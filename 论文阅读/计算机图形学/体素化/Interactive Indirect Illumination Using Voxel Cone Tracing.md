# Interactive Indirect Illumination Using Voxel Cone Tracing

![image-20201216181947607](Interactive Indirect Illumination Using Voxel Cone Tracing.assets/image-20201216181947607.png)

本文主要基于分层的<span style="color:red;font-size:1.3rem">体素八叉树</span>。通过一个常规的场景网格，加上**近似体素**<span style="color:red;font-size:1.3rem">锥跟踪</span>（此技术允许对能见度和传入的能量进行**快速估算**），本文可以实时**生成和更新**这个体素八叉树。

本文可以在25~70 FPS的表现下，为`Lambertian`材料和`Glossy`材料添加 *2 light bounce*的GI，其性能表现几乎和场景无关、且**不局限于低频照明**。

> 它显示了几乎与场景无关的性能，因为我们尽量避免在我们的计算中涉及实际网格。
>
> 建议主题：Fluent

## 1. Introduction

离线不行；预计算限制太大。

本文方法的==核心==是**预过滤**场景几何的层次八叉树。考虑到效率，这个表示以==动态稀疏八叉树==的形式存储在GPU上。利用一种新的==voxel cone tracing technique==，我们依靠这种**预滤波**，来快速估计**可见性**，并将来自光源的**间接能量**投射到结构中。

八叉树首先基于场景的静态部分进行构建，然后根据移动物体，或场景改变，来进行**更新**。



## 2. Previous Work

当前最有效的实时方案几乎都基于屏幕空间，但是忽略了离屏信息。本文的工作推导出了场景的**分层表示**，产生了一个规则的结构，以促进光的传输，实现实时性能。



## 3. Algorithm overview

![image-20201217190403212](Interactive Indirect Illumination Using Voxel Cone Tracing.assets/image-20201217190403212.png)

此算法主要按如图所示:arrow_up:的三步：

+ 首先将**来在静态光源**的入射光（能量和方向）注入到**稀疏体素八叉树**的叶子中。具体做法：从所有光源，来对场景进行光栅化，然后对每一个可见的表面片元，溅射一个光子(==splatting a photon==)。

  > This is done by rasterizing the scene from all light sources and splatting a photon for each visible surface fragment. 

+ 对入射辐射度值进行过滤，并将值存入八叉树的更上级（**mipmap**）。本文依靠一个紧凑的==高斯波瓣表示==，来存储入射光的**过滤分布**——通过屏幕空间四叉树分析`screen-space quad-tree analysis`，这是个并行过程。

  > 本文的体素滤波方案也以视图相关的方式处理NDF(正态分布函数)和BRDF

+ 最后，从相机角度，进行渲染。作者使用==近似圆锥追踪==，来进行最后的采集——在整个半球上发送几个圆锥，来收集分布在**八叉树**中的照明。对于**类Phong的BRDF**，使用**5**个左右的宽锥来近似整个场景的漫反射能量，而在反射方向上（视线的），则使用**一个紧凑的圆锥**来捕捉高光。



## 4. our hierarchical voxels structure

正如之前所言，本文的核心想法是：构建场景几何的**预过滤分层体素表示**，考虑到效率，这个表示用**稀疏八叉树**存储。

### 4.1 Structure description

根节点代表整个场景，其子节点代表场景的1/8，迭代这个过程。这种结构允许我们查询过滤后的场景信息，并通过**树层次的下降**来增加精度。

**GPU** **representation**：树节点存储在**线性GPU内存**中，节点被分组为2×2×2的`tiles`。这个分组允许我们存储一个**指向所有2×2×2个子节点的**指针。此外，每个节点都包含一个**指针**，指向存储在**纹理内存**中的==voxel volume==，`a brick`。这种表示是**稀疏的**，意味着空节点可以被压缩，同时每个节点的信息存储在内存中，意味着可以使用硬件的==三线性插值==。

但这种`brick`方法，不适用于小`birck`的场景，因为边界处的体素需要复制邻居体素，来保证**inter-brick**插值正确。==解决方法==：在使用$3\times3$的`brick`的同时，假设==体素中心==位于节点角落处，而不是节点中心:arrow_down:。这确保总是可以在一个包含2×2×2节点集的`brick`内计算插值。

![image-20201217200115005](Interactive Indirect Illumination Using Voxel Cone Tracing.assets/image-20201217200115005.png)

> 冗余并没有被消除，但是与添加边界相比，为了相同的采样精度，我们使用了不到一半的内存。这种内存减少允许我们向结构中添加邻居点，使我们能够快速访问空间上的==邻近节点和父节点==。这些连接对于将直接照明分配到树的所有层次来说，是非常重要的。



### 4.2 Interactive voxel hierarchy construction and dynamic updates

本文通过使用GPU的光栅化通道，提出了一个新的实时**体素化方法**。为了扩展到非常大的场景，此方法避免了**全规则网格**来作为中间步骤，而是直接构造**八叉树**。

> 容易观察到：场景的大部分都是静态的，不需要每帧更新。

半静态对象和完全动态对象都存储在相同的八叉树结构中，以便于简单遍历和**统一过滤**。使用**时间戳机制**`time-stamp`来区分这两种类型，以防止半静态部分每帧更新。

本文的==结构创建算法==主要是两步：**八叉树创建**和**Mips Mapping**

+ **八叉树创建**。

  + 首先使用**GPU光栅化管道**创建八叉树。沿着场景的三个主轴，对网格进行三次光栅化。

  + 通过禁用**深度测试**，来防止剔除，我们为每个**潜在存在的叶子节点**生成至少一个**片元着色器线程**。每个线程从上而下进行访问，直到找到正确的叶子节点，就写入数据（*纹理颜色、法线、材质*）。

    + 当一个节点需要被==细分==时，一组2×2×2的子节点被“**分配**”在全局共享`node buffer`内。这组子节点的地址被写入到原节点的“子”指针中，线程继续向下访问。

    > `global thread list`用来解决并行线程，同时拆分一个节点的冲突。

  + 叶子中的值，直接写入相关联的`brick`，其分配类似于节点，存入一个`shared brick buffer`中。

+ **Dynamic update**。

  + 更新动态物体，相对于上一部分，**唯一的区别**是，由这些对象生成的新体素不能覆盖结构中现有的静态部分。因此，动态物体的信息存储在缓冲区的末尾。

+ **Mips Mapping**

  + 对于一个n层的八叉树，只需要简单的$n-1$步。在每一层中，通过当前节点的子节点`brick`，进行过滤计算。每个节点包含一个$3\times3$体素brick（边界重用）。实践中，使用一个$3\times 3$高斯加权算子进行加权平均。

![image-20201217204051577](Interactive Indirect Illumination Using Voxel Cone Tracing.assets/image-20201217204051577.png)

> MipMapping过程应该是从下至上的

### 4.3 Voxel representation

在一个给定级别上，每个`voxel`必须代表较低级别的`light behavior`（这样嵌套，就可以代表==整个场景跨度==）。为此，作者用**描述底层数据**的分布，来建模方向信息。我们将其应用于法线和光线方向。

本文选择仅存储**各向同性高斯波瓣**，其特征由**平均向量**D和**标准差**σ表示。为了简化插值，方差通过范数|D|进行编码，$\sigma^2=\frac{1-|D|}{|D|}$。在第七节，会描述如何使用这些数据。



## 5. Approximate Voxel Cone Tracing

此方法首先用于过滤，来抗锯齿。想法是：沿着射线步近，然后在本文的层次表示中，进行查找（查找的层）