# Foveated Photon Mapping

***IEEE Transactions on Visualization and Computer Graphics***

![image-20211206125542839](Foveated Photon Mapping.assets/image-20211206125542839.png)

## 1. 介绍

==光子映射方法==（`Photon mapping`）是一种有效的方法，可以为不同材质的场景渲染`GI`。为了进一步提高渲染效率，作者将光子映射适应于`foveated rendering`的框架，这带来了两个问题。第一个问题是如何在`foveal`区域产生**高密度的光子**，来渲染高质量的图像。第二个问题是如何用**高密度的光子**提高**耗时的光子追踪过程**的性能。

在本文中，作者提出`foveated photon mapping`来解决上述两个问题。为了解决第一个问题，引入了`foveated photon tracing`方法，根据**传统的光子追踪方法**，在`foveal`区域生成高密度的光子。我们在渲染中使用**传统光子追踪法**和**注视点光子追踪法**产生的光子，用一个新的**辐射度计算函数**计算三维场景的辐射度。为了解决第二个问题，作者提出了==时域光子管理方法==，以选择和更新前一帧的**有效注视点光子**。此外，本文的方法支持具有多种材料的动态场景，如漫反射、镜面、`glossy`和透明材料。

作者比较了**1亿光子的光子映射**（`Ground Truth`，GT）、**300万光子的本文方法**（`Ours`）和**300万光子的光子映射**（`PM3M`）所渲染的单眼图像，如图`1`所示。本文方法在`foveal`区域显示出比`PM3M`更好的**GI效果**。



## 2. FOVEATED PHOTON MAPPING

`Foveated photon mapping`是基于注视点渲染中**多重照明分辨率的思想**，它通过在`foveal`区域实现比周边区域**更高的光子密度**来计算`foveal`区域的**高质量GI**。为了在`foveal`区域追踪更多的光子，在追踪**来自光源的光子**的==常规光子追踪==步骤之后，作者引入了==foveated光子追踪方法==来追踪`foveal`区域的光子。为了处理动态场景，作者采用`Tawara`的想法，将光子分为两类：<**静态场景中具有正流量的光子**> 和 <**动态物体中具有正或负流量的光子**>。因此，将这些光子存储在`4`个**光子图**中：$M_{ls}$存储静态场景的光子；$M_{ld}$存储动态物体的光子，$M_{fs}$存储静态场景的**foveated光子**，$M_{fd}$存储动态物体的**foveated光子**。

每个光子都有`4`个属性：`dir`代表光子是从哪个方向追踪过来的；`flux`是光子的能量；`pos`代表光子的位置；`isAcc`是一个双值标志，将用于**能量归一化**。**foveated光子**有两个额外的属性：`next f`是沿着追踪路径的下一个**凹陷光子**的`ID`；`nearl`是最近的光子的ID（这个光子的通量需要是正值，否则，该值被设置为`-1`）。为了获得更好的性能，并保持`foveal`区域相邻帧的**时间一致性GI效果**，前一帧的**foveated光子**被更新并重新用于当前帧。在渲染当前帧时，**注视点区域的辐射度**是用光子和**foveated光子**的新辐射度计算函数来估计的，而周边区域的辐射度只用光子来估计。

给定一个具有静态部分`S`和动态物体`D`的三维场景，光源`L` ，当前帧的视角$V$，上一帧的视角$V^/$，注视点区域$r_f$，`focus`区域$r_t$（包括**注视点和过渡区域**），输出分辨率$(w,h)$，每个像素的**最大foveated光子路径**`N`。帧缓冲区通过使用==算法1==进行渲染。

![image-20211206154716412](Foveated Photon Mapping.assets/image-20211206154716412.png)

**算法1**的动机是：通过在`foveal`区域获得比周边区域**更高的光子密度**来计算**高质量的GI**。在算法1的初始化中，首先追踪来自光源的**静态场景的光子**，并生成光子图$M_{ls}$（第`1`行）。由于场景不会改变，**$M_{ls}$只计算一次**。$M_{ld, fs, fd}$被初始化为`NULL`（第`2`行）。每个像素的**光子路径计数器**`fbm`是一个对应于帧缓冲区的**二维数组**，它记录了每个像素**需要追踪的`foveated`光子路径的总数**。在`initMask`中，作者在`fbm`的`focus`区域设置`N`（第`3`行）。每个像素的**静态foveated光子路径记录器**`fbp`是一个对应于帧缓冲区的**二维数组列表**，用来存储从这个像素开始的**每条静态foveated光子路径的第一个静态foveated光子的`ID`**（第4行）。**静态foveated光子路径**意味着该路径中**foveated光子的最近光子**都是$M_{ls}$中的光子。

在每一帧中，首先追踪**动态物体的光子**（第`6`行）。然后，如果当前帧不是第一帧，我们需要更新**静态foveated光子图**$M_{fs}$，每像素光子路径计数器`fbm`，最后一帧的每像素静态foveated光子路径记录器`fbp`（第`7-8`行）。之后，我们进行**foveated光子追踪**，在$M_{fs, fd}$中生成新的**foveated光子**，并更新`fbp`（第`9`行）。在第`10`行计算**能量归一化参数**`η`，用于`focus`区域的辐射度计算。最后，用来自四个光子图$M_{ls,ld, fs, fd}$的光子对场景进行渲染（第`11`行）。

------

对于静态场景，光子是用**传统的光子映射方法**（$PT_{s}$，第`1`行）。光子从光源发射到场景中，然后在场景的表面上反弹数次，并停留在**`diffused`表面**上。对于动态物体，作者使用**基于辐照度缓存的方法**来追踪**动态物体的光子**（$PT_{d}$，第`6`行）。首先，用来自光源的`cube map`渲染**包含动态物体的场景**。如果`cube map`中的像素属于动态物体，那么**从光源到这个像素的三维位置的方向**将被记录下来。作者随机地对这些方向进行采样，并沿着**采样的方向**追踪光子。光子在场景中会反弹几次。当一个光子击中**动态物体的表面**时，它在相交点产生**两条射线**，继续追踪光子。第一条射线被视为正射线，它被**反射或透射**出**正能量**，或根据表面的材料在场景中**被吸收**。正光线在光线与场景表面的**所有交叉点**上都留下了**正能量的光子**。第二条射线被视为==负射线==，它穿透动态物体并携带**负能量**。负射线只在**射线与静态场景表面的交汇处**留下带有**负能量的光子**——因为我们需要从**静态辐照度缓冲区**中减去**由于动态物体的遮挡而产生的能量**。最后，正能量的光子和负能量的光子都储存在$M_{ld}$中。


### 2.1 Foveated Photon Tracing

在**foveated光子追踪**中，**foveated光子**从视角被追踪，使其穿过`focus`区域并击中场景的表面。**需要追踪的光子路径的数量**是根据`fbm`。反弹方向和**foveated光子的通量**是根据场景中**击中点的材料**和它们**最近的光子**来确定的。

图`2`描述了**foveated光子追踪**的过程。场景包含一个透明球体、一个镜面立方体和漫反射墙。这个立方体是动态的。与普通的光子追踪相同，**foveated光子**只放在**漫反射表面**上。红线显示了从光源到在漫反射墙上产生光子（**红点**）的追踪路径，该方法**基于辐照度缓存**。当光线击中**动态立方体的顶部**时，它产生了两条光线：**实线和虚线**。实线显示了产生具有**正能量的光子**$p_l^4$，而虚线表示**产生负能量光子的光线追踪路径**$p_l^{/1}$。 **绿线**表示从观点`V`出发的追踪路径。视点`V`，通过图像平面上的**foveated像素**`px`，通过**foveated光子追踪方法**产生**foveated光子**（**绿点**）。当**foveated光子**碰到镜面立方体或透明球体的表面时，它们会根据反射或折射定律沿着方向反弹。而如果**foveated光子**撞上了**漫反射墙**，就会找到**最近的光子**。如果这个**光子带有正能量**，那么**foveated光子**的反弹方向就被设定为这个**最近的光子的入射方向的反方向**，否则，**foveated光子就被丢弃**。在图2中，**foveated光子**$p_f^1$的反弹方向被反转到**其最近的光子**$p_l^3$的入射方向，而$p_f^2$的反弹方向被设定为最近的光子$p^4_l$的入射方向。

![image-20211206163737611](Foveated Photon Mapping.assets/image-20211206163737611.png)

在确定**foveated光子的反弹方向**后，找到每个**追踪路径末端的foveated光子的最近的光子**，这个光子的通量值用于计算**路径上所有foveated光子的通量**。在图`2`中，$p^4_f$的通量设置与$p_l^2$的通量相同，$p_f^3$的通量设置与$p_l^1$的通量相同。$p^4_f$的通量被传输到$p_f^1$，$p_f^3$的通量被传输到$p_f^2$。对于每个**foveated光子**，沿着追踪路径的下一个**foveated光子**被记录在`next f`中，而**最近的具有正能量的光子的ID**被记录在`nearl`中。每个foveated光子路径的最大反弹深度值不会超过**预定的最大深度**，否则这个**foveated光子路径**中的**foveated光子**会被删除。在图`2`的情况下，最大反弹深度为`4`，$p_f^3$的反弹深度为`5`，所以$p_f^3$被移除。

在图`2`中，==蓝线==直观地显示了**通过像素px中心的追踪光线**，蓝色的断点椭圆显示了**px的聚集区域**。除了光子$p_l^3$之外，在渲染过程中还产生了两个**foveated光子** $p_f^1$和$p_f^2$来照亮`px`。在**foveated光子追踪**之后，作者对`4`个光子图$M_{ls,ld, fs, fd}$进行迭代，用公式`1`计算==能量归一化参数==`η`：

![image-20211206174138431](Foveated Photon Mapping.assets/image-20211206174138431.png)

### 2.2 Temporal Photon Management

由于追踪当前帧的所有**foveated光子**是非常昂贵的，重新使用**前一帧的foveated光子**可以提高性能并保持时间上的一致性。作者进行光子管理，以选择和更新**前一帧的光子**，并根据视角的变化、`foveal`区域的变化和动态物体的运动，**删除无效的光子**。

![image-20211206180103437](Foveated Photon Mapping.assets/image-20211206180103437.png)

首先，保留前一帧的`fbm`、`fbp`（第`1-2`行），并为当前帧初始化（第`3-4`行）。对于`focus`区域的每个像素`px`，我们把它反投影到三维空间，从当前视角`V`得到一个三维点`v`（第`6`行），然后从上一个视角$V^/$ (第`7`行)，得到它之前的投影$px^/$。如果`v`在静态场景的表面上，并且该表面是**漫反射的**，我们将根据前一帧的`fbp`和`fbm`的值来设置当前帧对应像素的`fbp`和`fbm`中的值（第`8-10`行）。否则，我们会从$M_{fs}$中删除沿静态光子路径的光子以及$fbp^/ [px^/]$中的路径（第`11-12`行）。



### 2.3 Rendering

为了在`foveal`区域实现**高质量的GI**，四个光子图$M_{ls,ld, fs, fd}$中的光子被用来收集`focus`区域的辐射度，而只有两个光子图$M_{ls,ld}$用来渲染外围区域。对于不同区域的一个给定的三维点x，其辐射度`I(x)`可以用公式`2`来计算：

![image-20211206182630461](Foveated Photon Mapping.assets/image-20211206182630461.png)

如果`x`在`foveal`区域，辐射度将由**加权辐射度估计函数** $g(x,M_{ls,ld, fs, fd},η)$来计算：

![image-20211206182833107](Foveated Photon Mapping.assets/image-20211206182833107.png)

其中`η`为**能量归一化参数**，$\gamma$为**收集光子的半径**，$M_d$指两张动态光子图$M_{ld,fd}$，$M_s$指两张静态光子图$M_{ls.fs}$，$f_r$为**BRDF函数**，$\phi(p)$为光子图中光子`p`的通量，$w_o$为从`x`到`V`的方向，$w_p$为光子`p`的入射方向。作者使用**基于辐照度缓存的方法**，将静态光子图中的光子贡献的辐射度与动态光子图中的光子贡献的辐射度用**权重系数**`k`进行混合：

![image-20211206183136653](Foveated Photon Mapping.assets/image-20211206183136653.png)

其中`p.r`、`p.g`和`p.b`分别表示$\phi$的通量中的红色、绿色和蓝色成分。如果`x`位于外围区域，那么辐射度将只用$M_{ls,ld}$中的光子来计算：

![image-20211206183304156](Foveated Photon Mapping.assets/image-20211206183304156.png)

过渡区域的`x`的辐射度可以通过使用**权重系数**`b`，对`foveal`区域的辐射度和周边区域的辐射度进行**线性内插**来计算：

![image-20211206183401955](Foveated Photon Mapping.assets/image-20211206183401955.png)



其中，`radius`是计算给定区域的像素半径的函数。在VR中，同样的有效光子被用来渲染一对立体图像。几乎所有在左眼中可见的物体都会在右眼视图中显示出来。我们对完整的左眼视图进行着色，然后通过使用重投影从完整的左眼视图中取样来渲染右眼视图。右眼视图只需要在没有找到有效样本的情况下对新的像素进行着色，而不是重新计算一切。



## 3. RESULTS AND DISCUSSION

### 3.1 实现

`foveal`区域的像素半径是公式`7`来计算的：

![image-20211206183617534](Foveated Photon Mapping.assets/image-20211206183617534.png)

其中，`foveal`区域的角度半径$e_f$被设定为$9.78^o$；`PPI`是HMD的像素密度，以每英寸像素衡量，HTC Vive为`615`ppi；b是HMD的瞳孔到镜头的距离，HTC Vive为`18`mm。



### 3.2 Quality

Todo



![image-20211206184133335](Foveated Photon Mapping.assets/image-20211206184133335.png)

![image-20211206184140699](Foveated Photon Mapping.assets/image-20211206184140699.png)













