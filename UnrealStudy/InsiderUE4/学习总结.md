# 原文

https://zhuanlan.zhihu.com/p/24170697



# GamePlay架构（一）Actor和Component

## UObject

UE创世，万物皆UObject，接着有Actor。藉着UObject提供的元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等，UE可以构建一个Object运行的世界。

<img src="学习总结.assets\image-20210525175503021-1621936563697.png" alt="image-20210525175503021" style="zoom:67%;" />

## Actor

<img src="学习总结.assets\image-20210525175557946.png" alt="image-20210525175557946" style="zoom:50%;" />

脱胎自`Object`的`Actor`也多了一些本事：Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)。

❓**思考：为何Actor不像GameObject一样自带Transform？**

- 因为UE跟贴近C++一些的缘故，所以设计哲学上就更偏向于C++的哲学：==不为你不需要的东西付代价==。一个Transform再加上附带的逆矩阵之类的表示，内存占用上其实也是挺可观的。

- 经过了UE的权衡和考虑，把Transform封装进了`SceneComponent`，当作`RootComponent`。

  

## Component

`UActorComponent`也是派生于UObject的一个子类，这意味着其实Component也是有UObject的那些通用功能的。

`TSet<UActorComponent*> OwnedComponents` 保存着这个Actor所拥有的所有Component，一般其中会有一个`SceneComponent`作为RootComponent。`TArray<UActorComponent*> InstanceComponents` 保存着**实例化的Components**。实例化是个什么意思呢，就是你在蓝图里Details定义的Component，当这个Actor被实例化的时候，这些附属的Component也会被实例化。

一个Actor若想可以被放进Level（关卡）里，就必须实例化`USceneComponent* RootComponent`。

<img src="学习总结.assets\image-20210525175923625.png" alt="image-20210525175923625" style="zoom:67%;" />

ActorComponent下面**最重要的一个Component就非SceneComponent莫属了**。SceneComponent提供了**两大能力**：

- 一是Transform
- 二是SceneComponent的互相嵌套。

❓**思考：为何ActorComponent不能互相嵌套？而在SceneComponent一级才提供嵌套？**

- ActorComponent下面当然不是只有SceneComponent，一些UMovementComponent，AIComponent，或者是我们自己写的Component，都是会直接继承ActorComponent的。但很奇怪的是，ActorComponent却是不能嵌套的，在UE的观念里，好像只有带Transform的SceneComponent才有资格被嵌套，好像Component的互相嵌套必须和3D里的transform父子对应起来。
- 从功能上来说，UE更倾向于编写功能单一的Component（如UMovementComponent），而不是一个整合了其他Component的大管家Component（当然如果你偏要这么干，那UE也阻止不了你）。

**❓思考：Actor的SceneComponent哲学**

​	//toCopy

❓**思考：Actor之间的父子关系是怎么确定的？**

- 你应该已经注意到了Actor里面的`TArray<AActor*> Children`字段，所以你可能会期望看到Actor:AddChild之类的方法，很遗憾。在UE里，==Actor之间的父子关系却是通过Component确定的==。同一般的Parent:AddChild操作原语不同，UE里是通过**Child:AttachToActor**或**Child:AttachToComponent**来创建父子连接的。

  ```c++
  void AActor::AttachToActor(AActor* ParentActor, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && ParentActor)
      {
          USceneComponent* ParentDefaultAttachComponent = ParentActor->GetDefaultAttachComponent();
          if (ParentDefaultAttachComponent)
          {
              RootComponent->AttachToComponent(ParentDefaultAttachComponent, AttachmentRules, SocketName);
          }
      }
  }
  void AActor::AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && Parent)
      {
          RootComponent->AttachToComponent(Parent, AttachmentRules, SocketName);
      }
  }
  ```

- Actor父子之间的“关系”隐含了许多数据，而这些数据都是在Component上提供的。==Actor其实更像是一个容器，只提供了基本的创建销毁，网络复制，事件触发等一些逻辑性的功能==，而把父子的关系维护都交给了具体的Component，**所以更准确的说，其实是不同Actor的SceneComponent之间有父子关系，而Actor本身其实并不太关心。**

📚**聊一聊ChildActorComponent**

![image-20210525181105823](学习总结.assets\image-20210525181105823.png)

同作为最常用到的Component之一，`ChildActorComponent`担负着**Actor之间互相组合的胶水**。这货在**蓝图里静态存在的时候**其实并不真正的创建Actor，而是在之后**Component实例化**的时候才真正创建。

```c++
void UChildActorComponent::OnRegister()
{
    Super::OnRegister();
    if (ChildActor)
    {
        if (ChildActor->GetClass() != ChildActorClass)
        {
            DestroyChildActor();
            CreateChildActor();
        }
        else
        {
            ChildActorName = ChildActor->GetFName();
            USceneComponent* ChildRoot = ChildActor->GetRootComponent();
            if (ChildRoot && ChildRoot->GetAttachParent() != this)
            {
                // attach new actor to this component
                // we can't attach in CreateChildActor since it has intermediate Mobility set up
                // causing spam with inconsistent mobility set up
                // so moving Attach to happen in Register
                ChildRoot->AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
            }
            // Ensure the components replication is correctly initialized
            SetIsReplicated(ChildActor->GetIsReplicated());
        }
    }
    else if (ChildActorClass)
    {
        CreateChildActor();
    }
}
void UChildActorComponent::OnComponentCreated()
{
    Super::OnComponentCreated();
    CreateChildActor();
}
```

这就导致了一个问题，当你把一个ActorClass拖进Level后，这个Actor实际是已经实例化了,你可以直接调整这个Actor的属性。但是你把它拖到另一个Actor Class里，它只会给你空空白白的ChildActorComponent的DetailsPanel，你想调整Actor的属性，就只能等生成了之后，用蓝图或代码去修改。这一点来说，其实还是挺不方便的，我个人觉得应该是还有优化的空间。

> UE终于听到了人民群众的呼声，在4.14里增加了Child Actor Templates来支持在子ChildActor的DetailsPannel里查看和修改属性。



# GamePlay架构（二）Level和World

> 由一个或多个Level组成一个World。

## Level

在UE的世界中，我们之前已经有了空气（C++）,土壤（UObject），物件（Actor）。而现在UE又施展神力创建了一片片大陆（Level），在这片大陆上（.map文件），Actor们秩序井然，各种地形拔地而起，植被繁茂，天空雾云缭绕，圣光普照，这也是玩家们降生开始精彩冒险的地方。

![image-20210525181811179](学习总结.assets\image-20210525181811179.png)

可以从ULevel的前缀U看出来**Level（大陆）也确实是继承于UObject（土壤）**的。那既然同属于Object下面的各Actor们都拥有了一定的智能能力（支持蓝图脚本），Level自然也得体现出大地的意志，所以**默认带了一个土地公（ALevelScriptActor）**，允许我们在关卡里编写脚本，可以对本关卡里的所有Actor通过名字呼之则来，**关卡蓝图实际上就代表着该片大陆上的运行规则**。

在Level已经有了管理者之后，一开始大家都挺满意，但渐渐的就发现，**好像各个Level需要的功能好像都差不多**，都是修改一下光照，物理等一些属性。所以为了方便起见，**UE便给每一个Level也都默认配了一个书记官（Info）**，他一一记录着本Level的各种规则属性，在UE需要的时候便负责相告。更重要的是，在Level需要有其他管理人员一起协助的时候，他也记录着`GameMode`的名字来让UE可以指派。

前面我们说过，有一些Actor是不“显示”的（**没有SceneComponent**），是不能“摆放”到Level里的，但是它依然可以在关卡里出力。其中一个家族系列就是`AInfo`和其子类。今天我们只简单介绍一下跟Level直接相关的一位书记官：==AWorldSettings==。

![image-20210525182200300](学习总结.assets\image-20210525182200300.png)

> 虽然名字叫做WorldSettings，但其实只是跟Level相关

❓**思考：为何AWorldSettings要放进在Actors[0]的位置？而ALevelScriptActor却不用？**

```c++
void ULevel::SortActorList()
{
    //[...]
    TArray<AActor*> NewActors;
    TArray<AActor*> NewNetActors;
    NewActors.Reserve(Actors.Num());
    NewNetActors.Reserve(Actors.Num());
    // The WorldSettings tries to stay at index 0
    NewActors.Add(WorldSettings);
    // Add non-net actors to the NewActors immediately, cache off the net actors to Append after
    for (AActor* Actor : Actors)
    {
        if (Actor != nullptr && Actor != WorldSettings && !Actor->IsPendingKill())
        {
            if (IsNetActor(Actor))
            {
                NewNetActors.Add(Actor);
            }
            else
            {
                NewActors.Add(Actor);
            }
        }
    }
    iFirstNetRelevantActor = NewActors.Num();
    NewActors.Append(MoveTemp(NewNetActors));
    Actors = MoveTemp(NewActors);   // Replace with sorted list.
    // Add all network actors to the owning world
    //[...]
}
```

- 实际上通过这一段代码可知，**Actors们的排序依据**是把那些**“非网络”的Actor放在前面**，而把**“网络可复制”的Actor们放在后面**，然后加一个起始索引标记`iFirstNetRelevantActor`，相当于为网络Actor划分了一个缓存，从而加速了网络复制时的检测速度。`AWorldSettings`因为都是静态的数据提供者，在游戏运行过程中也不会改变，不需要网络复制，所以也就可以一直放在前列，而如果再加个规则，一直放在第一个的话，也能同时把AWorldSettings和其他的前列Actor们再度区分开，在需要的时候也能加速判断。**ALevelScriptActor因为是代表关卡蓝图，是允许携带“复制”变量函数的，所以也有可能被排序到后列**。

**❓思考：既然ALevelScriptActor也继承于AActor,为何关卡蓝图不设计能添加Component？**

- 平常我们在创建Actor的时候，我们蓝图界面是可以创建Component的。那为什么在关卡蓝图里，却不能这么做（没有提供该界面功能）？虽然在图里标出了Level中拥有**ModelComponents**，但那其实只是**针对BSP应用的一个子集**。通过源码发现，其实UE自己也是在C++里往`ALevelScriptActor`添加**UInputComponent**来**实现关卡蓝图可以响应事件**。

- 其实既然ALevelScriptActor是个Actor，那意味着我们当然可以为它添加组件，实际上也确实可以这么做。比如你可以在关卡蓝图里这么干：

  <img src="学习总结.assets\image-20210525182911023.png" alt="image-20210525182911023" style="zoom:67%;" />

❓那么好好想想，为啥`UE`要给你这么一个**关卡蓝图界面**呢？

- 在此，我也只能进行一番猜测，`ALevelScriptActor`作为一个特化的Actor，却把Components列表界面给隐藏了，说明UE其实是不希望我们去复杂化关卡构成的。
- 假设说UE开放了关卡Component，那么我们在创建组件时就必然要考虑一个问题：哪些是ActorComponent，哪些是LevelComponent，再怎么ALevelScriptActor本质是个Actor，但Level的概念还是要突出，ALevelScriptActor的Actor本质是要隐藏的。所以用户就会多一些心智负担，可能混淆。而如果像这样不开放，大家的思路就都转向先创建个Actor，然后再往之上添加component，思路会比较统一清晰。
- 再之，从游戏逻辑的组织上来说，Level其实更应该表现为一个Actor的容器。UE其实也是不鼓励在Level里编写太复杂的逻辑的。所以才接着会有了之后的GameMode,Controller那些真正的逻辑控制类（后续会再细讨论）。



## World

终于，到了把大陆们（Level）拼装起来的时候了。可以用==SubLevel==的方式：

<img src="学习总结.assets\image-20210525183442256.png" alt="image-20210525183442256" style="zoom:80%;" />

也支持`WorldComposition`的方式自动把项目里的所有Level都组合起来，并设置摆放位置：

<img src="学习总结.assets\image-20210525183500177.png" alt="image-20210525183500177" style="zoom:80%;" />

简单本质来说，就是==一个World里有多个Level==，这些Level在什么位置，是在一开始就加载进来，还是Streaming运行时加载。**UE里每个World支持一个PersistentLevel和多个其他Level**：

![image-20210525183602080](学习总结.assets\image-20210525183602080.png)

**Persistent的意思是一开始就加载进World**，**Streaming是后续动态加载的意思**。Levels里保存有所有的、当前已经加载的Level，`StreamingLevels`保存整个World的**Levels配置列表**。PersistentLevel和CurrentLevel只是个快速引用。在编辑器里编辑的时候，CurrentLevel可以指向其他Level，但**运行时CurrentLevel只能是指向PersistentLevel**。

❓**思考：为何要有主PersistentLevel？**

- 首先，World至少得有一个Level，就像你也得先出生在一块大陆上才可以继续谈起去探索别的新大陆。所以这块玩家出生的大陆就是主Level了。当然了，因为我们也可以同时配置别的Level一开始就加载进来，其实跟PersistentLevel是差不多等价的，但再考虑到另一问题：Levels拼接进World一起之后，各自有各自的worldsetting，那整个World的配置应该以谁的为主？
- ==World的Settings也是以PersistentLevel为主的==，但这也并不以为着其他Level的Settings就完全没有作用了，本篇也无法一一列出所有配置选项来说明，简单来说，就是**需要在整个世界范围内起作用的配置选项（比如VR的WorldToMeters，KillZ，WorldGravity其他大部分都是）就是需要从主PersistentLevel的配置中提取**。而一些配置选项可以在单独Level中起作用的，比如在编辑Level时的**光照质量配置就是一个个Level单独的**，目前这种配置很少，但可能以后也会增加。

**❓思考：Levels们的Actors和World有直接关系吗？**

- 当别的Level被添加进当前World之后，我们能直接在WorldOutliner里看到其他Level的Actor们。

![image-20210525184037168](学习总结.assets\image-20210525184037168.png)

- 但这并不代表着World直接引用了Level里的Actor们。TActorIteratorBase（World的Actor迭代器）内部的实现也只是在遍历Levels来获得所有Actor。当然World为了更快速的操作Controllers和Pawn也都保存了引用。但**Levels却共享着World的一个PhysicsScene**，这也https://learn.unrealengine.com/course/3536489?r=False&ts=637454196686960980意味着**Levels里的Actors的物理实体其实都是在World里的**，这也好理解，毕竟物理的碰撞之类的当然要是全局的了。再说到导航，**World在拼接Level的时候，也是会同时把两个Level的导航网格给“拼接”起来的**。当然目前还不是深入细节的时候，现在只要从大局上明白World-Level-Actor的关系。

## 总结

==Level作为Actor的容器，同时也划分了World==，一方面支持了Level的动态加载，另一方面也允许了团队的实时协作，大家可以同时并行编辑不同的Level。一般而言，一个玩家从游戏开始到结束，UE会创造一个GameWorld给玩家并一直存在。**玩家切换场景或关卡，也只是在这个World中加载释放不同的Level**。既然Level拥有了管理者（LevelScriptActor），玩家可以编写特定关卡的逻辑，那么我们能否对World这种层次编写逻辑呢？答案是肯定的，不过本文篇幅有限，敬请期待下篇。



# GamePlay架构（三）WorldContext，GameInstance，Engine

## WorldContext

**一个游戏里是只有一个World吗**？==答案是否定的==，首先`World`就不是只有一种类型，比如**编辑器**本身就也是一个World，里面显示的**游戏场景也是一个World**，这两个World互相协作构成了我们的编辑体验。然后点播放的时候，引擎又可以生成新的类型World来让我们测试。简单来说，UE其实是一个平行宇宙世界观。
以下是一些世界类型：

```c#
namespace EWorldType
{
	enum Type
	{
		None,		// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels
		Game,		// The game world
		Editor,		// A world being edited in the editor
		PIE,		// A Play In Editor world
		Preview,	// A preview world for an editor tool
		Inactive	// An editor world that was loaded but not currently being edited in the level editor
	};
}
```

而UE用来管理和跟踪这些`World`的工具就是==WorldContext==：

![image-20210527194057422](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527194057422.png)



`FWorldContext`保存着`ThisCurrentWorld`来指向**当前的World**。而当需要从一个World切换到另一个World的时候（比如说当点击播放时，就是从Preview切换到PIE），FWorldContext就用来保存**切换过程信息**和**目标World上下文信息**。所以一般在切换的时候，比如OpenLevel，也都会需要传`FWorldContext`的参数。对于独立运行的游戏，WorldContext只有唯一个。**而对于编辑器模式，则是一个WorldContext给编辑器，一个WorldContext给PIE（Play In Editor）的World**。一般来说我们不需要直接操作到这个类，引擎内部已经处理好各种World的协作。不仅如此，**FWorldContext还保存着World里Level切换的上下文**：

```c#
struct FWorldContext
{
    [...]
	TEnumAsByte<EWorldType::Type>	WorldType;

	FSeamlessTravelHandler SeamlessTravelHandler;

	FName ContextHandle;

	/** URL to travel to for pending client connect */
	FString TravelURL;

	/** TravelType for pending client connects */
	uint8 TravelType;

	/** URL the last time we traveled */
	UPROPERTY()
	struct FURL LastURL;

	/** last server we connected to (for "reconnect" command) */
	UPROPERTY()
	struct FURL LastRemoteURL;

}
```

这里的`TravelURL`和`TravelType`就是负责设定下一个Level的**目标**和**转换过程**。

```c++
// Traveling from server to server.
UENUM()
enum ETravelType
{
	/** Absolute URL. */
	TRAVEL_Absolute,
	/** Partial (carry name, reset server). */
	TRAVEL_Partial,
	/** Relative URL. */
	TRAVEL_Relative,
	TRAVEL_MAX,
};

void UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )
{
	FWorldContext &Context = GetWorldContextFromWorldChecked(InWorld);
	// set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().
	Context.TravelURL    = NextURL;
	Context.TravelType   = InTravelType;
    [...]
}
```

粗略的流程是：UE在**OpenLevel**的时候， 先设置当前World的Context上的`TravelURL`，然后在`UEngine::TickWorldTravel`的时候判断TravelURL非空，来真正执行Level的切换。具体的Level切换详细流程比较复杂，目前先从大局上理解整体结构。总而言之，==WorldContext既负责World之间切换的上下文，也负责Level之间切换的操作信息。==

❓**思考：为何Level的切换信息不放在World里？**

- 因为UE有一个逻辑，一个World只有一个PersistentLevel（见上篇），而当我们OpenLevel一个PersistentLevel的时候，实际上引擎做的是先释放掉当前的World，然后再创建个新的World。所以如果我们把下一个Level的信息放在当前的World中，就不得不在释放当前World前又拷贝回来一遍了。
- 而`LoadStreamLevel`的时候，就只是在当前的World中载入对象了，所以其实就没有这个限制了。

```c++
void UGameplayStatics::LoadStreamLevel(UObject* WorldContextObject, FName LevelName,bool bMakeVisibleAfterLoad,bool bShouldBlockOnLoad,FLatentActionInfo LatentInfo)
{
	if (UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject))
	{
		FLatentActionManager& LatentManager = World->GetLatentActionManager();
		if (LatentManager.FindExistingAction<FStreamLevelAction>(LatentInfo.CallbackTarget, LatentInfo.UUID) == nullptr)
		{
			FStreamLevelAction* NewAction = new FStreamLevelAction(true, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo, World);
			LatentManager.AddNewAction(LatentInfo.CallbackTarget, LatentInfo.UUID, NewAction);
		}
	}
}
```

❓**思考：为何World和Level的切换要放在下一帧再执行？**

- 首先`Level`的加载显然是比较慢的，需要载入Map，相应的Mesh，Material……等等。所以这个操作就必须异步化，异步的话其实就剩下两种方式，一种是先记录下来信息之后再执行；一种是命令模式立马往队列里压个命令之后再执行。注意，因为`OpenLevel`还要相应在主线程生成相应**Actor对象**，所以有些部分还是要在主线程完成的。这两种模式其实都可以达成需求，前者更加简单明了，后者相对统一。UE也是个进化过来的引擎，也并不是所有的代码都完美无缺。猜想其实也是一开始这么简单就这么做了，后来也没有特别大的改动的动力就一直这样了。引擎最终比的是生产效率的提高，确实也不是代码有多优雅。



## GameInstance

那么这些WorldContexts又是保存在哪里的呢？追根溯源：

![image-20210527195134128](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195134128.png)

`GameInstance`里会保存着**当前的WorldConext**和**其他整个游戏的信息**。明白了==GameInstance是比World更高的层次==之后，我们也就能明白为何那些独立于Level的逻辑或数据要在`GameInstance`中存储了。

这一点其实也很好理解，大凡游戏引擎都会有一个`Game`的概念，不管是叫Application还是Director，它都是玩家能直接接触到的最根源的操作类。而UE的`GameInstance`因为继承于`UObject`，所以就**拥有了动态创建的能力**，所以我们可以通过指定`GameInstanceClass`来让UE使用我们**自定义的GameInstance子类**。所以不论是C++还是BP，==我们通常会继承于GameInstance，然后在里面编写应用于整个游戏范围的逻辑==:star:。

因为经常有初学者会问到：我的Level切换了，变量数据就丟了，我应该把那些数据放在哪？再清晰直白一点，==GameInstance就是你不管Level怎么切换，还是会一直存在的那个对象==！



## Engine

让我们继续再往上，终于得见UE大神：

![image-20210527195358337](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195358337.png)



此处`UEngine`分化出了两个子类：`UGameEngine`和`UEditorEngine`。众所周知，UE的编辑器也是UE用自己的引擎渲染出来的，采用的也是`Slate`那套UI框架。好处有很多，比如跨平台比较统一，UI框架可以复用一套控件库，Dogfood等等，此处不再细讲。所以**本质上来说，UE的编辑器其实也是个游戏**！我们是在编辑器这个游戏里面创造我们自己的另一个游戏。话虽如此，但比较编辑器和游戏还是有一定差别的，所以UE会在不同模式下根据编译环境而采用不同的具体Engine类，而在==基类UEngine==里通过一个`WorldList`保存了所有的`World`。

- `Standlone Game`：会使用UGameEngine来创建出唯一的一个GameWorld，因为也只有一个，所以为了方便起见，就直接保存了`GameInstance`指针。
- 而对于编辑器来说，EditorWorld其实只是用来预览，所以并不拥有OwningGameInstance，而PlayWorld里的`OwningGameInstance`才是间接保存了GameInstance.

目前来说，因为UE还不支持同时运行多个World（当前只能一个，但可以切换），所以`GameInstance`其实也是唯一的。提前说些题外话，虽然目前网络部分还没涉及到，但是当我们在Editor里进行MultiplePlayer的测试时，每一个Player Window里都是一个World。如果是DedicateServer模式，那DedicateServer也会是一个World。

最后实例化出来的`UEngine`实例用一个**全局的GEngine变量**来保存。至此，我们已经到了引擎的最根处:

```c++
//UnrealEngine\Engine\Source\Runtime\Engine\Private\UnrealEngine.cpp
ENGINE_API UEngine*	GEngine = NULL;
```

**GEngine可以说是一切开始的地方了**。翻看引擎源码，到处也可以看见从`GEngine->`出来的引用。



## GamePlayStatics

既然我们在引擎内部C++层次已经有了**访问World**、**操作Level**的能力，那么在暴露出的蓝图系统里，UE为了我们的使用方便，也在**Engine层次**为我们提供了便利操作蓝图函数库。

```c++
UCLASS ()
class UGameplayStatics : public UBlueprintFunctionLibrary 

UCLASS ()class UGameplayStatics : public UBlueprintFunctionLibrary 
```

我们在蓝图里见到的`GetPlayerController`、`SpawActor`和`OpenLevel`等都是来至于这个类的接口。这个类比较简单，相当于一个C++的静态类，只为蓝图暴露提供了一些静态方法。在想借鉴或者是查询某个功能的实现时，此处往往会是一个入口。

## 总结

从结构上而言，我们已经来到了最根源的地方。GEngine仿佛就是一棵大树的根，当我们拎起它的时候，也会带出整个游戏世界的各个对象。但目前这些对象：==Object->Actor + Component->Level->World->WorldContext->GameInstance->Engine==，确实已经足够表达UE游戏世界的各个部分。

那作为GamePlay部分而言，我们还有一个问题：UE是如何把在该对象结构上表达游戏逻辑的？
如果说：“程序 = 数据 + 算法”的话，那==UE的GamePlay我们已经讨论完了数据部分==，而下篇我们将开始讨论UE的**游戏逻辑“算法”部分**。



# GamePlay架构（四）Pawn

## Component

`Actor`可以说是由`Component`组成的，所以`Component`其实是我们对象树里最底层的员工了。在UE里，Component表达的是“功能”的概念。比如说你要实现一个可以响应的WASD移动的功能，或者是VR里抓取的功能，甚至是嵌套另一个Actor的功能，这些都是一个个组件。==正确理解“功能”和“游戏业务逻辑”的区分是理解Component的关键要点==。

==所以我们在这一个层级上要编写的逻辑，是实现一个个“与特定游戏无关”的功能==。理想情况下，等你的一个游戏完成，你那些已经实现完成的Components是可以无痛迁移到下一个游戏中用的。换言之，一旦你发现你在Component中含有游戏的业务逻辑代码，这就是所谓的“Bad Smell”了，要警惕游戏架构是否恰当，是否没有很清晰的概念划分。

## Actor

如果说UE是一个大国家的话，那Actor无疑就是人口最大的民族了。StaticMeshActor，CameraActor……我们天天口里嚷嚷的也都是它。和Unity的`Prefab`对应的，在UE里我们用的最多的也是`BlueprintActor`了，我们也常常自定义我们的Actor子类来组装其他Component和Actor，然后再编写一些协作逻辑代码，就似乎完成了一个骁勇善战的特种兵，接下来就可以撒豆成兵般的往Level中扔了。

用的越广泛越多，往往错的也越多。似乎是受到了一种朴素的子承父业的精神感染，也或许是我们的面向对象编程都学得太好的缘故，我们都非常倾向于直接在Actor里堆砌逻辑。右键一个BlueprintActor，刚添加完Component，就立马撸起袖子来，Event、Function和Variable一个个罗列开来，噼里啪啦无不快活！但是且慢，这是最好的方式了吗？让我们一路带着这个问题，试着从UE角度去推演一下，重走一下Actor进化之路。在本章节旅程的终点，我保证，我们可以比较清楚的回答这个问题。

其实所有的游戏引擎在构建完节点树之后，都会面临这么一个问题，**我的游戏逻辑写在哪里？** 有的原始的如**Cocos2dx懒得想那么多，干脆就直接码在Node里面得了，所以你翻看Cocos2dx的源码你就会经常发现它的逻辑和表现往往是交杂在一起的，简单直接暴力美学，面向对象继承玩得溜**。

而**面向组合阵营的领军Unity则干脆就把Component思想再应用极致一点，我的逻辑为什么不能也是一个组件**？所以Unity里的ScriptComponent也是这种组合思想的体现，模型统一架构优雅，MonoBehavior立大功了！但是在一个Component（ScriptComponent）里去操作管理其他的Components，本身却其实并不是那么优雅，因为有些Component之上的协调管理的事务，从层次上来说，应该放在更高的一个概念上实现。

UE在思考这个问题时，却是感觉有些理想主义，颇有些C++的理念，力求不为你不需要的东西付代价，宁愿有时候折衷，也想保住最优性能。UE的架构中也大量应用了各种继承，有些继承链也能拉得很长，同时一方面也吸纳了组合的优点，我们也能见到UE的源码中类的成员变量也是组合了好多其他对象。所以接下来的该介绍的就是==UE综合应用这两种思想的设计产物==。**面向对象派生下来的Pawn和Character**，**支持组合的Controller**。

## Pawn

那么第二个至关重要的的问题是，**哪些Actor需要附加逻辑？**

在游戏中，我们之所以会觉得一个角色生动，是因为它会响应我们的交互，并给出恰当的反应。而我们所谓的**游戏业务逻辑，实际上编写的就是该如何对玩家的输入提供反馈**。同样，一个Actor想要变得“生动”，就得有响应外部输入的能力，否则就只是自动运转麻木的机器人。但是在一个比较大型的3D游戏中，Actor有千千万万，然后并不是所有的Actor都需要和玩家互动，能直接面圣和玩家互动的Actor也是比较少的。

我们经常都只是操作我们的“角色”，让“角色”和场景里的其他物体互动。比如FPS游戏里我们操作的主角或者是FlappyBird里的那只小鸟。所以从这一点上来看，UE中Actor就立马又可以划分出一个类别了，这些Actor们可谓是玩家们的宠儿，它们是玩家们的亲卫兵，对，它的名字就是==Pawn==!

<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201143143.png" alt="image-20210527201143143" style="zoom:67%;" />

<img src="学习总结.assets\image-20210527201143143.png" alt="image-20210527201143143" style="zoom:67%;" />

同其他AInfo一样，UE也是从Actor中再派生出了APawn，并定义了3块基本的模板方法接口：

1. 可被`Controller`控制
2. `PhysicsCollision`表示
3. `MovementInput`的基本响应接口

==Pawn就是那些可以被玩家（你或AI）控制的Actor==！再考察到UE是做FPS游戏起家的，所以你可以想象这个Pawn就相当于战场里最基本的士兵的表示。一个士兵在战场中首先需要表达自身的存在（`PhysicsCollision`），可以移动（`MovementInput`），然后可以响应输入和处理逻辑（`Controller`）。

你也可以想象成**提线木偶**，那个==木偶就是Pawn==，而==提线的是Controller==。Pawn表达的最关键点是可被玩家操纵的能力。因为UE从FPS进化过来的关系，所以附带的物理表示和移动也一并加了进去，应该也是为了方便的缘故。

❓**思考：为何Actor也能接受Input事件？**

- 我上述的对`Pawn`的描述可能会让你觉得，似乎Pawn既然就是用来被玩家控制的，那么理所当然的我们应该在Pawn上同时实现对输入的接受。但我们会发现实际上`EnableInput`接口却是在`Actor`上的，同时`InputComponent`也是在`Actor`里面的，意味着实际上你也可以在Actor上绑定处理输入事件。官方的输入事件处理流程图也是表明了这一点：

<<<<<<< HEAD
<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201544265.png" alt="image-20210527201544265" style="zoom:67%;" />
=======
<img src="学习总结.assets\image-20210527201544265.png" alt="image-20210527201544265" style="zoom:67%;" />
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

- 首先应该不难理解**输入的处理功能**可以实现化出`InputComponent`，而“输入”的种类也有很多，我们也不能确定和分类哪些Actor的子类该接受哪些种类的输入事件；同时又因为`Actor`也是由**Component组件化**组装而成的，UE不可能为了输入的处理就改变`Component`的组织方式，所以还不如泛泛的在`Actor`的基类里提供`InputComponent`的集成，这样反而保证了灵活性。
- 理解这个问题的要点在于正确区分“输入响应”和“逻辑控制”。比如说WASD移动，Actor拥有最基本的输入响应，它可以响应WASD的按键事件。但是按键了之后呢？该如何移动？**Pawn就定义了一个基本的MovementInput套路**，相当于把WASD的输入响应再往前包装处理了一步。**而“逻辑控制”指的是更高层上的比如寻路或自动巡逻等行为**。
- 作为`GamePlay`中至关重要的一个逻辑概念，让我再罗嗦强调一遍应该不为过吧。==Pawn实现的是“可被控制”的概念==。因为“被控制了”之后经常要被移动（UE对FPS是真爱啊），所以Pawn就索性把移动的接口也定义了一下（当然，为了灵活性，内部转交给`MovementComponent`再处理），既然能移动了，但也不能随便在地图里乱走吧，所以碰撞（物理表示）看来也是需要的啊，好吧，那就加上，齐活了。



## DefaultPawn，SpectatorPawn，Character

<<<<<<< HEAD
![image-20210527201808498](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201808498.png)
=======
![image-20210527201808498](学习总结.assets\image-20210527201808498.png)
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

### DefaultPawn

因为我们每次想自己搞Pawn都得从Pawn派生过来，然后再一个个添加组件。UE知道我们大家都很懒，所以提供了一个默认的Pawn：DefaultPawn，默认带了一个`DefaultPawnMovementComponent`、`spherical CollisionComponent`和`StaticMeshComponent`。也是上述Pawn阐述过的**三件套**，只不过都是默认套餐。

### SpectatorPawn

UE的FPS做的太好了，就会有一些观众想要观战。观战的玩家们虽然也在当前地图里，但是我们并不需要真正的去表示它们，只要给他们一些摄像机“漫游”的能力。所以==派生于DefaultPawn的SpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。==

### Character

因为我们是人，所以在游戏中，代入的角色大部分也都是人。大部分游戏中都会有用到人形的角色，既然如此，UE就为我们直接提供了一个==人形的Pawn==来让我们操纵。

像人一样行走的`CharacterMovementComponent`， 尽量贴合的`CapsuleComponent`，再加上骨骼上蒙皮的网格。**同样的三件套，不一样的配方**。

有些人一开始的时候会困惑应该选择Pawn还是Character，其实从继承体系中就可以了解到**Character只不过是Pawn的加强特化版本**。一般来说，如果你控制的角色是人形的带骨骼的，那就选择Character吧。而如果是VR中的一双手（假设只有一双手），因为移动模式和显示都算不太上人形，顶多只能算是个漂浮的“幽灵”，所以还是用Pawn方便些。后期如果你想加上人形模型和IK了，那么再把Mesh替换成SkeletalMesh也就行了。Pawn因为是基础款，所以提供了最大的灵活性。



# GamePlay架构（五）Controller

如上文所述，UE从`Actor`中分化了一些专门可供玩家“控制”的`Pawn`，那我们这篇就专门来谈谈该怎么个控制法！**所谓的控制，本质指的就是我们游戏的业务逻辑**。比如说玩家按A键，角色自动找一个最近的敌人并攻击，这个自动寻找目标并攻击的逻辑过程，就是我们所谈的控制。

## MVC

典型的，对于游戏：

- “==显示==”指的是游戏的UI，是屏幕上显示的3D画面，或是手柄上的输入和震动，也可以是VR头盔的镜片和定位，是与玩家直接交互的载体；
- “==数据==”指的是Mesh，Material，Actor，Level等各种元素组织起来的**内存数据表示**；
- “==算法==”可以是各种渲染算法，物理模拟，AI寻路，本文咱们就先暂时特指游戏开发者们编写的游戏业务逻辑。

抽象这三个变化，并归纳关系，就是**典型的MVC模式**了：

![image-20210531162441198](学习总结.assets\image-20210531162441198.png)

对于简单的游戏或者引擎来说，有时并不需要把这三者分的很清，如Cocos2dx就没有Controller，它的MVC就是混杂在一起，因为代码量少所以也还算勉强能凑合；Unity的MonoBehavior其实也相当于把MC放在了一起，用得方便的同时也得小心太顺手了出现组件之间互相网状引用一团乱麻的情况；UE在这个问题上的思考就有些一脉相承，既然Actor们形形色色，我们之前也谈过甚至有AInfo这种书记官，那为何不让一些Actor专门来承载逻辑呢？于是，`Actor`再度分化出`Controller`。下面我们就来一一介绍Actor旗下Controller家族的指挥官们。

## AController

虽然我在之前已经一再的剧透过AController是继承自AActor的一个子类，但是为了更好理解思考UE里的Controller机制，请先把脑袋放空，也别去偷看UE里的源码，像张无忌一样暂时忘记AController这回事，问自己一个问题：如果我想实现一种机制去控制游戏里的Actor，该怎么设计？巧妇难为无米之炊，咱们先来看看当前手上都有些什么：

1. **UObject**，反射序列化等机制
2. **UActorComponent**，功能的载体，一定程度的嵌套组装能力（SceneComponent）
3. **AActor**，基础的游戏对象，Component的容器
4. **APawn**，分化出来的AActor，物理表示和基本的移动能力，当前正翘首以待。
5. **没了**，在控制Actor这个层级，我们还暂时不需要去考虑Level等更高层次的对象

针对`APawn`，再想想我们希望达成的控制愿景，没事，你尽管放开想象的想，做不做得到咱们先放一边，但至少别在一开始就被想象力限制住了。“控制”本身虽然只是一段逻辑算法代码，但是它也需要有个载体去承载和运行，某种意义上来说也算得上是个实体。所以下面我们不妨就脑洞大开，以“控制”这个实体的视角口吻，讲讲“**我，作为一个——控制**”希望拥有哪一些本领：

1. **能够和Pawn对应起来**，理想情况下，极端的灵活性应该是多对多。我希望我能同时控制多个Pawn，当然，一个Pawn也可以被多个我的兄弟姐妹们一起控制。想想那些RTS游戏和多人协作游戏，你应该能明白我有时候需要协调调度Pawn们走个方阵，有时候也得多人合作才能操纵得了一台机甲。当然越灵活也往往意味着越容易出错，但总之我们需要一个和Pawn关联的机制。
2. **多个控制实例**，在需要的时候，我不介意可以克隆出多个我来，比如一段逻辑A，我们希望可以有多个实例在同时运行。就像行为树一样，可以有多个运行实例，彼此算法一样，但互不干扰。
3. **可挂载释放**，我可以选择当前控制PawnA，也可以选择之后把它释放掉不再控制让她自生自灭，然后再另寻新欢控制PawnB，我必须拥有灵活的运行时增删控制Pawn的能力。
4. **能够脱离Pawn存在**，我思故我在，就算当前没有任何Pawn控制，我也可以继续存在，这样我就可以延时动态的选择Pawn对象。有些Pawn值得我去等。
5. **操纵Pawn生死的能力**，谁规定必须一定去控制世界当前存在的Pawn才行。当世界里没有Pawn可供我控制时，我希望可以自己造一个出来。你要说她是玩具、亦或傀儡也好，我不在乎。有时候我很羡慕暗黑里的沉沦魔巫师，身边总是围绕着一群沉沦魔，一个沉沦魔挂了，他可以紧接着再复活一个出来，这样永远都不会感动寂寞，你说多好？那索性再霸道一点吧，要是我这个控制实体不在了，我**希望可以选择是否带Pawn们跟我一起走，没了我，她们都傻得让人心疼**。当然如果有哪个Pawn能让我这个霸道总裁爱上，我也愿意陪她一起去死。
6. **根据配置自动生成**，我（控制）虽然只是一段代码，但也不能无中生有，所以也得有个机制可以生成我这个控制实体，不过想来这应该是组织里更上层领导的事，但至少他应该知道怎么创建我出来。
7. **事件响应**，游戏事件的一些控制关心的事件应该能够传到我这里，我可以酌情处理。同样，Pawn也可以向我汇报，我会好好研究决定的，嗯。
8. **持续的运行**，没事的时候，我喜欢听世界大钟的每一次Tick，跟我的心跳同步起来，就仿佛真的活过来一样，可以自主的做一些我想做的事，这是我最自在的时候。
9. **自身有状态**，你累了要休息，我也一样。我可以选择自身的状态，选择工作或者是休息，也可以选择今天是哪个Pawn和心情最配。
10. **拥有一定的扩展继承组合能力**，一方面我希望我的家族开枝散叶繁荣昌盛，我的一身本领继承自我的父亲，而我也将有我的儿，大家各有天赋。另一方面，那些普通的Actor们都可以身背各个Component，更高贵的我当然也想有。
11. **保存数据状态**，听说金鱼的记忆只有7秒，可是我却想记住你一辈子。所以我希望我能拥有一些记忆，人的过去成就了现在，也将指引着未来。以前有一个人跟我说过，当你不能再拥有的时候，唯一能做的就是令自己不要忘记。
12. **可在世界里移动**，我可以选择帐中千里之外遥控Pawn，也可以选择附身在一个Pawn身上，这样我才能多角度无死角的观察我可爱的Pawn们，嘿嘿。
13. **可探查世界的对象**，我要有眼睛，让我干活，基本的我得看得见知道当前世界里已经有哪些对象吧，否则不就抓瞎了嘛。
14. **可同步**，这年头，要是不能适应网络环境，可真的没有竞争力。这个Object，Actor基本都有的能力，我当然也得有。位于服务器或客户端上的我也必须有能力在其他客户端上影分身，让他们都跟随我的步伐一致行动。

在仔细考察了**"控制"的需求**和**手头上的原料**之后，我们试着从UE的角度来权衡一下。首先**Controller不能是一个Component**，一是因为**Component的层级太低，表达的是功能的概念而非逻辑**；二是**Component必须依附于Actor存在，而我们的Controller希望能独立存在**。

其次如果从UObject直接继承下来UController，倒是也可行，UObject也能复制同步，其他的控制Pawn的能力和事件响应等倒也是能改改接口想想办法，但是要想在世界里移动，就得有个位置表示，再加上还希望能容纳Components，这就麻烦了，基本就是把Actor的工作再做一套，有点累人，搞起来也怕两套班子出错闹矛盾。

再来考察下从AActor继承下来AController怎么样，Actor比Object多了一些我们正需要的配置动态生成、输入事件响应、Tick、可继承、可容纳Component、可在世界里出现、可在网络间同步。好了，现在就差控制Pawn的能力，那我们就在这个分化出来的AController增加一些控制Pawn的接口，这个思路正是和我们从Actor从分化出Pawn的时候不谋而合！现在我们来看看UE里的AController：



<img src="学习总结.assets\v2-4151952d1f2ab74fcc78d7c3bd215e0d_720w.png" alt="img" style="zoom:67%;" />

跟我们的设计八九不离十，我们再一一仔细验证一番：关联Pawn的能力，有Possess和UnPossess，源码里也有PawnPendingDestroy等这些函数（未一一列出）；GameMode中也保存着AIControllerClass和PlayerControllerClass的配置，用于在适当的时候Spanw出Controller；继承于Actor也就有了EnableInput和Tick；Controller本身还可以继续派生下去（如AIController和PlayerController），也可以容纳Components；也带着一个SceneComponent所以可以摆放在世界中；自身也可以添加成员变量来记忆存储游戏状态；自身也有一个FName StateName（Playing、Spectating、Inactive），切换自身的状态（运行，观察，非激活）；因为跟Pawn是平级的关系，只在运行的时候引用关联，所以对彼此独立存在不做强制约束，提高了灵活性。一个Pawn自身上也可以配置策略：

```c++
namespace EAutoReceiveInput{
    enum Type
    {
        Disabled,
        Player0,
        Player1,
        Player2,
        Player3,
        Player4,
        Player5,
        Player6,
        Player7,
    };
}
TEnumAsByte<EAutoReceiveInput::Type> AutoPossessPlayer;
enum class EAutoPossessAI : uint8
{
    /** Feature is disabled (do not automatically possess AI). */
    Disabled,
    /** Only possess by an AI Controller if Pawn is placed in the world. */
    PlacedInWorld,
    /** Only possess by an AI Controller if Pawn is spawned after the world has loaded. */
    Spawned,
    /** Pawn is automatically possessed by an AI Controller whenever it is created. */
    PlacedInWorldOrSpawned,
};
EAutoPossessAI AutoPossessAI;
TSubclassOf<AController> AIControllerClass;
```

❓**思考：Controller和Pawn必须1:1吗？**

- 观察UE实现里我们发现Controller里只是保存了一个Pawn指针，而不是数组，这和一开始希望的多对多关系有些出入。理想和现实总是有差距，一个愿景落实到工程实践上也不免得有一些妥协。首先我们再来梳理理解一下这个Possess(拥有/占用)的概念。一个Controller能灵活的Possess/UnPossess一个Pawn，虽然一次只能控制一个，但在游戏中我们也可以在不同的Pawn中切换，比如操纵一个主角坐进然后控制一辆汽车，或者端起固定的机关枪扫射，这些功能琢磨一下其实只是涉及操作实体Pawn的变化。如果我们能妥善的用好Pawn和Controller的切换功能，大部分基本的游戏功能也是能够比较方便的实现的。

❓**思考：为何Controller不能像Actor层级嵌套？**

- 我们都知道Actor可以藉着身上的SceneComponent互相嵌套。那么AController同样也是Actor，为何不也实现这么一个父子机制？从功能上来说，一个Controller可以有子Controllers，听起来也是非常灵活强大啊。但是冷静想一下，Controller表达的“控制”的概念，所以在这里你实际上想要表达的是一种“控制”互相嵌套的概念，感觉又给“控制”给分了层，有“大控制”，也有“小控制”，但是“控制”的“大小”又是个什么概念呢？我们应该怎么划分控制的大小？“控制”本质上来说就是一些代码，不管怎么设计，目的都是用来表达游戏游戏逻辑的。

❓**思考：Controller可以显示吗？**

- 既然Actor本身可以带着Mesh组件来渲染显示，那Controller可不可以呢？是不是Controller都是不可见的？这个答案可说是也可以说不是，因为Controller本身确实就是一个特殊点的Actor而已，你依然可以在Controller中添加Mesh组件，添加别的子Actor等，所以从这个方面说Controller是有可以渲染显示的能力的。但是一个控制者毕竟只是表达一个逻辑的概念，所以为了分工明确，UE就干脆在Controller的构造函数里把自己给隐藏了：

  ```c#
      bHidden = true;
  #if WITH_EDITORONLY_DATA
      bHiddenEd = true;
  #endif // WITH_EDITORONLY_DATA
  ```

❓**思考：Controller的位置有什么意义？**

- 既然Controller本身只是控制者，那它在场景中的位置和移动有什么意义吗？Controller为何还需要个SceneComponent?意义在于如果Controller本身有位置信息，就可以利用该信息更好的控制Pawn的位置和移动。首先说下Controller的Rotation，这个比较好理解一点，如果我想让我的Pawn和Controller保持旋转朝向一致，因为是Controller作主控制Pawn的关系，所以Controller就得维护自己的Rotation。再来说位置，如果Controller有自己的位置，这样在Respawn重新生成Pawn的时候，你就可以选择在当前位置创建。因此为了自动更新Controller的位置，UE还提供了一个bAttachToPawn的开关选项，默认是关闭的，UE不会自动的更新Controller的位置信息；而如果打开，就会把Controller附加到Pawn的子节点里面去，让Controller跟随Pawn来移动。你可以把这两种模式想象成一种是上帝视角在千里之外心电感应控制Pawn，另一种是骑在Pawn肩上来指挥。

  当然如果这个Controller确实只是纯朴的逻辑控制的话（如AIController），那确实位置也没什么意义。所以UE甚至还隐藏了Controller的一些更新位置的接口，尽量避免让人手动去操纵。

- UE这里其实想说的是，这些更新位置的操作还是让我来为你管理吧，我真的担心你会用错搞出什么乱子来。顺便再说些题外话，**对于PlayerController来说，因为玩家需要一个视角来观察世界，所以常常PlayerController常常会扛着个摄像机出现**（蓝图里没有，但是会运行时生成PlayerCameraManager和CameraActor），所以就算没有角色可供操作，玩家也依然希望是可以视角漫游观察整个世界的（试试看把默认Level里的PlayerStart删掉后运行看看）。这个时候PlayerController常常会默认创建出一个ASpectatorPawn或者DefaultPawn（根据GameMode里配置），我们虽然看不见Pawn，但依然可以观察世界，靠得就是跟Controller关联的旋转和摄像机。

❓**思考：哪些逻辑应该写在Controller中？**

- 如同当初我们在思考Actor和Component的逻辑划分一样，我们也得要划分哪些逻辑应该放在Pawn中，哪些应该放在Contrller中。上文我们也说过，Pawn也可以接收用户输入事件，所以其实只要你愿意，你甚至可以脱离Controller做一个特立独行的Pawn。那么在哪些时候需要Controller？哪些逻辑应该由Controller掌管呢？可以从以下一些方面考虑：
  - 从概念上，Pawn本身表示的是一个“能动”的概念，重点在于“能”。而Controller代表的是动到“哪里”的概念，重点在于“方向”。**所以如果是一些Pawn本身固有的能力逻辑，如前进后退、播放动画、碰撞检测之类的就完全可以在Pawn内实现**；而对于一些可替换的逻辑，或者智能决策的，就应该归Controller管辖。
  - 从对应上来说，如果一个逻辑只属于某一类Pawn，那么其实你放进Pawn内也挺好。**而如果一个逻辑可以应用于多个Pawn，那么放进Controller就可以组合应用了**。举个例子，在战争游戏中，假设说有坦克和卡车两种战车（Pawn），只有坦克可以开炮，那么开炮这个功能你就可以直接实现在坦克Pawn上。而这两辆战车都有的自动寻找攻击目标功能，就可以实现在一个Controller里。
  - 从存在性来说，Controller的生命期比Pawn要长一些，比如我们经常会实现的游戏中玩家死亡后复活的功能。Pawn死亡后，这个Pawn就被Destroy了，就算之后再Respawn创建出来一个新的，但是Pawn身上保存的变量状态都已经被重置了。所以**对于那些需要在Pawn之外还要持续存在的逻辑和状态，放进Controller中是更好的选择**。

## APlayerState

我们上文提到过Controller希望也能有一些记忆，保存住一些游戏状态。那么到底应该怎么保存呢？AController自身当然可以添加成员变量来保存，这些变量也可以网络复制，一般来说也够用。但是终究还是遗忘了一个最重要的数据状态。整个游戏世界构建起来就是为了玩家服务的，而玩家在游戏过程中，肯定要存取产生一些状态。而**Controller作为游戏业务逻辑最重要的载体，势必要和玩家的状态打交道。所以Controller如果可以动态存取玩家的状态就会大为方便了**。因此我们会在Controller中见到：

```c#
 /** PlayerState containing replicated information about the player using this controller (only exists for players, not NPCs). */
    UPROPERTY(replicatedUsing=OnRep_PlayerState, BlueprintReadOnly, Category="Controller")
    class APlayerState* PlayerState;
```

而`APlayerState`的继承体系是：

![img](学习总结.assets\v2-ba203b15c1e9356d5aa7fe6bf2fd556c_720w.png)

至于**为啥APlayerState是从AActor派生的AInfo继承下来**的，我们聪明的读者相信也能猜得到了，所以也就不费口舌论证了。无非就是**贪图AActor本身的那些特性：网络复制等**。而AInfo们正是这种不爱表现的纯数据书呆子们的大本营。而这个PlayerState我们可以通过在GameMode中配置的PlayerStateClass来自动生成。

注意，这个**APlayerState也理所当然是生成在Level中的，跟Pawn和Controller是平级的关系，Controller里只不过保存了一个指针引用罢了**。注释里说的PlayerState只为players存在，不为NPC生成，指的是**PlayerState是跟UPlayer对应的，换句话说当前游戏有多少个真正的玩家，才会有多少个PlayerState，而那些AI控制的NPC因为不是真正的玩家，所以也不需要创建生成PlayerState**。

但是UE把PlayerState的引用变量放在了Controller一级，而不是PlayerController之中，说明了**其实AIController也是可以设置读取该变量的**。一个AI智能能够读取玩家的比分等状态，有了更多的信息来作决策，想来也没有什么不对嘛。

:star:Controller和网络的结合很紧密，很多机制和网络也非常强关联，但是在这里并不详细叙述，这里先可以单纯理解成Controller也可以当作玩家在服务器上的代理对象。把PlayerState独立构成一个Actor还有一个好处，当玩家偶尔因网络波动断线，因为这个连接不在了，所以该Controller也失效了被释放了，服务器可以把对应的该PlayerState先暂存起来，等玩家再紧接着重连上了，可以利用该PlayerState重新挂接上Controller，以此提供一个比较顺畅无缝的体验。至于AIController，因为都是运行在Server上的，Client上并没有，所以也就无所谓了。

❓**思考：哪些数据应该放在PlayerState中？**

- 从应用范围上来说，**PlayerState表示的是玩家的游玩数据**，所以那些关卡内的其他游戏数据就不应该放进来（GameState是个好选择），另外**Controller本身运行需要的临时数据也不应该归PlayerState管理**。而玩家在切换关卡的时候，APlayerState也会被释放掉，所有**PlayerState实际上表达的是当前关卡的玩家得分等数据**。这样，**那些跨关卡的统计数据等就也不应该放进PlayerState里了**，应该放在外面的GameInstance，然后用SaveGame保存起来。

## 总结

在游戏里，如果要评劳模，那Controller们无疑是最兢兢业业的，虽然有时候蛮横霸道了一些，但是经常工作在第一线，下面的Pawn们常常智商太低，上面的Level，GameMode们又有点高高在上，让他们直接管理数量繁多的Pawn们又有点太折腾，于是事无巨细的真正干那些脏活累活的还得靠Controller们。本文虽然没有在网络一块留太多笔墨，但是Controller也是同时作为联机环境中最重要的沟通渠道，身兼要职。

回顾总结一下本文要点，UE在Pawn这个层级演化构成了一个最基本和非常完善的`Component-Actor-Pawn-Controller`的结构：

<img src="学习总结.assets\v2-117fa2fe09c46ed2dac388278f028df0_r.jpg" alt="preview" style="zoom:67%;" />

通过分化出来后的Actor的互相控制，既充分利用了现有的机制功能，又提供了足够的灵活性，而且做的更改还很少，不用再设计额外另一套框架。读者朋友们，现在我们如果翻到第一小节，想想UE最初从Object分化出Actor的那一刻，是不是有很多感慨和感动呢？一个最初的很简单的游戏对象表示，慢慢演化派生充实起来，彼此之间通力配合，竟也能优雅的运转起来。

有时候架构的设计和搭建是一脉相承的，最初的时候选择了什么样的模型和骨架，后面再设计别的逻辑框架等其他模块，也基本上都得跟最初的设计配合着来。所以有时候往往也会发现，怎么感觉我架构设计的方案可选择数量并不多啊？其实是因为如果一开始铺垫的好，接下来的设计水到渠成自然而然，让你感觉不到用心设计的力气。UE以Actor的视角来看待世间万物，自然得到的是一个Actor繁荣昌盛的世界；Unity以Component来组装万物，得到的就是个各种插件组件组装出的世界；而如果如Cocos2dx一般万物都是Node,那么自然也会得到一棵挂满各种Node的世界之树。这也算是游戏引擎的基因吧。

本想着一篇介绍完Controller、PlayerController和AIController这三个对象，但是Controller本身是UE里极为重要的核心概念，自身的功能非常的丰富，牵扯的模块也比较多，因此想抽离阐述最核心的概念和功能并不是一件容易的事。花了这么长的篇幅，只讨论揣摩了`Controller`的设计过程和最基本的职责（还有输入网络等都没有解释），顺便先简单介绍了下`PlayerState`出场（PlayerState实际上是跟UPlayer关联更大一些，PlayerController等后续章节会继续讨论它），对于PlayerController和AIController，目前也只是语焉不详的含糊带过。不过还是希望读者们能从中吸取到设计的营养，把握清楚概念了，才能更好的组织游戏逻辑，开发出更好的游戏。



# GamePlay架构（六）PlayerController和AIController

上文我们谈到了Component-Actor-Pawn-Controller的结构，追溯了AController整个家族的崛起和身负的使命。本篇我们继续来探讨Controller家族中最为人所知的`PlayerController`和`AIController`。

作为一个Controller，我们讨论的依然是该如何控制。我们已经知道了==Controller可以Possess并控制Pawn==，但是Controller本身又是怎么驱动起来的呢？**一个游戏里的控制角色大抵都可以分为两类：玩家和AI**。不管是单机游戏或者分屏多玩家，还是网络玩家联机对战，游戏都是为了玩家服务的，所以也必然会有一个或多个玩家，就算是如《山》那种纯看的游戏，也是有一个“可观察不可动”的玩家的。而AI的实体的数量就可以是零或者多个。

## APlayerController

让咱们先从简单的单机游戏开始讨论吧，比如一款单机FPS游戏，这个游戏里已经用各种各样的Actor们构建完成了世界场景，你的主角和敌人Pawn们也都在整装待发，这个时候你思考这么一个问题，我该怎么玩这个游戏？壮丽的舞台已经准备好了，就等你入场了。先抛开具体的引擎而言，**首先你需要能看见**（拥有Camera和位置），其次你**必须能响应输**入（玩家按WASD你应该能接收到），然后你可以**根据输入操控一些Pawn（Possess然后传递Input）**，这样一个单机游戏中的简单玩家控制器就差不多了。**一个游戏中只有一个PlayerController，在不同的关卡中你可以使用不同的PlayerController，但是同一时刻响应的只能是一个PlayerController**。

插上多个手柄，咱们再拓展一下，比如像**《街霸》那种单PC但是多玩家对抗或者协作的游戏**。两个玩家可以分别用两个手柄，或者一个用键盘一个用鼠标，甚至是键盘上的不同区域，形式可以多种多样。这个时候如果依然只有一个PlayerController，实现起来其实也是可行的，把两个手柄——所有的输入都由这个PlayerController来接收，然后在PlayerController内部再分别根据情况去处理不同的Pawn。但是这种方式的缺点显然也在于很容易把玩家1、2的输入和控制混杂在一起，没有清晰的区分开。**因此，为了支持这种情况，我们可以开始允许游戏中同时出现多个PlayerController，每个PlayerController甚至都可以拥有自己的Viewport（分屏或者不同窗口），这样我们通过配置，可以精确的路由手柄1的输入给玩家1，各自的逻辑也很好的区分和复用。**

再插上网线继续，**到了网游时代，我们的游戏就开始允许有多人联机对战了**。玩家在自己的PC上控制的只是自己的本地的角色，而屏幕游戏里其他的玩家角色是由网线另一端的玩家控制的。为了更好的适应这种情况，我们就又得扩展一下PlayerController的概念，PlayerController不仅能控制本地的Pawn，而且还能“控制”远程的Pawn（**实际上是通过Server上的PlayerController控制Server上的Pawn，然后再复制到远程机器上的Pawn实现的**）。

因此我们来看看==UE里的PlayerController==：

<img src="学习总结.assets\v2-88131e55febd8886e0f3c87b92c526e8_r.jpg" alt="preview" style="zoom:67%;" />

PlayerController因为是直接跟玩家打交道的逻辑类，因此是UE里使用最多的类之一。UE4.13.2版本里1632行的.h文件和4686行的.cpp文件，里面实现了很多的功能，初阅读起来往往深陷其中不得要领。但是在上述的分析了之后，我们也可以在其中大概归纳出几个模块：

- ==Camera的管理==，目的都是为了控制玩家的视角，所以有了`PlayerCameraManager`这一个关联很紧密的摄像机管理类，用来方便的切换摄像机。`PlayerController`的ControlRotation、ViewTarget等也都是为了**更新Camera的位置**。因为跟Camera的关系紧密，而Camera最后输出的是屏幕坐标里的图像，所以为了方便一些拾取的**HitResult函数**也都是实现在这里面。渲染章节会再详细介绍UE的摄像机管理。
- ==Input系统==，包括构建`InputStack`用来路由输入事件，也包括了自己对输入事件的处理。所以包含了`UPlayerInput`来委托处理。
- ==**UPlayer关联**==，既然顾名思义是`PlayerController`，那自然要和Player对应起来，这也是==PlayerController最核心的部分==。**一个UPlayer可以是本地的LocalPlayer，也可以是一个网络控制UNetConnection**。`PlayerController`只有在`SetPlayer`之后，才可以开始正常工作。
- ==HUD显示==，用于在当前控制器的摄像机面前一直显示一些UI，这是从UE3迁移过来的组件，现在用`UMG`的比较多，等介绍UI模块的时候再详细介绍。
- ==Level的切换==，PlayerController作为网络里通道，在一起进行Level Travelling的时候，也都是先通过PlayerController来进行RPC调用，然后由PlayerController来转发到自己World中来实际进行。
- ==Voice==，也是为了方便网络中语音聊天的一些控制函数。

简单来说，`PlayerController`作为玩家直接控制的实体，很多的跟玩家直接相关的操作也都得委托它来完成。目前来说`PlayerController`里旗下的100+的函数也大概可以分为以上几大模块，也根据需要重载了Controller里的一些其他函数。

**UE的思想是具象化一个“玩家实体”**，并把所有的跟该玩家相关的操作和接口都交给它完成。一般其他的游戏引擎只是个“功能引擎”，提供了一些图形渲染UI系统等组件，但是在`GamePlay`这个层次就都非常欠缺了，一般都需要开发者自己搭建一套。而回想你写过的游戏，是不是也往往有一个**Player类**（一般是单件或者全局变量）？里面几乎是放着所有跟该玩家相关的业务逻辑代码。**UE里的PlayerController就是这种概念，优点当然是直接方便好理解，缺点也如你所见，会代码膨胀得比较快**。不过目前来说还算能接受，**等某一块功能真的比较大了之后，可以再把它抽出一个单独的类来，如`PlayerInput`和`PlayerCameraManager`一样**。

❓**思考：哪些逻辑应该放在PlayerController中？**

- 回想我们上篇的问题：“哪些逻辑应该写在Controller中？”，该处的答案观点在本处也依然适用。不过我还想再补充几点：
  - 对实现游戏逻辑来说，如果是**按照MVC的视角**，那么View对应的是Pawn的表现，而**PlayerController对应的是Controller的部分**，那Model就是游戏业务逻辑的数据了。拿超级马里奥游戏来举例子，把问题先局限在一个关卡内，假设要实现的是金币的逻辑，那么View指的是游戏右上角的金币数目UI，而玩家用PlayerController来控制马里奥来蹦跳行走，而**马里奥（Pawn）**通过触碰金币的事件又上报给PlayerController来相应增加金币。而**PlayerController存储金币的数据就是在PlayerState中**。即PlayerState中有一个**int coin**，也有相应的AddCoin(int coin)。**而PlayerController的职责应该是一边控制Pawn，一边负责内部正确的调用PlayerState的Coin接口。**那么PlayerController里的成员变量有什么用？根据单一职责原则，我们写在哪个类里的变量应该尽量只符合该类的作用，所以PlayerController里的变量的意义在于更好的实现控制。比如假设玩家在一个关卡内可以按AABB来作弊获得100金币，但是限最多3次。那么这个按键的响应就应该由PlayerController来接收，然后调用AddCoin(100)，并更新PlayerController里的成员变量CoinCheatCount。也或者想实现马里奥的加速跑，也可以在PlayerController里增加`Speed`的成员变量。
  - **记住PlayerController是可被替换的，不同的关卡里也可能是不一样的。比如马里奥在水下的时候控制的方式明显就不一样**，所以就不能像“Player”单件类那样什么都往里面塞。这样一旦被替换掉了之后数据就都丢失了。
  - PlayerController也不一定存在，考虑一下如果把马里奥做成联机游戏，那么对方玩家被同步过来的将只有PlayerState，对方玩家的PlayerController只在服务器上存在。所以这个时候，如果你把金币数据放在PlayerController里的话就非常尴尬了。所以为了扩展性来说，还是根据职责分明的原则来正确划分业务逻辑会比较好。
  - ==在任一刻，Player:PlayerController:PlayerState是`1:1:1`的关系==。**但是PlayerController可以有多个备选用来切换，PlayerState也可以相应多个切换**。`UPlayer`的概念会在之后讲解，但目前**可以简单理解为游戏里一个全局的玩家逻辑实体**，**而PlayerController代表的就是玩家的意志，PlayerState代表的是玩家的状态**。

## AAIController

从某种程度上来说，AI也可以算是一个Player，只不过它不需要接收玩家的控制，可以自行决策行动。从**玩家控制的逻辑**需要有一个载体一样，**AI的逻辑算法也需要有一个运行的实体**。而这就是UE里的`AIController`：

<img src="学习总结.assets\v2-a0c2148ff8331da1b70ab4157e19f1c2_r.jpg" alt="preview" style="zoom: 67%;" />

同PlayerController对比，少了Camera、Input、UPlayer关联，HUD显示，Voice、Level切换接口，但也增加了一些AI需要的组件：

- ==Navigation==，用于智能根据==导航寻路==，其中我们常用的`MoveTo`接口就是做这件事情的。而在移动的过程中，因为少了玩家控制的来转向，所以多了一个`SetFocus`来控制当前的Pawn视角朝向哪个位置。
- ==AI组件==，运行**启动行为树**，使用黑板数据，探索周围环境，以后如果有别的AI算法方法实现成组件，也应该在本组件内组合启动。
- ==Task系统==，让AI去完成一些任务，也是实现`GameplayAbilities`系统的一个接口。目前简单来说GameplayAbilities是为Actor添加额外能力属性集合的一个模块，比如HP，MP等。其中的GamePlayEffect也是用来实现Buffer的工具。另外GamePlayTags也是用来给Actor添加标签标记来表明状态的一种机制。目前来说该两个模块似乎都是由Epic的Game Team在维护，所以完成度不是非常的高，用的时候也往往需要根据自己情况去重构调整。

本文重点不在于讨论AI内部的各种组件功能，因此我们先把目光聚焦在AIController对象本身上。同PlayerController一样，**AIController也只存在于Server上（单机游戏也可看作是Server）**。游戏里必须有玩家参与，而AI可以没有，所以AIController并不一定会存在。我们可以在Pawn上配置AIControllerClass来让该Pawn产生的时候自动为它分配一个`AIController`，之后自动释放。

❓**思考：哪些逻辑应该放在AIController中？**

- 我们依然要思考这个问题，**大部分思想和原则和PlayerController是一样的**，只不过AI算法的多种多样，所以我们**推荐尽量利用UE提供的行为树、黑板等组件实现，而不是直接在AIController硬编码再度实现**。也请把目光仅仅局限在当前的Pawn身上，不要在里面写其他无关的逻辑。另外，**因为AIController都是在关卡内比较短暂存在的，一般不太有跨Level的数据保存，所以你可以用AIController的成员变量来保存状态**。而如果真的需要用到PlayerController的状态，则也可以引用一个PlayerState过来。如果想引用关卡的全局状态，也可以引用GameState，再更高级别的，甚至可以直接和GameInstance接触。
- 但是AIController也可以通过配置`bWantsPlayerState`来获得自己的PlayerState，所以PlayerState其实也并不是跟`UPlayer`绑定的，毕竟从本质上来说APlayerState也只是个AInfo（AActor），跟其他Actor一样可以有多个，并没有什么稀奇的，区别是你自己怎么创建并利用它。

## 总结

到此，我们也算讨论完了**Actor（Pawn）层次的控制**，在这个层次上，我们关注的焦点在于如何更好的控制游戏世界里各种Actor交互和逻辑。UE采用了分化Actor的思维创建出AController来控制APawn们，因为玩家玩游戏也全都是控制着游戏里的一个化身来行动，所以UE抽象总结分化了一个APlayerController来上接Player的输入，下承Pawn的控制。对于那些自治的AI实体，UE给予了同样的尊重，创建出AIController，包含了一些方便的AI组件来实现游戏逻辑。并利用PlayerState来存储状态数据，支持在网络间同步。

![preview](学习总结.assets\v2-3bd34e0947e07fe6b4e54b025977b3ac_r.jpg)

上图应该可以比较清晰的阐明，UE是如何充分利用Actor的本身机制来反过来实现对Actor的逻辑控制，相信亲爱的读者朋友们也能自行体会到它的优雅之处。对比其他的游戏引擎，往往它们都止步于Actor这一个层次，只提供了最基本的对象层次，美名其曰交给玩家控制。UE为我们提供了这一套简洁强大的机制，大大方便了我们编写逻辑的难度。




# GamePlay架构（七）GameMode和GameState

上文我们说到在Actor层次，UE用Controller来充当APawn的逻辑控制者，也有了可以接受玩家输入的PlayerController，和能自行行动的AIController。Actor的逻辑编写介绍完了，那么本篇，我们继续爬升，对于由Actors组成的Level这一层次，UE又是怎么控制的呢？

对Level记不太清楚的朋友，可以翻回去查看“GamePlay架构（二）Level和World”的讲述，简单概括就是**World是由一个PersisitentLevel和一些subLevels组成的，PersisitentLevel切换了，相应的World也会切换**。所以本文的关注点是在这么一个对象层次结构下，UE是怎么设计的，我们又能做些什么。

## GameMode

游戏里的哪些部分可以算是一个关卡？简单的我们都知道有《愤怒的小鸟》或《植物大战僵尸》的关卡，复杂的有大型FPS游戏里的关卡，而对于更大型的《暗黑3》或者大型无缝地图RPG游戏《巫师3》，甚至是号称超级广阔宇宙《无人深空》，我们能直接了当的说出哪部分是关卡吗？游戏行业发展如今，为了更好的组织游戏逻辑和内容资源，也发展出了一些概念来更好的理解和阐述，虽然叫法不同，不过含义理念都是相通的。比如，Cocos2dx会认为游戏就是由不同的Scene切换组成的，每个Scene又由Layer组成；Unity也认为游戏就是一个个Scene；而UE的视角的是，游戏是由一个个World组成的，World又是由Level组成的。这些概念有什么不同？

让我们从游戏本身的机制上分析：

- **游戏或玩家的节奏，游戏可以分成一个个阶段**，马里奥里的关卡就是一个阶段，而RPG游戏的一个大地图也是一个阶段。一个游戏也可能只有一个阶段，比如一直在宇宙里漫游的游戏。**通常一个阶段结束后，会有一个结算**。阶段之间，玩家也能明显感觉到切换感。
- **游戏的机制**，有时候即使是同样的场景，玩家却也能感觉就像在玩两个不同的游戏，比如MOBA里的同一张地图上的各种不同挑战模式。
- **游戏的资源划分**，有时候也能遇见同一个玩法应用在不同的场景上，比如赛车游戏的不同跑道。有时候也会在游戏的大地图里从酷热的沙漠到寒冷的极地。游戏开发中也总是倾向于给游戏用到的资源划分成组的进行载入和释放。

通过以上的分析，也和以前的一贯思路一样，我们发现在思考“关卡”这件事情上，也是**要保持头脑清晰的分清“表示”和“逻辑”**。==玩法就是“逻辑”，场景就是“表示”。所以我们如果以逻辑来划分游戏，得到的就是一个个World的概念；如果以表示来划分，得到就是一个个Level。==一场游戏中，玩法再复杂但也只有一个，场景却可以无限大，所以可以有很多个表示拼接组装，因此是World包含Level，而不是反过来。现在回过头来回想一下Cocos2dx和Unity的世界观，它们的概念还只是在表示层，在游戏实例和关卡之间少了一个更高级的逻辑概念。

因此UE的世界观是，**World更多是逻辑的概念，而Level是资源场景表示**。以《巫师3》为例，有好几个国家之间通过传送切换，国家内大地图无缝漫游，显然我们知道不可能把一个国家的所有资源都加载进内存，因此在UE里，一个国家就是许多个Level拼接的，而一个国家就是一个World，它们可以有不同的模式玩法。但毕竟AAA游戏很少，**通常的，我们的游戏比较简单的用一个Level就够了，否则这个场景表示的概念就应该叫Area更合适了，也因此通常的这里的Level也常常对应游戏里玩家面对的"关卡"，也因此UE里Level的Settings叫做WorldSettings了**。

厘清了这些概念了之后，我们就知道，**当我们在谈Level的业务逻辑控制的时候，我们实际上谈的是World的业务逻辑**。按照UE的设计理念和经过Controller的经历，我想我也不用多解释了从Actor再派生出一个WorldController的方式了，可以直接的享受Actor已经提供的一切福利。一个World的Controller想不出有什么需要展示渲染的，因此可以直接从AInfo派生吧。哦，WorldController是我瞎编的，在UE3里它叫做GameInfo，到了UE4它改名为了GameMode。笼统的讲，==一个World就是一个Game，把玩法叫做Mode==，我们应该也能接受吧。那我们来看看它：

![image-20210603190108503](学习总结.assets\image-20210603190108503.png)

`GameMode`身为一场游戏的**唯一逻辑操纵者**身兼重任，在功能实现上有许多的接口，但主要可以分为以下几大块：

- **Class登记**，GameMode里登记了游戏里基本需要的类型信息，在需要的时候通过`UClass`的反射可以自动Spawn出相应的对象来添加进关卡中。前文说过的Controller的类型登记也是在此，GameMode就是比`Controller`更高一级的领导。

  ![image-20210603190220368](学习总结.assets\image-20210603190220368.png)

- **游戏内实体的Spawn**。不光登记，GameMode既然作为一场游戏的主要负责人，那么**游戏的加载释放过程**中涉及到的实体的产生，包括玩家Pawn、PlayerController，AIController都是由GameMode负责。最主要的`SpawnDefaultPawnFor`、`SpawnPlayerController`、`ShouldSpawnAtStartSpot`这一系列函数都是在接管**玩家实体的生成和释放**，玩家进入该游戏的过程叫做Login（和服务器统一），也控制进来后在什么位置，等等这些实体管理的工作。GameMode也控制着本场游戏支持的玩家、旁观者和AI实体的数目。

- **游戏的进度**，一个游戏支不支持暂停，怎么重启等这些涉及到游戏内状态的操作也都是`GameMode`的工作之一，`SetPause`、`ResartPlayer`等函数可以控制相应逻辑。

- **Level的切换**，或者说**World的切换**更加合适，GameMode也决定了刚进入一场游戏的时候是否应该开始播放开场动画（cinematic），也决定了当要切换到下一个关卡时是否要`bUseSeamlessTravel`，一旦开启后，你可以重载GameMode和PlayerController的`GetSeamlessTravelActorList`方法和`GetSeamlessTravelActorList`来指定哪些Actors不被释放而进入下一个World的Level。

- **多人游戏的步调同步**，在多人游戏的时候，我们常常需要等所有加入的玩家连上之后，载入地图完毕后才能一起开始逻辑。因此UE提供了一个MatchState来指定一场游戏运行的状态，意义看名称也是不言自明的，就是用了一个状态机来标记开始和结束的状态，并触发各种回调。

```c#
/** Possible state of the current match, where a match is all the gameplay that happens on a single map */
    namespace MatchState
    {
    	extern ENGINE_API const FName EnteringMap;			// We are entering this map, actors are not yet ticking
    	extern ENGINE_API const FName WaitingToStart;		// Actors are ticking, but the match has not yet started
    	extern ENGINE_API const FName InProgress;			// Normal gameplay is occurring. Specific games will have their own state machine inside this state
    	extern ENGINE_API const FName WaitingPostMatch;		// Match has ended so we aren't accepting new players, but actors are still ticking
    	extern ENGINE_API const FName LeavingMap;			// We are transitioning out of the map to another location
    	extern ENGINE_API const FName Aborted;				// Match has failed due to network issues or other problems, cannot continue
    }
```

❓**思考：多个Level配置不同的GameMode时采用的是哪一个GameMode？**

- 我们知道除了配置全局的GameModeClass之外，我们还能为每个Level单独的配置不同的GameModeClass。但是当一个World由多个Level组成的时候，这样就相当于配置了多个GameModeClass，那么应用的是哪一个？首先第一个原则需要记住的就是，一个World里只会有一个GameMode实例，否则肯定乱套了。因此当有多个Level的时候，一定是PersisitentLevel和多个StreamingLevel，这时就算它们配置了不同的GameModeClass，**UE也只会为第一次创建World时加载PersisitentLevel的时候创建GameMode，在后续的LoadStreamingLevel时候，并不会再动态创建出别的GameMode，所以GameMode从始至终只有一个，PersisitentLevel的那个**。

❓**Level迁移时GameMode是否保持一致？**

- 结论是，UE的流程travelling，GameMode在新的World里是会新生成一个的，即使Class类型一致，即使bUseSeamlessTravel，因此在travelling的时候要小心GameMode里保存的状态丢失。不过Pawn和Controller默认是一致的。

❓**思考：哪些逻辑应该写在GameMode里？哪些应该写在Level Blueprint里？**

我们依旧要问这个老土的问题。根据我们前面的知识，我们知道**每个Level其实也是有自己的LevelScriptActor**的，那么这两个有什么区别？可以从这几个方面来回答：

- 概念上，==Level是表示，World是逻辑==，一个World如果有很多个Level拼在一起，那么也就是有了很多个LevelScriptActor，无法想象在那么多个地方写一个完整的游戏逻辑。所以**GameMode应该专注于逻辑的实现，而LevelScriptActor应该专注于本Level的表示逻辑，比如改变Level内某些Actor的运动轨迹，或者某一个区域的重力，或者触发一段特效或动画。**而GameMode应该专注于玩法，比如胜利条件，怪物刷新等。
- 组合上，同Controller应用到Pawn一样道理，因为GameMode是可以应用在不同的Level的，所以**通用的玩法应该放在GameMode里**。
- **GameMode只在Server存在（单机游戏也是Server）**，对于已经连接上Server的Client来说，因为游戏的状态都是由Sever决定的，**Client只是负责展示，所以Client上是没有GameMode的**，**但是有LevelScriptActor**，所以**GameMode里不要写Client特定相关的逻辑，比如操作UI等**。但是LevelScriptActor还是有的，而且支持RPC，即使如此，LevelScriptActor还是应该只专注于表现，比如网络中触发一个特效火焰。至于UI，可以通过PlayerController的RPC，然后转发到GameInstance来操作。
- 跟下层的PlayerController比较，GameMode关心的是构建一个游戏本身的玩法，PlayerController关心的玩家的行为。这两个行为是独立正交可以自由组合的。**所以想想哪些逻辑属于游戏，哪些属于玩家，就应该清楚写在哪里了**。
- 跟上层的GameInstance比较，**GameInstance关注的是更高层的不同World之间的逻辑，虽然有时候他也把手伸下来做些UI的管理工作，不过严谨来说，在UE里UI是独立于World的一个结构，所以也还算能理解。因此可以把不同GameMode之间协调的工作交给GameInstance，而GameMode只专注自己的玩法世界。**



## GameState

上回说到了**APlayerState用来保存玩家的游戏数据**，那么同样的，对于**一场游戏，也需要一个State来保存当前游戏的状态数据**，比如任务数据等。跟APlayerState一样，GameState也选择从AInfo里继承，这样在网络环境里也可以Replicated到多个Client上面去。

<img src="学习总结.assets\image-20210603191346581.png" alt="image-20210603191346581" style="zoom:80%;" />

比较简单，第一个`MatchState`和相关的回调就是为了**在网络中传播同步游戏的状态**使用的（记得GameMode在Client并不存在，但是GameState是存在的，所以可以通过它来复制），第二部分是**玩家状态列表**，同样的如果在Client1想看到Client2的游戏状态数据，则Client2的PlayerState就必须广播过来，因此GameState把当前Server的PlayerState都收集了过来，方便访问使用。

关于使用，开发者可以自定义GameState子类来存储本GameMode的运行过程中产生的数据（那些想要replicated的!），如果是GameMode游戏运行的一些数据，又不想要所有的客户端都可以看到，则也可以写在GameMode的成员变量中。重复遍，**PlayerState是玩家自己的游戏数据，GamerState里是程序运行的全局数据。**

### GameSession

是在网络联机游戏中针对`Session`使用的一个方便的管理类，并不存储数据，本文重点也不在网络，故不做过多解释，可暂时忽略，留待网络章节再讨论。在单机游戏中，也存在该类对象用来LoginPlayer，不过因为只是作为辅助类，那也可看作GameMode本身的功能，所以不做过多讨论。



## 总结

现在，我们也算讨论完了Level（World）层次的控制，对于一场游戏而言，我们最关心的是怎么协调好整个**场景的表现（LevelBlueprint）**和**游戏玩法的编写（GameMode）**。UE再次用Actor分化派生的思想，用同样套路的`AGameMode`和`AGameState`支持了玩法和表现的解耦分离和自由组合，并很好的支持了网络间状态的同步。同时也提供了一个逻辑的实体来负责创建关系内那些关键的Pawn和Controller们，在关卡切换（World）的时候，也有了一个负责对象来处理一些本游戏的特定情况处理。

![image-20210603191732501](学习总结.assets\image-20210603191732501.png)



## 修订

根据搜索到的最早记录"[[Request/Improvment\] GameMode cleanup.](https://link.zhihu.com/?target=https%3A//forums.unrealengine.com/showthread.php%3F39840-Request-Improvment-GameMode-cleanup)"(09-14-2014)，是有人抱怨当前的GameMode实现了太多的默认逻辑（例如多人的Match），虽然方便了一些人使用，但是也确实加大了理解的难度，并且有时候还得去屏蔽删除一些默认逻辑。然后顺便吐槽了一番AActor里的Damage，笔者也表示这确实不是AActor应该管的事情。

言归正传，UE在2016-08-24的时候开始加进roadmap，并终于在4.14里实现完成了。如前所述，就是把GameMode和GameState的一些共同最基础部分抽到基类AGameModeBase和AGameStateBase里，并**把现在的GameMode和GameState依然当作多人联机的默认实现**。所以以后大家**如果想实现一个比较简单的单机GameMode就可以直接从AGameModeBase里继承了**。



# GamePlay架构（八）Player

回顾上文，我们谈完了World和Level级别的逻辑操纵控制，如同分离组合的AController一样，UE在World的层次上也采用了一个分离的AGameMode来抽离了游戏关卡逻辑，从而支持了逻辑的组合。本篇我们继续上升一个层次，考虑在World之上，游戏还需要哪些逻辑控制？

暂时不考虑别的功能系统（如社交系统，统计等各种），单从游戏性来讨论，现在闭上眼睛，想象我们已经藉着UE的伟力搭建了好了一个个LevelWorld，嗯，就像《西部世界》一样，场景已经搭建好了，世界规则故事也编写完善，现在需要干些什么？当然是开始派玩家进去玩啦！大家都是老玩家了，想想我们之前玩的游戏类型：

- 玩家数目是单人还是多人
- 网络环境是只本地还是联网
- 窗口显示模式是单屏还是分屏
- 输入模式是共用设备还是分开控制（比如各有手柄）
- 也许还有别的不同



按照软件工程的理念，没有什么问题是不能通过加一个**间接层**解决的，不行就加两层！所以既然我们在处理玩家模式的问题，理所当然的是加个间接层，将玩家这个概念抽象出来。

那么什么是玩家呢？狭义的讲，玩家就是真实的你，和你身旁的小伙伴。广义来说，按照图灵测试理论，如果你无法分辨另一方是AI还是人，那他其实就跟玩家毫无区别，所以并不妨碍我们将网络另一端的一条狗当作玩家。那么**在游戏引擎看来，玩家就是输入的发起者**。游戏说白了，也只是接受输入产生输出的一个程序。所以有多少输入，这些输入归多少组，就有多少个玩家。**这里的输入不止包括本地键盘手柄等输入设备的按键，也包括网线里传过来的信号，是广义的、该游戏能接受到的外界输入**。注意**输出并不是玩家的必要属性，一个玩家并不一定需要游戏的输出**，想象你闭上眼睛玩马里奥或者有个网络连接不断发送来控制信号但是从来不接收反馈，虽然看起来意义不大，但也确实不能说这就不是游戏。

在UE的眼里，玩家也是如此广义的一个概念。本地的玩家是玩家，网络联机时虽然看不见对方，但是对方的网络连接也可以看作是个玩家。当然的，本地玩家和网络玩家毕竟还是差别很大，所以UE里也对二者进行了区分，才好更好的管理和应用到不同场景中去，比如网络玩家就跟本地设备的输入没多大关系了嘛。



## UPlayer

让我们假装自己是UE，开始编写**Player类**吧。为了利用上`UObject`的那些现有特性，所以肯定是得从`UObject`继承了。那能否是`AActor`呢？==Actor是必须在World中才能存在的，而Player却是比World更高一级的对象==。**玩游戏的过程中，LevelWorld在不停的切换，但是玩家的模式却是脱离不变的**。另外，**Player也不需要被摆放在Level中，也不需要各种Component组装，所以从AActor继承并不合适**。那还是保持简单吧：

<img src="学习总结.assets\image-20210603192622664.png" alt="image-20210603192622664" style="zoom:67%;" />

如图可见，**Player和一个PlayerController关联起来**，因此UE引擎就可以把输入和PlayerController关联起来，这也符合了前文说过的`PlayerController`接受玩家输入的描述。因为**不管是本地玩家还是远程玩家，都是需要控制一个玩家Pawn的**，所以自然也就需要为每个玩家分配一个PlayerController，所以把PlayerController放在UPlayer基类里是合理的。

## ULocalPlayer

然后是本地玩家，从Player中派生下来**LocalPlayer类**。对本地环境中，一个本地玩家关联着输入，也一般需要关联着输出（无输出的玩家毕竟还是非常少见）。**玩家对象的上层就是引擎了，所以会在GameInstance里保存有LocalPlayer列表。**

![image-20210603192813357](学习总结.assets\image-20210603192813357.png)

UE4里的`ULocalPlayer`也如图所见，`ULocalPlayer`比`UPlayer`多了`Viewport`相关的配置（Viewport相关的内容在渲染章节讲述），也终于用`SpawnPlayerActor`实现了创建出`PlayerController`的功能

GameInstance里有LocalPlayers的信息之后，就可以方便的遍历访问，来实现跟本地玩家相关操作。
关于游戏的详细加载流程目前不多讲述（按惯例在相应引擎流程章节讲述），现在简单了解一下LocalPlayer是怎么在游戏的引擎的各个环节发挥作用的。UE在初始化`GameInstance`的时候，会先默认创建出一个`GameViewportClient`，然后在内部再转发到`GameInstanc`e的`CreateLocalPlayer`：

```c#
ULocalPlayer* UGameInstance::CreateLocalPlayer(int32 ControllerId, FString& OutError, bool bSpawnActor)
{
	ULocalPlayer* NewPlayer = NULL;
	int32 InsertIndex = INDEX_NONE;
	const int32 MaxSplitscreenPlayers = (GetGameViewportClient() != NULL) ? GetGameViewportClient()->MaxSplitscreenPlayers : 1;
    //已略去错误验证代码，MaxSplitscreenPlayers默认为4
	NewPlayer = NewObject<ULocalPlayer>(GetEngine(), GetEngine()->LocalPlayerClass);
	InsertIndex = AddLocalPlayer(NewPlayer, ControllerId);
	if (bSpawnActor && InsertIndex != INDEX_NONE && GetWorld() != NULL)
	{
		if (GetWorld()->GetNetMode() != NM_Client)
		{
			// server; spawn a new PlayerController immediately
			if (!NewPlayer->SpawnPlayActor("", OutError, GetWorld()))
			{
				RemoveLocalPlayer(NewPlayer);
				NewPlayer = NULL;
			}
		}
		else
		{
			// client; ask the server to let the new player join
			NewPlayer->SendSplitJoin();
		}
	}
	return NewPlayer;
}
```

可以看到，如果是在Server模式，会直接创建出ULocalPlayer，然后创建出相应的PlayerController。而如果是Client（比如Play的时候选择NumberPlayer=2，则有一个为Client），则会先发送JoinSplit消息到服务器，在载入服务器上的Map之后，再为LocalPlayer创建出PlayerController。

而在每个PlayerController创建的过程中，在其内部会调用InitPlayerState：

```c++
void AController::InitPlayerState()
{
	if ( GetNetMode() != NM_Client )
	{
		UWorld* const World = GetWorld();
		const AGameModeBase* GameMode = World ? World->GetAuthGameMode() : NULL;
		//已省略其他验证和无关部分
		if (GameMode != NULL)
		{
			FActorSpawnParameters SpawnInfo;
			SpawnInfo.Owner = this;
			SpawnInfo.Instigator = Instigator;
			SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
			SpawnInfo.ObjectFlags |= RF_Transient;	// We never want player states to save into a map
			PlayerState = World->SpawnActor<APlayerState>(GameMode->PlayerStateClass, SpawnInfo );
	
			// force a default player name if necessary
			if (PlayerState && PlayerState->PlayerName.IsEmpty())
			{
				// don't call SetPlayerName() as that will broadcast entry messages but the GameMode hasn't had a chance
				// to potentially apply a player/bot name yet
				PlayerState->PlayerName = GameMode->DefaultPlayerName.ToString();
			}
		}
	}
}
```

这样`LocalPlayer`最终就和PlayerState对应了起来。而网络联机时其他玩家的PlayerState是通过Replicated过来的。我们谈了那么久的玩家就是输入，体现在在每个PlayerController接受Player的时候：

```c++
void APlayerController::SetPlayer( UPlayer* InPlayer )
{
    //[...]
	// Set the viewport.
	Player = InPlayer;
	InPlayer->PlayerController = this;
	// initializations only for local players
	ULocalPlayer *LP = Cast<ULocalPlayer>(InPlayer);
	if (LP != NULL)
	{
		// Clients need this marked as local (server already knew at construction time)
		SetAsLocalPlayerController();
		LP->InitOnlineSession();
		InitInputSystem();
	}
	else
	{
		NetConnection = Cast<UNetConnection>(InPlayer);
		if (NetConnection)
		{
			NetConnection->OwningActor = this;
		}
	}
	UpdateStateInputComponents();
	// notify script that we've been assigned a valid player
	ReceivedPlayer();
}
```

可见，对于ULocalPlayer，APlayerController内部会开始`InitInputSystem()`，接着会创建相应的`UPlayerInput`，BuildInputStack等初始化出和Input相关的组件对象。现在先明白到**LocalPlayer才是PlayerController产生的源头**，也因此才有了Input就够了，特定的Input事件流程分析在后续章节再细述。

❓**思考：为何不在LocalPlayer里编写逻辑？**

- 作为游戏开发者，相信大家都有这么个体会，往往在游戏逻辑代码中总会有一个自己的Player类，里面放着这个玩家的相关数据和逻辑业务。可是在UE里为何就不见了这么个结构？也没见UE在文档里有描述推荐你怎么创建自己的Player。

  这个可能有两个原因，一是UE从FPS-Specify游戏起家，不像现在的各种手游有非常重的玩家系统，在UE的眼中，Level和World才是最应该关注的对象，因此UE的视角就在于怎么在Level中处理好Player的逻辑，而非在World之外的额外操作。二是因为在一个World中，上文提到其实已经有了Pawn-PlayerController和PlayerState的组合了，表示、逻辑和数据都齐备了，也就没必要再在Level掺和进Player什么事了。当然你也可以理解为PlayerController就是Player在Level中的话事人。

  凡事留一线，日后好相见。尽管如此，UE还是给了我们自定义ULocalPlayer子类的机会：

  ```c++
  //class UEngine：
  /** The class to use for local players. */
  UPROPERTY()
  TSubclassOf<class ULocalPlayer>  LocalPlayerClass;
  
  /** @todo document */
  UPROPERTY(globalconfig, noclear, EditAnywhere, Category=DefaultClasses, meta=(MetaClass="LocalPlayer", DisplayName="Local Player Class"))
  FStringClassReference LocalPlayerClassName;
  ```

  你可以在配置中写上LocalPlayer的子类名称，让UE为你生成你的子类。然后再在里面写上一些特定玩家的数据和逻辑也未尝不可，不过这部分额外扩展的功能就得用C++来实现了。



## UNetConnection

非常耐人寻味的是，==在UE里，一个网络连接也是个Player==：

![preview](https://pic4.zhimg.com/v2-4bc20d50aa7c95755bf4d4c4b2b60ed7_r.jpg)

**包含Socket的IpConnection也是玩家，甚至对于一些平台的特定实现如OculusNet的连接也可以当作玩家**，因为对于玩家，只要能提供输入信号，就可以当作一个玩家。

追根溯源，UNetConnection的列表保存在UNetDriver，再到FWorldContext，最后也依然是UGameInstance，所以和LocalPlayer的列表一样，是在World上层的对象。本篇先前瞻一下结构，对于网络部分不再细述。

## 总结

本篇我们抽象出了Player的概念，并依据使用场景派生出了`LocalPlayer`和`NetConnection`这两个子类，从此Player就不再是一个虚无缥缈的概念，而是UE里的逻辑实体。UE可以根据生成的Player对象的数量和类型的不同，在此上实现出不同的玩家控制模式，LocalPlayer作为源头Spawn出PlayerController，继而PlayerState就是实证之一。而在网络联机时，把一个网络连接看作是一个玩家这个概念，把在World之上的输入实体用Player统一了起来，从而可以实现出灵活的本地远程不同玩家模式策略。

尽管如此，UPlayer却像是深藏在UE里的幕后功臣，UE也并不推荐直接在Player里编程，而是利用Player作为源头，来产生构建一系列相关的机制。但对于我们游戏开发者而言，知道并了解UE里的Player的概念，是把现实生活同游戏世界串联起来的很重要的纽带。我们在一个个World里向上仰望，还能清楚的看见一个个LocalPlayer或NetConnection仿佛在注视着这片大地，是他们为World注入了生机。已经到头了？并没有，我们继续向上逆风飞翔，终将得见游戏里的神：GameInstance。



# GamePlay架构（九）GameInstance

上篇我们讲到了UE在World之上，继续抽象出了Player的概念，包含了本地的`ULocalPlayer`和网络的`UNetConnection`，并以此创建出了`World`中的`PlayerController`，从而实现了不同的玩家模式策略。一路向上，依照设计里一个最朴素的原理：自己是无法创建管理自身的，所以`Player`也需要一个创建管理和存储的地方。另一方面，上文提到Player固然可以负责一些跟玩家相关的业务逻辑，但是对于**World之上协调管理的逻辑**却也仍然无处安放。

如果是有一定的游戏开发实战经验的朋友也一定能体会到，在自己开发的游戏中，往往除了我们上文提到的Player类，常常会创建一个Game类，比如BattleGame、WarGame或HappyGame等等。Game之前的名词往往都是游戏的开发代号。这倒不是因为我们如此热衷创建各种Manager类，而是确实需要一个大管家来干一些协调的活。一般的游戏引擎都只会暴露给你它自己引擎的管理类，如Director，Engine或Application之类的，但是却不会主动在**Game类的创建管理**上为你提供方便。游戏引擎的出现，最开始其实只是因为一些人发现游戏做着做着，有一大部分功能是可以复用的，于是就把它抽离了出来方便做下一款游戏。在那个时候，人们对游戏还是处于开荒探索的阶段，游戏引擎只是一大堆功能的复合体，就像叮当猫的口袋一样，互相比谁掏出的工具最强大。然而即使到了现代，绝大部分的引擎的思想却还停留在上个世纪，仍然执着于罗列**Feature列表**，却忘了真正的游戏开发人员天天面对的游戏业务逻辑编写，没有思考在那方面如何也下一番功夫去帮助开发者。人们对比UE和其他游戏引擎时，也会常常说出的一句话是：“别忘了Epic自己也是做游戏的”（虚幻竞技场，战争机器，无尽之剑……）。从这一点也可以看出，UE很大的得益于Epic实战游戏开发的反哺，这一方面Unity就有点吃亏了，没有自己亲自下手干脏活累活，就不懂得急人民群众之所急。所以如果一个游戏引擎能把GamePlay也做好了，那就不止是口袋了，而是知你懂你的叮当猫本身。

## GameInstance

简单的事情就不用多讲了，UE提供的方案是一以贯之的，为我们提供了一个`GameInstance`类。为了受益于`UObject`的反射创建能力，直接继承于UObject，**这样就可以依据一个Class直接动态创建出来具体的GameInstance子类**。

![image-20210607181017651](学习总结.assets\image-20210607181017651.png)

我并不想罗列所有的接口，UGameInstance里的接口大概有4类：

1.  引擎的初始化加载，`Init`和`ShutDown`等（在引擎流程章节会详细叙述）

2. `Player`的创建，如CreateLocalPlayer，GetLocalPlayers之类的。

3. `GameMode`的重载修改，这是从4.14新增加进来改进，本来你只能为特定的某个Map配置好GameModeClass，但是现在GameInstance允许你重载它的`PreloadContentForURL`、`CreateGameModeForURL`和`OverrideGameModeClass`方法来hook改变这一流程。

4. `OnlineSession`的管理，这部分逻辑跟**网络的机制**有关（到时候再详细介绍），目前**可以简单理解为有一个网络会话的管理辅助控制类**。

而`GameInstance`是在`GameEngine`里创建的（先不谈UEditorEngine）：

```c
void UGameEngine::Init(IEngineLoop* InEngineLoop)
{
    //[...]
	// Create game instance.  For GameEngine, this should be the only GameInstance that ever gets created.
	{
		FStringClassReference GameInstanceClassName = GetDefault<UGameMapsSettings>()->GameInstanceClass;
		UClass* GameInstanceClass = (GameInstanceClassName.IsValid() ? LoadObject<UClass>(NULL, *GameInstanceClassName.ToString()) : UGameInstance::StaticClass());
		if (GameInstanceClass == nullptr)
		{
			UE_LOG(LogEngine, Error, TEXT("Unable to load GameInstance Class '%s'. Falling back to generic UGameInstance."), *GameInstanceClassName.ToString());
			GameInstanceClass = UGameInstance::StaticClass();
		}
		GameInstance = NewObject<UGameInstance>(this, GameInstanceClass);
		GameInstance->InitializeStandalone();
	}
	//[...]
 }
//在BaseEngine.ini或DefaultEngine.init里你可以配置GameInstanceClass
[/Script/EngineSettings.GameMapsSettings]
GameInstanceClass=/Script/Engine.GameInstance
```

先从配置中取出`GameInstanceClass`，然后动态创建，一目了然。

❓**思考：GameInstance只有一个吗？**

- 一般而言，是的。对于我们自己开发的游戏而言，我们始终只需要关注自己的一亩三分地，那么你可以认为你子类化的那个`GameInstance`就像个单件一样，全局唯一只有一个，从游戏的开始到结束。但既然是本系列文章的读者，自然也是不甘于只了解这么多的。

- 正如把网络连接也当作Player这个概念一样，我们此时也需要重新审视一下Game这个概念。什么是一个Game？对于玩家而言，Game就是从打开到关闭的这整个过程说展现的内容。但是对于开发者来说，这个概念就需要扩充一下了。假设有个引擎支持双击图标一下子开出4个窗口来让4个玩家独立运行，你能说得清这是一个Game还是4个Game在运行吗？哪一种说法都能自圆其说，但关键是哪一种概念划分能更好的让我们管理组织结构。因此针对这种情况，如果是这4个窗口一点都不互相关联，或者只是单独的共用地图资源，那么用4个Game的概念来管理就更为合适。如果这4个窗口里运行的内容，实际上只是在同一个关卡里本地对战，内存里互相直接通信，那用一个Game加上4个Player的概念就会变得更合适。所以针对这点，你可以把Game理解为就像进程一样，进程可以在同一个exe上多开，Game也可以在同一份游戏资源上开出多个运行实例；进程之间可以互相通信协作，Game的不同实例也可以互相沟通，不管是内存中直接在Engine的协调下完成，还是通过Socket通信。

- 另一方面，一般游戏引擎都只是服务于游戏本身，而对于其配套的各种编辑器就像是对待外来的打工者一样，编辑器往往只负责最终输出游戏资源。由于应用场景的不同，编辑器的架构也常常根据相应平台而定，五花八门，有用Qt，MFC，WPF等各种平台UI框架。而对于另一些有大志向的引擎，比如Unity和UE，其编辑器就是采用引擎自绘的方案（其优劣暂不分析，以后聊到UI框架再细说）。所以游戏引擎这个时候，就更加的拔高了一个层次，就不再只是个“游戏”引擎了，而是个“程序”引擎了。因此UE本身的这套框架不光要服务游戏，还要服务编辑器，甚至是另外一些辅助程序。所以，Game的概念也就扩充到了更上层的“程序”，变得更广义了。

- 言归正传，因为UE的这套Editor自绘机制，还有==PIE==（`PlayInEditor`），进程里其实是可以同时有多个`GameInstance`的，如正在编辑的EditorWorld所属于的，和Play之后的World属于的。我想，这也就是为何UE把它叫做`GameInstance`，而不是简单的Game的含义，其名字中就隐含了多个Instance的深意。我们现在再次回顾一下([GamePlay架构（三）WorldContext，GameInstance，Engine](https://zhuanlan.zhihu.com/p/23167068))最后的结构图，了解一下GameInstance又是被谁管理的：

  ![preview](学习总结.assets\v2-94d1f4e3750b6f4fd09d02b20bc980b0_r.jpg)

- 当初我们是以数据的视角，在考察WorldContext的从属的时候讨论过这个结构。现在以逻辑的角度，明白了GameInstance也会被上层的Engine实例出来多个，就会有更深的理解了。

  再扩充一下，在Engine之下允许同时运行多个GameInstance，还会有许多其他好处，就像操作系统允许一份资源运行多个进程实例一样，Engine就可以站在更高的层次上管理协调多个Game，同时也能更加的深入到Game内部去得到更多的优化。比如未来要实现游戏本地的host多开并管理，或者在Server同时Host一个Map的多个实例(现在只能一个……还是有很多工作要做啊)，这对于开发MMO网游是非常需要的功能，虽然目前UE在这一块的具体工作还有些薄弱，但至少可扩展的可能性是已经保证了的（动手能力强的高手可以在此基础上定制）。一般而言，间接多一层，就多了一层的灵活性，所以很多引擎其实就是把Game和Engine揉在了一块，没有为了GamePlay框架而分开。

❓**思考：哪些逻辑应该放在GameInstance？**

- 第二个惯例的问题是，这一层应该写些什么逻辑。顾名思义，既然是作为游戏中全局唯一的长者，我们就应该给他全局的控制权。在逻辑层面，GameInstance往下看是：

  1. Worlds，Level的切换实际发生地是`Engine`，而==GameInstance可以说是UE之神其下的唯一代言人==，所以GameInstance也可以代之管理World的切换等。我们可以在GameInstance里实现各种逻辑最后调用`Engine`的`OpenLevel`等接口。
  2. `Players`，虽然一般来说我们直接控制Players的机会不多，都是配置好了就行。但要是到了需要的时候，GameInstance也实现了许多的接口可以让你动态的添加删除Players。
  3. `UI`，UE的UI是另一套World之外的系统，虽然同属于Viewport的显示之下，但是控制结构跟Actor们并不一样。所以我们常常会需要控制UI各种切换的业务逻辑，虽然在Widget的Graph里也可以写些简单的切换，但是要想复用某些切换逻辑的时候，在特定的Wdiget里就不合适了，而GameMode一方面局限于Level，另一方面又只存在于Server；PlayerController也是会切换掉的，同时又只存在于World中，所以最后比较合适的就剩下GameInstance了，以后当然有可能了可能会扩展出个UI的业务逻辑Manger类，不过那是后话了。
  4. **全局的配置**，也常常需要根据平台改变一些游戏的配置，`Execute`一些`ConsoleCommand`，GameInstance也是这些命令的存放地。
  5. 游戏的额外第三方逻辑，如果你的游戏需要其他一些控制，比如自己写的网络通信、自定义的配置文件或者自己的一些程序算法，如果简单的话，GameInstance也可以一放，等复杂起来了，也可以把GameInstance当作一个模块容器，你可以在里面再扩展出来其他的子逻辑模块。当然如果是插件的话，还是在自己的插件Module里面自行管理逻辑，然后把协调工作交给GameInstance来做。

  而在数据层面上，我们层层上来，已经有了针对一个`Player`的`Contoller`的`PlayerState`，也有了针对World的GameMode的`GameState`，到了更全局之上，自然的GameInstance就应该存储一些全局的状态数据。所以你可以在GameInstance的成员变量中添加一些全局的状态，或者是那些想要在Level之外持续存在的对象。不过需要注意的一点是，==GameInstance成员变量中最好只保存那些“临时”的数据，而对于那些想要持久序列化保存的数据，我们就需要接下来的SaveGame了==。把持久的数据直接放在SaveGame，用的时候直接读取出来，之后再直接在其上更新，好处是只用维护一份，省得要保存的时候，还去想到底要选GameInstance的哪些成员变量中来保存，一开始就设计选好，以后就方便了

## SaveGame

UE连玩家存档都帮你做了！得益于`UObject`的序列化机制，现在你只需要继承于`USaveGame`，并添加你想要的那些属性字段，然后这个结构就可以序列化保存下来的。玩家存档也是游戏中一个非常常见的功能，差的引擎一般就只提供给你读写文件的接口，好一点的会继续给你一些序列化机制，而更好的则会服务得更加周到。UE为我们在蓝图里提供了SaveGame的统一接口，让你只用关心想序列化的数据。

USaveGame其实就是为了提供给UE一个UObject对象，本身并不需要其他额外的控制，所以它的类是如此的简单以至于我能直接把它的全部声明展示出来：

```c#
UCLASS(abstract, Blueprintable, BlueprintType)
class ENGINE_API USaveGame : public UObject
{
	/**
	 *	@see UGameplayStatics::CreateSaveGameObject
	 *	@see UGameplayStatics::SaveGameToSlot
	 *	@see UGameplayStatics::DoesSaveGameExist
	 *	@see UGameplayStatics::LoadGameFromSlot
	 *	@see UGameplayStatics::DeleteGameInSlot
	 */

	GENERATED_UCLASS_BODY()
};
```

而`UGameplayStatics`作为暴露给蓝图的接口实现部分，其内部的实现是：

![img](学习总结.assets\v2-5f9893415a3b89cb6ef4c2e217cbf391_720w.png)

先在内存中写入一些`SavegameFileVersion`之类的控制文件头，然后再序列化USaveGame对象，接着会找到`ISaveGameSystem`接口，最后交于真正的子类实现文件的保存。目前的默认实现是`FGenericSaveGameSystem`，其内部也只是转发到直接的文件读写接口上去。但你也可以实现自己的SaveGameSystem，不管是写文件或者是网络传输，保存到不同的地方去。或者是内部调用OnlineSubsystem的Storage接口，直接把玩家存档保存到Steam云存储中也可以。

因此可见，单单是玩家存档这件边角的小事，UE作为一个深受游戏开发淬炼过的引擎，为了方便自己，也同时造福我们广大开发者，已经实现了这么一套完善的机制。

关于存档数据关联的逻辑，再重复几句，对于那些需要直接在全局处理的数据逻辑，也可以直接在SaveGame中写方法来实现。比如实现AddCoin接口，对外隐藏实现，对内可以自定义附加一些逻辑。USaveGame可以看作是一个全局持久数据的业务逻辑类。跟GameInstance里的数据区分就是，GameInstance里面的是临时的数据，SaveGame里是持久的。清晰这一点区分，到时就不会纠结哪些属性放在哪里，哪些方法实现在哪里了。

注意一下，`SaveGameToSlot`里的SlotName可以理解为存档的文件名，`UserIndex`是用来标识是哪个玩家在存档。`UserIndex`是预留的，在目前的UE实现里并没有用到，只是预留给一些平台提供足够的信息。你也可以利用这个信息来为多个不同玩家生成不同的最后文件名什么的。而`ISaveGameSystem`是`IPlatformFeaturesModule`提供的模块接口，关于模块的机制，等引擎流程章节再说吧，目前可以简单理解为一个单件对象里提供了一些平台相关的接口对象。

## 总结

至此，我们可以说已经介绍完了GamePlay下半部分——逻辑控制。在蓝图层，UE并不向BP直接暴露Engine概念，即使在C++层，在实现GamePlay业务时也是很少需要真正直接操纵Engine的时候。如果GamePlay已经足够好，那么Engine自然就可以隐居幕后了。UE用GameInstance实现了全局的控制，并支持多GameInstance来实现编辑器，最后在存档的时候还可以用到SaveGame的方便的接口。

下篇，就是GamePlay章节的最终章，我们将会对GamePlay架构的（一到九）篇进行回顾归纳总结巩固，以一个承上启下总览的眼光，再来重新审视一下UE的整套GamePlay框架，下个章节见。



# GamePlay架构（十）总结

通过对前九篇的介绍，至此我们已经了解了UE里的游戏世界**组织方式**和**游戏业务逻辑的控制**。行百里者半九十，前述的篇章里我们的目光往往专注在于特定一个类或者对象，一方面固然可以让内容更有针对性，但另一方面也有了身在山中不见山的困惑。本文作为GamePlay章节的最终章，就是要回顾我们之前探讨过的内容，以一个更高层总览的眼光，把之前的所有内容有机组织起来，思考整体的结构和数据及逻辑的流向。

## 游戏世界

如果我们在最初篇所问的，如果让你来制作一款3D游戏引擎，你会怎么设计其结构？已经知道，在UE的眼里，游戏世界的万物皆Actor，Actor再通过Component组装功能。Actor又通过UChildActorComponent实现Actor之间的父子嵌套。

![img](学习总结.assets\v2-91234c7d5bc32dd04c7221ac9dcc56d0_720w.jpg)

众多的各种Actor子类又组装成了Level

![img](学习总结.assets\v2-14a202ba552576c2505073cb1543eeae_720w.png)

如此每一个Level就拥有了一座Actor的森林，你可以根据自己的需要定制化Level，比如有些Level是临时Loading场景，有些只是保存光照，有些只是一块静态场景。UE用Level这种细一些粒度的对象为你的想象力提供了极大的自由度，同时也能方便团队内的平行协作。

一个个的Level，又进一步组装成了World:

![img](学习总结.assets\v2-4b0a3d9cb6479a1c8efe736046c06dc5_720w.png)

就像地球上的大陆板块一样，World允许多个Level静态的通过位置摆放在游戏世界中，也允许运行时动态的加载关卡。

而**World之间的切换，UE用了一个WorldContext来保存切换的过程信息**。玩家在切换PersistentLevel的时候，实际上就相当于切换了一个World。而再往上，就是整个游戏唯一的`GameInstance`，由Engine对象管理着。

![img](学习总结.assets\v2-19ce8ccbd2e444a8fb27459614aa602d_720w.png)

到了World这一层，整个游戏的渲染对象就齐全了。但是游戏引擎并不只是渲染，因此为了让玩家也各种方式接入World中开始游戏。**GameInstance下不光保存着World，同时也存储着Player，有着LocalPlayer用于表示本地的玩家，也有NetConnection当作远端的连接。**

![img](学习总结.assets\v2-e7fc2230978792cb4ea8552337a11565_720w.png)

**玩家利用Player对象接入World之后，就可以开始控制Pawn和PlayerController的生成**，有了附身的对象和摄像的眼睛。最后在Engine的**Tick心跳脉搏**驱动下，开始一帧帧的**逻辑更新**和**渲染**。

## 数据和逻辑

**说完了游戏世界的表现组成，那么对于一个GamePlay框架而言自然需要与其配套的业务逻辑架构**。GamePlay架构的后半部分就自底向上的逐一分析了各个层次的逻辑载体，按照MVC的思想，我们可以把整个游戏的GamePlay分为三大部分：表现（View）、逻辑（Controller）、数据（Model）。一图胜千言：

![img](学习总结.assets\v2-b4e0dd15956ccb819fca93e73d1b8ed2_720w.jpg)

最左侧的是我们已经讨论过的游戏世界表现部分，从最最根源的UObject和Actor，一直到UGameEngine，不断的组合起来，形成丰富的游戏世界的各种对象。

1. 从UObject派生下来的AActor，拥有了UObject的反射、序列化、网络同步等功能，同时又通过各种Component，来组装不同组件。UE在AActor身上同时利用了继承和组合的各自优点，同时也规避了彼此的一些缺点，我不得不说，UE在这一方面度把握得非常的平衡优雅，既不像cocos2dx那样继承爆炸，也不像Unity那样走极端全部组件组合。
2. AActor中一些**需要逻辑控制的成员**分化出了APawn。Pawn就像是棋盘上的棋子，或者是战场中的兵卒。**有3个基本的功能**：可被Controller控制、PhysicsCollision表示和MovementInput的基本响应接口。代表了基本的逻辑控制物理表示和行走功能。根据这3个功能的定制化不同，可以派生出不同功能的的DefaultPawn、SpectatorPawn和Character。([GamePlay架构（四）Pawn](https://zhuanlan.zhihu.com/p/23321666))
3. **AController是用来控制APawn的一个特殊的AActor**。同属于AActor的设计，可以让Controller享受到AActor的基本福利，而和APawn分离又可以通过组合来提供更大的灵活性，把表示和逻辑分开，独立变化。([GamePlay架构（五）Controller](https://zhuanlan.zhihu.com/p/23480071))。而AController又根据用法和适用对象的不同，分化出了APlayerController来充当本地玩家的控制器，而AAIController就充当了NPC们的AI智能。([GamePlay架构（六）PlayerController和AIController](https://zhuanlan.zhihu.com/p/23649987))。而数据配套的就是APlayerState，可以充当AController的可网络复制的状态。
4. 到了Level这一层，UE为我们提供了`ALevelScriptActor`（关卡蓝图）当作关卡静态性的逻辑载体。而对于一场游戏或世界的规则，UE提供的AGameMode就只是一个虚拟的逻辑载体，**可以通过PersistentLevel上的AWorldSettings上的配置创建出我们具体的AGameMode子类**。AGameMode同时也是负责在具体的Level中创建出其他的Pawn和PlayerController的负责人，在Level的切换的时候AGameMode也负责协调Actor的迁移。配套的数据对象是AGameState。([GamePlay架构（七）GameMode和GameState](https://zhuanlan.zhihu.com/p/23707588))
5. World构建好了，该派玩家进来了。但游戏的方式多样，玩家的接入方式也多样。UE为了支持各种不同的玩家模式，抽象出了UPlayer实体来实际上控制游戏中的玩家PlayerController的生成数量和方式。([GamePlay架构（八）Player](https://zhuanlan.zhihu.com/p/23826859))
6. **所有的表示和逻辑汇集到一起，形成了全局唯一的UGameInstance对象**，代表着整个游戏的开始和结束。同时为了方便开发者进行玩家存档，提供了USaveGame进行全局的数据配套。([GamePlay架构（九）GameInstance](https://zhuanlan.zhihu.com/p/24005952))

在分析UE这么一个**GamePlay系统**的时候，就像UML有各种图一样，我们也应该从各个切面去分析它的构成。这里有两大基本原则：==单一职责和变化隔离==，但也可以说只有一个。所有的程序设计模式都只是在抽象变化，把变化都抽离开了，剩下的不就是单一职责了嘛。所以UE里对MVC的实践其实也只是在不断抽离出各个对象的变化部分，**把Pawn的逻辑抽出来是Controller，把数据抽出来是PlayerState**。**把World的Level静态逻辑抽出来是关卡蓝图，把动态的游戏玩法抽离出来是GameMode**，把游戏数据抽离出来是GameState。具体的每个层次的数据和逻辑的关系前文已经一一详细说过了，此处就不再赘述了。但也再次着重探讨一些分析方法：

- 从竖直的角度来看，左侧是表示，中间是逻辑，右侧是数据。
  - 当我们谈到表示的时候，脑袋里想的应该是一个单纯的展示对象，就像一个基本的网络物体，它可以带一些基本的动画，再多一些功能，也顶多只能像一个木偶，有着一些非常机械原始的行为。我们让他前进，他可以知道左腿右腿交替着迈，但他是无知觉的。所以**左侧的那一串对象，你应该尽量得让他们保持简单**。
  - **实现中间的逻辑的时候，你应该专注于逻辑本身，尽量的忘记两旁的表示和数据**。去思考哪些逻辑是表示固有的还是比较智能判断的。哪些Controller或Mode我们应该尽量的让它们通用，哪些就让它们特定的负责某一块，有些也不能强求，自己把握好度。
  - **右侧的数据，同样的保持简单。我们把它们分离出来的目的就是为了独立变化和在网络间同步**，注意一下别走回头路了就好。我们应该只在此放置纯数据。
- 从水平的切面上看，依次自底向上，记住一个原则，**哪个层次的应该尽量只负责哪个层次的东西，不要对上层或下层的细节知道得太多**，也尽量不要逾矩越权去指手画脚别的对象里的内务事。大家通力协作，注重隐私，保持安全距离，不就社会和谐了嘛。
  - **最底层的Component，应该只是实现一些与游戏逻辑无关的功能。理解这个“无关”是关键。**==换个游戏，你这些Component依然可以用，就是所谓的游戏无关==。
  - Actor层，通过Pawn、Controller和PlayerState的合作，根据需要旗下再派生出特定的Character，或PlayerController，AIController，但它们的合作模式，三大家族的长老们已经定下了，后辈们应该尽量遵守。这一层，**关键的地方在于分清楚哪些是操作Actor的，别向下把Actor内部的功能给抽了出来，也别大包大揽把整个游戏的玩法也管了过来**。脑袋保持清醒，这一层所做的事，就是为了让Actor们显得更加的智能。换句话说，**这些智能的Actor组合，理论上是可以在随便哪个Level里用的**。
  - Level和World层，**分清楚静态的关卡蓝图和动态可组合GameMode。静态的意思是这个场景本身的运作机制，动态的指的是可以像切换比赛方式一样切换一场游戏的目的。**在这一层上，你得有总览游戏大局的自觉了，咱们都是干大事的人，眼光就不要局限在那些一兵一卒那些小事了。制定好游戏规则，赋予这一场游戏以意义，是GameMode最重要的职责。注意两点，一是脑袋里有跟弦，一旦开始联机环境了，GameMode就升职到Server里去了，Client就没有了，所以**千万要小心别在GameMode做些客户端的小事**；二是**GameState是表示一场游戏的数据的，而PlayerState是表示Controller的数据**，对象和范围都不同，不能混了。
  - **GameInstance层，一般来说Player不需要你做太多事情，UE已经帮你处理好了**。虽说力量越大，责任就越大，但领导日理万机累坏了也不行是吧。所以GameInstance作为全局的唯一逻辑对象，我们如果能不打扰他就尽量少把事推给他，否则你很快就会看着GameInstance里堆着一山东西。GameInstance身在高层，应该只尽量做一些Level之间的协调工作。而SaveGame也应该尽量只保存游戏持久的数据。

自始至终，回顾一下每个类的本身的职责，该是他的就是他的，别人的不要抢。读者朋友们，如果到此觉得似乎懂了一些，但还是觉得不够深刻理解的话，也没关系，凡事不能一蹴而就，在开发过程中多想多琢磨自然而然就会慢慢领悟了。

## 整体类图

从类的继承层次上，咱们再加深一下理解。下图只列出了GamePlay架构里一些相关的重要的类：

![img](学习总结.assets\v2-c0cd2e5121f63c37615f78476e2a425c_720w.jpg)

由此也可以看出来，UE基于UObject的机制出发，构建出了纷繁复杂的游戏世界，**几乎所有的重要的类都直接或间接的继承于UObject，都能充分利用到UObject的反射等功能，大大加强了整体框架的灵活度和表达能力**。比如GamePlay中最常用到根据某个**Class配置**在运行时创建出特定的对象的行为就是利用了反射功能；而网络里的属性同步也是利用了UObject的网络同步RPC调用；一个Level想保存成uasset文件，或者USaveGame想存档，也都是利用了UObject的序列化；而利用了UObject的CDO（Class Default Object），在保存时候也大大节省了内存；这么多Actor对象能在编辑器里方便的编辑，也得益于UObject的属性编辑器集成；对象互相引用的从属关系有了UObject的垃圾回收之后我们就不用担心会释放问题了。想象一下如果一开始没有设计出UObject，那么这个GamePlay框架肯定是另一番模样了。

## 总结

对于GamePlay我们从构建游戏世界开始，再到一层层的逻辑控制，本篇也从各个切面上总结归纳了整体架构。希望读者们好好领会UE的GamePlay架构思想，别贪快，整体上慢慢琢磨以上的架构图，细节上可以回顾过往的单篇来了解。

对于这一套UE提供的GamePlay框架，我们既然选择了用UE引擎，那么自然就应该想着怎么充分利用好它。框架就是你如果在它的规则下办事，那它就是事半功倍的助力器，你会常常发现UE怎么连这个也帮你做完了；而如果你在不了解的情况下想逆着它行事，就常常感受到怎么哪里都受到束缚。我们对于框架的理念应该就像是对待一辆汽车一般，我们关心的是怎么驾驶它到达想要的目的他，而不是折腾着怪它四个轮子不能按照你的心意朝不同方向乱转。对比隔壁的Cocos2dx、或Unity、或CryEngine，UE能够提供这么一个完善的GamePlay框架，对我们开发者而言，是一件幸福的事，不是吗？

