# GamePlay架构（一）Actor和Component

## UObject

UE创世，万物皆UObject，接着有Actor。藉着UObject提供的元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等，UE可以构建一个Object运行的世界。

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175503021-1621936563697.png" alt="image-20210525175503021" style="zoom:67%;" />

## Actor

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175557946.png" alt="image-20210525175557946" style="zoom:50%;" />

脱胎自`Object`的`Actor`也多了一些本事：Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)。

❓**思考：为何Actor不像GameObject一样自带Transform？**

- 因为UE跟贴近C++一些的缘故，所以设计哲学上就更偏向于C++的哲学：==不为你不需要的东西付代价==。一个Transform再加上附带的逆矩阵之类的表示，内存占用上其实也是挺可观的。

- 经过了UE的权衡和考虑，把Transform封装进了`SceneComponent`，当作`RootComponent`。

  

## Component

`UActorComponent`也是派生于UObject的一个子类，这意味着其实Component也是有UObject的那些通用功能的。

`TSet<UActorComponent*> OwnedComponents` 保存着这个Actor所拥有的所有Component，一般其中会有一个`SceneComponent`作为RootComponent。`TArray<UActorComponent*> InstanceComponents` 保存着**实例化的Components**。实例化是个什么意思呢，就是你在蓝图里Details定义的Component，当这个Actor被实例化的时候，这些附属的Component也会被实例化。

一个Actor若想可以被放进Level（关卡）里，就必须实例化`USceneComponent* RootComponent`。

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175923625.png" alt="image-20210525175923625" style="zoom:67%;" />

ActorComponent下面**最重要的一个Component就非SceneComponent莫属了**。SceneComponent提供了**两大能力**：

- 一是Transform
- 二是SceneComponent的互相嵌套。

❓**思考：为何ActorComponent不能互相嵌套？而在SceneComponent一级才提供嵌套？**

- ActorComponent下面当然不是只有SceneComponent，一些UMovementComponent，AIComponent，或者是我们自己写的Component，都是会直接继承ActorComponent的。但很奇怪的是，ActorComponent却是不能嵌套的，在UE的观念里，好像只有带Transform的SceneComponent才有资格被嵌套，好像Component的互相嵌套必须和3D里的transform父子对应起来。
- 从功能上来说，UE更倾向于编写功能单一的Component（如UMovementComponent），而不是一个整合了其他Component的大管家Component（当然如果你偏要这么干，那UE也阻止不了你）。

**❓思考：Actor的SceneComponent哲学**

​	//toCopy

❓**思考：Actor之间的父子关系是怎么确定的？**

- 你应该已经注意到了Actor里面的`TArray<AActor*> Children`字段，所以你可能会期望看到Actor:AddChild之类的方法，很遗憾。在UE里，==Actor之间的父子关系却是通过Component确定的==。同一般的Parent:AddChild操作原语不同，UE里是通过**Child:AttachToActor**或**Child:AttachToComponent**来创建父子连接的。

  ```c++
  void AActor::AttachToActor(AActor* ParentActor, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && ParentActor)
      {
          USceneComponent* ParentDefaultAttachComponent = ParentActor->GetDefaultAttachComponent();
          if (ParentDefaultAttachComponent)
          {
              RootComponent->AttachToComponent(ParentDefaultAttachComponent, AttachmentRules, SocketName);
          }
      }
  }
  void AActor::AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && Parent)
      {
          RootComponent->AttachToComponent(Parent, AttachmentRules, SocketName);
      }
  }
  ```

- Actor父子之间的“关系”隐含了许多数据，而这些数据都是在Component上提供的。==Actor其实更像是一个容器，只提供了基本的创建销毁，网络复制，事件触发等一些逻辑性的功能==，而把父子的关系维护都交给了具体的Component，**所以更准确的说，其实是不同Actor的SceneComponent之间有父子关系，而Actor本身其实并不太关心。**

📚**聊一聊ChildActorComponent**

![image-20210525181105823](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525181105823.png)

同作为最常用到的Component之一，`ChildActorComponent`担负着**Actor之间互相组合的胶水**。这货在**蓝图里静态存在的时候**其实并不真正的创建Actor，而是在之后**Component实例化**的时候才真正创建。

```c++
void UChildActorComponent::OnRegister()
{
    Super::OnRegister();
    if (ChildActor)
    {
        if (ChildActor->GetClass() != ChildActorClass)
        {
            DestroyChildActor();
            CreateChildActor();
        }
        else
        {
            ChildActorName = ChildActor->GetFName();
            USceneComponent* ChildRoot = ChildActor->GetRootComponent();
            if (ChildRoot && ChildRoot->GetAttachParent() != this)
            {
                // attach new actor to this component
                // we can't attach in CreateChildActor since it has intermediate Mobility set up
                // causing spam with inconsistent mobility set up
                // so moving Attach to happen in Register
                ChildRoot->AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
            }
            // Ensure the components replication is correctly initialized
            SetIsReplicated(ChildActor->GetIsReplicated());
        }
    }
    else if (ChildActorClass)
    {
        CreateChildActor();
    }
}
void UChildActorComponent::OnComponentCreated()
{
    Super::OnComponentCreated();
    CreateChildActor();
}
```

这就导致了一个问题，当你把一个ActorClass拖进Level后，这个Actor实际是已经实例化了,你可以直接调整这个Actor的属性。但是你把它拖到另一个Actor Class里，它只会给你空空白白的ChildActorComponent的DetailsPanel，你想调整Actor的属性，就只能等生成了之后，用蓝图或代码去修改。这一点来说，其实还是挺不方便的，我个人觉得应该是还有优化的空间。

> UE终于听到了人民群众的呼声，在4.14里增加了Child Actor Templates来支持在子ChildActor的DetailsPannel里查看和修改属性。



# GamePlay架构（二）Level和World

> 由一个或多个Level组成一个World。

## Level

在UE的世界中，我们之前已经有了空气（C++）,土壤（UObject），物件（Actor）。而现在UE又施展神力创建了一片片大陆（Level），在这片大陆上（.map文件），Actor们秩序井然，各种地形拔地而起，植被繁茂，天空雾云缭绕，圣光普照，这也是玩家们降生开始精彩冒险的地方。

![image-20210525181811179](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525181811179.png)

可以从ULevel的前缀U看出来**Level（大陆）也确实是继承于UObject（土壤）**的。那既然同属于Object下面的各Actor们都拥有了一定的智能能力（支持蓝图脚本），Level自然也得体现出大地的意志，所以**默认带了一个土地公（ALevelScriptActor）**，允许我们在关卡里编写脚本，可以对本关卡里的所有Actor通过名字呼之则来，**关卡蓝图实际上就代表着该片大陆上的运行规则**。

在Level已经有了管理者之后，一开始大家都挺满意，但渐渐的就发现，**好像各个Level需要的功能好像都差不多**，都是修改一下光照，物理等一些属性。所以为了方便起见，**UE便给每一个Level也都默认配了一个书记官（Info）**，他一一记录着本Level的各种规则属性，在UE需要的时候便负责相告。更重要的是，在Level需要有其他管理人员一起协助的时候，他也记录着`GameMode`的名字来让UE可以指派。

前面我们说过，有一些Actor是不“显示”的（**没有SceneComponent**），是不能“摆放”到Level里的，但是它依然可以在关卡里出力。其中一个家族系列就是`AInfo`和其子类。今天我们只简单介绍一下跟Level直接相关的一位书记官：==AWorldSettings==。

![image-20210525182200300](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525182200300.png)

> 虽然名字叫做WorldSettings，但其实只是跟Level相关

❓**思考：为何AWorldSettings要放进在Actors[0]的位置？而ALevelScriptActor却不用？**

```c++
void ULevel::SortActorList()
{
    //[...]
    TArray<AActor*> NewActors;
    TArray<AActor*> NewNetActors;
    NewActors.Reserve(Actors.Num());
    NewNetActors.Reserve(Actors.Num());
    // The WorldSettings tries to stay at index 0
    NewActors.Add(WorldSettings);
    // Add non-net actors to the NewActors immediately, cache off the net actors to Append after
    for (AActor* Actor : Actors)
    {
        if (Actor != nullptr && Actor != WorldSettings && !Actor->IsPendingKill())
        {
            if (IsNetActor(Actor))
            {
                NewNetActors.Add(Actor);
            }
            else
            {
                NewActors.Add(Actor);
            }
        }
    }
    iFirstNetRelevantActor = NewActors.Num();
    NewActors.Append(MoveTemp(NewNetActors));
    Actors = MoveTemp(NewActors);   // Replace with sorted list.
    // Add all network actors to the owning world
    //[...]
}
```

- 实际上通过这一段代码可知，**Actors们的排序依据**是把那些**“非网络”的Actor放在前面**，而把**“网络可复制”的Actor们放在后面**，然后加一个起始索引标记`iFirstNetRelevantActor`，相当于为网络Actor划分了一个缓存，从而加速了网络复制时的检测速度。`AWorldSettings`因为都是静态的数据提供者，在游戏运行过程中也不会改变，不需要网络复制，所以也就可以一直放在前列，而如果再加个规则，一直放在第一个的话，也能同时把AWorldSettings和其他的前列Actor们再度区分开，在需要的时候也能加速判断。**ALevelScriptActor因为是代表关卡蓝图，是允许携带“复制”变量函数的，所以也有可能被排序到后列**。

**❓思考：既然ALevelScriptActor也继承于AActor,为何关卡蓝图不设计能添加Component？**

- 平常我们在创建Actor的时候，我们蓝图界面是可以创建Component的。那为什么在关卡蓝图里，却不能这么做（没有提供该界面功能）？虽然在图里标出了Level中拥有**ModelComponents**，但那其实只是**针对BSP应用的一个子集**。通过源码发现，其实UE自己也是在C++里往`ALevelScriptActor`添加**UInputComponent**来**实现关卡蓝图可以响应事件**。

- 其实既然ALevelScriptActor是个Actor，那意味着我们当然可以为它添加组件，实际上也确实可以这么做。比如你可以在关卡蓝图里这么干：

  <img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525182911023.png" alt="image-20210525182911023" style="zoom:67%;" />

❓那么好好想想，为啥`UE`要给你这么一个**关卡蓝图界面**呢？

- 在此，我也只能进行一番猜测，`ALevelScriptActor`作为一个特化的Actor，却把Components列表界面给隐藏了，说明UE其实是不希望我们去复杂化关卡构成的。
- 假设说UE开放了关卡Component，那么我们在创建组件时就必然要考虑一个问题：哪些是ActorComponent，哪些是LevelComponent，再怎么ALevelScriptActor本质是个Actor，但Level的概念还是要突出，ALevelScriptActor的Actor本质是要隐藏的。所以用户就会多一些心智负担，可能混淆。而如果像这样不开放，大家的思路就都转向先创建个Actor，然后再往之上添加component，思路会比较统一清晰。
- 再之，从游戏逻辑的组织上来说，Level其实更应该表现为一个Actor的容器。UE其实也是不鼓励在Level里编写太复杂的逻辑的。所以才接着会有了之后的GameMode,Controller那些真正的逻辑控制类（后续会再细讨论）。



## World

终于，到了把大陆们（Level）拼装起来的时候了。可以用==SubLevel==的方式：

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183442256.png" alt="image-20210525183442256" style="zoom:80%;" />

也支持`WorldComposition`的方式自动把项目里的所有Level都组合起来，并设置摆放位置：

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183500177.png" alt="image-20210525183500177" style="zoom:80%;" />

简单本质来说，就是==一个World里有多个Level==，这些Level在什么位置，是在一开始就加载进来，还是Streaming运行时加载。**UE里每个World支持一个PersistentLevel和多个其他Level**：

![image-20210525183602080](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183602080.png)

**Persistent的意思是一开始就加载进World**，**Streaming是后续动态加载的意思**。Levels里保存有所有的、当前已经加载的Level，`StreamingLevels`保存整个World的**Levels配置列表**。PersistentLevel和CurrentLevel只是个快速引用。在编辑器里编辑的时候，CurrentLevel可以指向其他Level，但**运行时CurrentLevel只能是指向PersistentLevel**。

❓**思考：为何要有主PersistentLevel？**

- 首先，World至少得有一个Level，就像你也得先出生在一块大陆上才可以继续谈起去探索别的新大陆。所以这块玩家出生的大陆就是主Level了。当然了，因为我们也可以同时配置别的Level一开始就加载进来，其实跟PersistentLevel是差不多等价的，但再考虑到另一问题：Levels拼接进World一起之后，各自有各自的worldsetting，那整个World的配置应该以谁的为主？
- ==World的Settings也是以PersistentLevel为主的==，但这也并不以为着其他Level的Settings就完全没有作用了，本篇也无法一一列出所有配置选项来说明，简单来说，就是**需要在整个世界范围内起作用的配置选项（比如VR的WorldToMeters，KillZ，WorldGravity其他大部分都是）就是需要从主PersistentLevel的配置中提取**。而一些配置选项可以在单独Level中起作用的，比如在编辑Level时的**光照质量配置就是一个个Level单独的**，目前这种配置很少，但可能以后也会增加。

**❓思考：Levels们的Actors和World有直接关系吗？**

- 当别的Level被添加进当前World之后，我们能直接在WorldOutliner里看到其他Level的Actor们。

![image-20210525184037168](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525184037168.png)

- 但这并不代表着World直接引用了Level里的Actor们。TActorIteratorBase（World的Actor迭代器）内部的实现也只是在遍历Levels来获得所有Actor。当然World为了更快速的操作Controllers和Pawn也都保存了引用。但**Levels却共享着World的一个PhysicsScene**，这也意味着**Levels里的Actors的物理实体其实都是在World里的**，这也好理解，毕竟物理的碰撞之类的当然要是全局的了。再说到导航，**World在拼接Level的时候，也是会同时把两个Level的导航网格给“拼接”起来的**。当然目前还不是深入细节的时候，现在只要从大局上明白World-Level-Actor的关系。

## 总结

==Level作为Actor的容器，同时也划分了World==，一方面支持了Level的动态加载，另一方面也允许了团队的实时协作，大家可以同时并行编辑不同的Level。一般而言，一个玩家从游戏开始到结束，UE会创造一个GameWorld给玩家并一直存在。**玩家切换场景或关卡，也只是在这个World中加载释放不同的Level**。既然Level拥有了管理者（LevelScriptActor），玩家可以编写特定关卡的逻辑，那么我们能否对World这种层次编写逻辑呢？答案是肯定的，不过本文篇幅有限，敬请期待下篇。

