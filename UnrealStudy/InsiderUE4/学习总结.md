# GamePlay架构（一）Actor和Component

## UObject

UE创世，万物皆UObject，接着有Actor。藉着UObject提供的元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等，UE可以构建一个Object运行的世界。

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175503021-1621936563697.png" alt="image-20210525175503021" style="zoom:67%;" />

## Actor

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175557946.png" alt="image-20210525175557946" style="zoom:50%;" />

脱胎自`Object`的`Actor`也多了一些本事：Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)。

❓**思考：为何Actor不像GameObject一样自带Transform？**

- 因为UE跟贴近C++一些的缘故，所以设计哲学上就更偏向于C++的哲学：==不为你不需要的东西付代价==。一个Transform再加上附带的逆矩阵之类的表示，内存占用上其实也是挺可观的。

- 经过了UE的权衡和考虑，把Transform封装进了`SceneComponent`，当作`RootComponent`。

  

## Component

`UActorComponent`也是派生于UObject的一个子类，这意味着其实Component也是有UObject的那些通用功能的。

`TSet<UActorComponent*> OwnedComponents` 保存着这个Actor所拥有的所有Component，一般其中会有一个`SceneComponent`作为RootComponent。`TArray<UActorComponent*> InstanceComponents` 保存着**实例化的Components**。实例化是个什么意思呢，就是你在蓝图里Details定义的Component，当这个Actor被实例化的时候，这些附属的Component也会被实例化。

一个Actor若想可以被放进Level（关卡）里，就必须实例化`USceneComponent* RootComponent`。

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525175923625.png" alt="image-20210525175923625" style="zoom:67%;" />

ActorComponent下面**最重要的一个Component就非SceneComponent莫属了**。SceneComponent提供了**两大能力**：

- 一是Transform
- 二是SceneComponent的互相嵌套。

❓**思考：为何ActorComponent不能互相嵌套？而在SceneComponent一级才提供嵌套？**

- ActorComponent下面当然不是只有SceneComponent，一些UMovementComponent，AIComponent，或者是我们自己写的Component，都是会直接继承ActorComponent的。但很奇怪的是，ActorComponent却是不能嵌套的，在UE的观念里，好像只有带Transform的SceneComponent才有资格被嵌套，好像Component的互相嵌套必须和3D里的transform父子对应起来。
- 从功能上来说，UE更倾向于编写功能单一的Component（如UMovementComponent），而不是一个整合了其他Component的大管家Component（当然如果你偏要这么干，那UE也阻止不了你）。

**❓思考：Actor的SceneComponent哲学**

​	//toCopy

❓**思考：Actor之间的父子关系是怎么确定的？**

- 你应该已经注意到了Actor里面的`TArray<AActor*> Children`字段，所以你可能会期望看到Actor:AddChild之类的方法，很遗憾。在UE里，==Actor之间的父子关系却是通过Component确定的==。同一般的Parent:AddChild操作原语不同，UE里是通过**Child:AttachToActor**或**Child:AttachToComponent**来创建父子连接的。

  ```c++
  void AActor::AttachToActor(AActor* ParentActor, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && ParentActor)
      {
          USceneComponent* ParentDefaultAttachComponent = ParentActor->GetDefaultAttachComponent();
          if (ParentDefaultAttachComponent)
          {
              RootComponent->AttachToComponent(ParentDefaultAttachComponent, AttachmentRules, SocketName);
          }
      }
  }
  void AActor::AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && Parent)
      {
          RootComponent->AttachToComponent(Parent, AttachmentRules, SocketName);
      }
  }
  ```

- Actor父子之间的“关系”隐含了许多数据，而这些数据都是在Component上提供的。==Actor其实更像是一个容器，只提供了基本的创建销毁，网络复制，事件触发等一些逻辑性的功能==，而把父子的关系维护都交给了具体的Component，**所以更准确的说，其实是不同Actor的SceneComponent之间有父子关系，而Actor本身其实并不太关心。**

📚**聊一聊ChildActorComponent**

![image-20210525181105823](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525181105823.png)

同作为最常用到的Component之一，`ChildActorComponent`担负着**Actor之间互相组合的胶水**。这货在**蓝图里静态存在的时候**其实并不真正的创建Actor，而是在之后**Component实例化**的时候才真正创建。

```c++
void UChildActorComponent::OnRegister()
{
    Super::OnRegister();
    if (ChildActor)
    {
        if (ChildActor->GetClass() != ChildActorClass)
        {
            DestroyChildActor();
            CreateChildActor();
        }
        else
        {
            ChildActorName = ChildActor->GetFName();
            USceneComponent* ChildRoot = ChildActor->GetRootComponent();
            if (ChildRoot && ChildRoot->GetAttachParent() != this)
            {
                // attach new actor to this component
                // we can't attach in CreateChildActor since it has intermediate Mobility set up
                // causing spam with inconsistent mobility set up
                // so moving Attach to happen in Register
                ChildRoot->AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
            }
            // Ensure the components replication is correctly initialized
            SetIsReplicated(ChildActor->GetIsReplicated());
        }
    }
    else if (ChildActorClass)
    {
        CreateChildActor();
    }
}
void UChildActorComponent::OnComponentCreated()
{
    Super::OnComponentCreated();
    CreateChildActor();
}
```

这就导致了一个问题，当你把一个ActorClass拖进Level后，这个Actor实际是已经实例化了,你可以直接调整这个Actor的属性。但是你把它拖到另一个Actor Class里，它只会给你空空白白的ChildActorComponent的DetailsPanel，你想调整Actor的属性，就只能等生成了之后，用蓝图或代码去修改。这一点来说，其实还是挺不方便的，我个人觉得应该是还有优化的空间。

> UE终于听到了人民群众的呼声，在4.14里增加了Child Actor Templates来支持在子ChildActor的DetailsPannel里查看和修改属性。



# GamePlay架构（二）Level和World

> 由一个或多个Level组成一个World。

## Level

在UE的世界中，我们之前已经有了空气（C++）,土壤（UObject），物件（Actor）。而现在UE又施展神力创建了一片片大陆（Level），在这片大陆上（.map文件），Actor们秩序井然，各种地形拔地而起，植被繁茂，天空雾云缭绕，圣光普照，这也是玩家们降生开始精彩冒险的地方。

![image-20210525181811179](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525181811179.png)

可以从ULevel的前缀U看出来**Level（大陆）也确实是继承于UObject（土壤）**的。那既然同属于Object下面的各Actor们都拥有了一定的智能能力（支持蓝图脚本），Level自然也得体现出大地的意志，所以**默认带了一个土地公（ALevelScriptActor）**，允许我们在关卡里编写脚本，可以对本关卡里的所有Actor通过名字呼之则来，**关卡蓝图实际上就代表着该片大陆上的运行规则**。

在Level已经有了管理者之后，一开始大家都挺满意，但渐渐的就发现，**好像各个Level需要的功能好像都差不多**，都是修改一下光照，物理等一些属性。所以为了方便起见，**UE便给每一个Level也都默认配了一个书记官（Info）**，他一一记录着本Level的各种规则属性，在UE需要的时候便负责相告。更重要的是，在Level需要有其他管理人员一起协助的时候，他也记录着`GameMode`的名字来让UE可以指派。

前面我们说过，有一些Actor是不“显示”的（**没有SceneComponent**），是不能“摆放”到Level里的，但是它依然可以在关卡里出力。其中一个家族系列就是`AInfo`和其子类。今天我们只简单介绍一下跟Level直接相关的一位书记官：==AWorldSettings==。

![image-20210525182200300](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525182200300.png)

> 虽然名字叫做WorldSettings，但其实只是跟Level相关

❓**思考：为何AWorldSettings要放进在Actors[0]的位置？而ALevelScriptActor却不用？**

```c++
void ULevel::SortActorList()
{
    //[...]
    TArray<AActor*> NewActors;
    TArray<AActor*> NewNetActors;
    NewActors.Reserve(Actors.Num());
    NewNetActors.Reserve(Actors.Num());
    // The WorldSettings tries to stay at index 0
    NewActors.Add(WorldSettings);
    // Add non-net actors to the NewActors immediately, cache off the net actors to Append after
    for (AActor* Actor : Actors)
    {
        if (Actor != nullptr && Actor != WorldSettings && !Actor->IsPendingKill())
        {
            if (IsNetActor(Actor))
            {
                NewNetActors.Add(Actor);
            }
            else
            {
                NewActors.Add(Actor);
            }
        }
    }
    iFirstNetRelevantActor = NewActors.Num();
    NewActors.Append(MoveTemp(NewNetActors));
    Actors = MoveTemp(NewActors);   // Replace with sorted list.
    // Add all network actors to the owning world
    //[...]
}
```

- 实际上通过这一段代码可知，**Actors们的排序依据**是把那些**“非网络”的Actor放在前面**，而把**“网络可复制”的Actor们放在后面**，然后加一个起始索引标记`iFirstNetRelevantActor`，相当于为网络Actor划分了一个缓存，从而加速了网络复制时的检测速度。`AWorldSettings`因为都是静态的数据提供者，在游戏运行过程中也不会改变，不需要网络复制，所以也就可以一直放在前列，而如果再加个规则，一直放在第一个的话，也能同时把AWorldSettings和其他的前列Actor们再度区分开，在需要的时候也能加速判断。**ALevelScriptActor因为是代表关卡蓝图，是允许携带“复制”变量函数的，所以也有可能被排序到后列**。

**❓思考：既然ALevelScriptActor也继承于AActor,为何关卡蓝图不设计能添加Component？**

- 平常我们在创建Actor的时候，我们蓝图界面是可以创建Component的。那为什么在关卡蓝图里，却不能这么做（没有提供该界面功能）？虽然在图里标出了Level中拥有**ModelComponents**，但那其实只是**针对BSP应用的一个子集**。通过源码发现，其实UE自己也是在C++里往`ALevelScriptActor`添加**UInputComponent**来**实现关卡蓝图可以响应事件**。

- 其实既然ALevelScriptActor是个Actor，那意味着我们当然可以为它添加组件，实际上也确实可以这么做。比如你可以在关卡蓝图里这么干：

  <img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525182911023.png" alt="image-20210525182911023" style="zoom:67%;" />

❓那么好好想想，为啥`UE`要给你这么一个**关卡蓝图界面**呢？

- 在此，我也只能进行一番猜测，`ALevelScriptActor`作为一个特化的Actor，却把Components列表界面给隐藏了，说明UE其实是不希望我们去复杂化关卡构成的。
- 假设说UE开放了关卡Component，那么我们在创建组件时就必然要考虑一个问题：哪些是ActorComponent，哪些是LevelComponent，再怎么ALevelScriptActor本质是个Actor，但Level的概念还是要突出，ALevelScriptActor的Actor本质是要隐藏的。所以用户就会多一些心智负担，可能混淆。而如果像这样不开放，大家的思路就都转向先创建个Actor，然后再往之上添加component，思路会比较统一清晰。
- 再之，从游戏逻辑的组织上来说，Level其实更应该表现为一个Actor的容器。UE其实也是不鼓励在Level里编写太复杂的逻辑的。所以才接着会有了之后的GameMode,Controller那些真正的逻辑控制类（后续会再细讨论）。



## World

终于，到了把大陆们（Level）拼装起来的时候了。可以用==SubLevel==的方式：

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183442256.png" alt="image-20210525183442256" style="zoom:80%;" />

也支持`WorldComposition`的方式自动把项目里的所有Level都组合起来，并设置摆放位置：

<img src="C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183500177.png" alt="image-20210525183500177" style="zoom:80%;" />

简单本质来说，就是==一个World里有多个Level==，这些Level在什么位置，是在一开始就加载进来，还是Streaming运行时加载。**UE里每个World支持一个PersistentLevel和多个其他Level**：

![image-20210525183602080](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525183602080.png)

**Persistent的意思是一开始就加载进World**，**Streaming是后续动态加载的意思**。Levels里保存有所有的、当前已经加载的Level，`StreamingLevels`保存整个World的**Levels配置列表**。PersistentLevel和CurrentLevel只是个快速引用。在编辑器里编辑的时候，CurrentLevel可以指向其他Level，但**运行时CurrentLevel只能是指向PersistentLevel**。

❓**思考：为何要有主PersistentLevel？**

- 首先，World至少得有一个Level，就像你也得先出生在一块大陆上才可以继续谈起去探索别的新大陆。所以这块玩家出生的大陆就是主Level了。当然了，因为我们也可以同时配置别的Level一开始就加载进来，其实跟PersistentLevel是差不多等价的，但再考虑到另一问题：Levels拼接进World一起之后，各自有各自的worldsetting，那整个World的配置应该以谁的为主？
- ==World的Settings也是以PersistentLevel为主的==，但这也并不以为着其他Level的Settings就完全没有作用了，本篇也无法一一列出所有配置选项来说明，简单来说，就是**需要在整个世界范围内起作用的配置选项（比如VR的WorldToMeters，KillZ，WorldGravity其他大部分都是）就是需要从主PersistentLevel的配置中提取**。而一些配置选项可以在单独Level中起作用的，比如在编辑Level时的**光照质量配置就是一个个Level单独的**，目前这种配置很少，但可能以后也会增加。

**❓思考：Levels们的Actors和World有直接关系吗？**

- 当别的Level被添加进当前World之后，我们能直接在WorldOutliner里看到其他Level的Actor们。

![image-20210525184037168](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210525184037168.png)

- 但这并不代表着World直接引用了Level里的Actor们。TActorIteratorBase（World的Actor迭代器）内部的实现也只是在遍历Levels来获得所有Actor。当然World为了更快速的操作Controllers和Pawn也都保存了引用。但**Levels却共享着World的一个PhysicsScene**，这也https://learn.unrealengine.com/course/3536489?r=False&ts=637454196686960980意味着**Levels里的Actors的物理实体其实都是在World里的**，这也好理解，毕竟物理的碰撞之类的当然要是全局的了。再说到导航，**World在拼接Level的时候，也是会同时把两个Level的导航网格给“拼接”起来的**。当然目前还不是深入细节的时候，现在只要从大局上明白World-Level-Actor的关系。

## 总结

==Level作为Actor的容器，同时也划分了World==，一方面支持了Level的动态加载，另一方面也允许了团队的实时协作，大家可以同时并行编辑不同的Level。一般而言，一个玩家从游戏开始到结束，UE会创造一个GameWorld给玩家并一直存在。**玩家切换场景或关卡，也只是在这个World中加载释放不同的Level**。既然Level拥有了管理者（LevelScriptActor），玩家可以编写特定关卡的逻辑，那么我们能否对World这种层次编写逻辑呢？答案是肯定的，不过本文篇幅有限，敬请期待下篇。



# GamePlay架构（三）WorldContext，GameInstance，Engine

## WorldContext

**一个游戏里是只有一个World吗**？==答案是否定的==，首先`World`就不是只有一种类型，比如**编辑器**本身就也是一个World，里面显示的**游戏场景也是一个World**，这两个World互相协作构成了我们的编辑体验。然后点播放的时候，引擎又可以生成新的类型World来让我们测试。简单来说，UE其实是一个平行宇宙世界观。
以下是一些世界类型：

```c#
namespace EWorldType
{
	enum Type
	{
		None,		// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels
		Game,		// The game world
		Editor,		// A world being edited in the editor
		PIE,		// A Play In Editor world
		Preview,	// A preview world for an editor tool
		Inactive	// An editor world that was loaded but not currently being edited in the level editor
	};
}
```

而UE用来管理和跟踪这些`World`的工具就是==WorldContext==：

![image-20210527194057422](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527194057422.png)

`FWorldContext`保存着`ThisCurrentWorld`来指向**当前的World**。而当需要从一个World切换到另一个World的时候（比如说当点击播放时，就是从Preview切换到PIE），FWorldContext就用来保存**切换过程信息**和**目标World上下文信息**。所以一般在切换的时候，比如OpenLevel，也都会需要传`FWorldContext`的参数。对于独立运行的游戏，WorldContext只有唯一个。**而对于编辑器模式，则是一个WorldContext给编辑器，一个WorldContext给PIE（Play In Editor）的World**。一般来说我们不需要直接操作到这个类，引擎内部已经处理好各种World的协作。不仅如此，**FWorldContext还保存着World里Level切换的上下文**：

```c#
struct FWorldContext
{
    [...]
	TEnumAsByte<EWorldType::Type>	WorldType;

	FSeamlessTravelHandler SeamlessTravelHandler;

	FName ContextHandle;

	/** URL to travel to for pending client connect */
	FString TravelURL;

	/** TravelType for pending client connects */
	uint8 TravelType;

	/** URL the last time we traveled */
	UPROPERTY()
	struct FURL LastURL;

	/** last server we connected to (for "reconnect" command) */
	UPROPERTY()
	struct FURL LastRemoteURL;

}
```

这里的`TravelURL`和`TravelType`就是负责设定下一个Level的**目标**和**转换过程**。

```c++
// Traveling from server to server.
UENUM()
enum ETravelType
{
	/** Absolute URL. */
	TRAVEL_Absolute,
	/** Partial (carry name, reset server). */
	TRAVEL_Partial,
	/** Relative URL. */
	TRAVEL_Relative,
	TRAVEL_MAX,
};

void UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )
{
	FWorldContext &Context = GetWorldContextFromWorldChecked(InWorld);
	// set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().
	Context.TravelURL    = NextURL;
	Context.TravelType   = InTravelType;
    [...]
}
```

粗略的流程是：UE在**OpenLevel**的时候， 先设置当前World的Context上的`TravelURL`，然后在`UEngine::TickWorldTravel`的时候判断TravelURL非空，来真正执行Level的切换。具体的Level切换详细流程比较复杂，目前先从大局上理解整体结构。总而言之，==WorldContext既负责World之间切换的上下文，也负责Level之间切换的操作信息。==

❓**思考：为何Level的切换信息不放在World里？**

- 因为UE有一个逻辑，一个World只有一个PersistentLevel（见上篇），而当我们OpenLevel一个PersistentLevel的时候，实际上引擎做的是先释放掉当前的World，然后再创建个新的World。所以如果我们把下一个Level的信息放在当前的World中，就不得不在释放当前World前又拷贝回来一遍了。
- 而`LoadStreamLevel`的时候，就只是在当前的World中载入对象了，所以其实就没有这个限制了。

```c++
void UGameplayStatics::LoadStreamLevel(UObject* WorldContextObject, FName LevelName,bool bMakeVisibleAfterLoad,bool bShouldBlockOnLoad,FLatentActionInfo LatentInfo)
{
	if (UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject))
	{
		FLatentActionManager& LatentManager = World->GetLatentActionManager();
		if (LatentManager.FindExistingAction<FStreamLevelAction>(LatentInfo.CallbackTarget, LatentInfo.UUID) == nullptr)
		{
			FStreamLevelAction* NewAction = new FStreamLevelAction(true, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo, World);
			LatentManager.AddNewAction(LatentInfo.CallbackTarget, LatentInfo.UUID, NewAction);
		}
	}
}
```

❓**思考：为何World和Level的切换要放在下一帧再执行？**

- 首先`Level`的加载显然是比较慢的，需要载入Map，相应的Mesh，Material……等等。所以这个操作就必须异步化，异步的话其实就剩下两种方式，一种是先记录下来信息之后再执行；一种是命令模式立马往队列里压个命令之后再执行。注意，因为`OpenLevel`还要相应在主线程生成相应**Actor对象**，所以有些部分还是要在主线程完成的。这两种模式其实都可以达成需求，前者更加简单明了，后者相对统一。UE也是个进化过来的引擎，也并不是所有的代码都完美无缺。猜想其实也是一开始这么简单就这么做了，后来也没有特别大的改动的动力就一直这样了。引擎最终比的是生产效率的提高，确实也不是代码有多优雅。



## GameInstance

那么这些WorldContexts又是保存在哪里的呢？追根溯源：

![image-20210527195134128](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195134128.png)

`GameInstance`里会保存着**当前的WorldConext**和**其他整个游戏的信息**。明白了==GameInstance是比World更高的层次==之后，我们也就能明白为何那些独立于Level的逻辑或数据要在`GameInstance`中存储了。

这一点其实也很好理解，大凡游戏引擎都会有一个`Game`的概念，不管是叫Application还是Director，它都是玩家能直接接触到的最根源的操作类。而UE的`GameInstance`因为继承于`UObject`，所以就**拥有了动态创建的能力**，所以我们可以通过指定`GameInstanceClass`来让UE使用我们**自定义的GameInstance子类**。所以不论是C++还是BP，==我们通常会继承于GameInstance，然后在里面编写应用于整个游戏范围的逻辑==:star:。

因为经常有初学者会问到：我的Level切换了，变量数据就丟了，我应该把那些数据放在哪？再清晰直白一点，==GameInstance就是你不管Level怎么切换，还是会一直存在的那个对象==！



## Engine

让我们继续再往上，终于得见UE大神：

![image-20210527195358337](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195358337.png)

此处`UEngine`分化出了两个子类：`UGameEngine`和`UEditorEngine`。众所周知，UE的编辑器也是UE用自己的引擎渲染出来的，采用的也是`Slate`那套UI框架。好处有很多，比如跨平台比较统一，UI框架可以复用一套控件库，Dogfood等等，此处不再细讲。所以**本质上来说，UE的编辑器其实也是个游戏**！我们是在编辑器这个游戏里面创造我们自己的另一个游戏。话虽如此，但比较编辑器和游戏还是有一定差别的，所以UE会在不同模式下根据编译环境而采用不同的具体Engine类，而在==基类UEngine==里通过一个`WorldList`保存了所有的`World`。

- `Standlone Game`：会使用UGameEngine来创建出唯一的一个GameWorld，因为也只有一个，所以为了方便起见，就直接保存了`GameInstance`指针。
- 而对于编辑器来说，EditorWorld其实只是用来预览，所以并不拥有OwningGameInstance，而PlayWorld里的`OwningGameInstance`才是间接保存了GameInstance.

目前来说，因为UE还不支持同时运行多个World（当前只能一个，但可以切换），所以`GameInstance`其实也是唯一的。提前说些题外话，虽然目前网络部分还没涉及到，但是当我们在Editor里进行MultiplePlayer的测试时，每一个Player Window里都是一个World。如果是DedicateServer模式，那DedicateServer也会是一个World。

最后实例化出来的`UEngine`实例用一个**全局的GEngine变量**来保存。至此，我们已经到了引擎的最根处:

```c++
//UnrealEngine\Engine\Source\Runtime\Engine\Private\UnrealEngine.cpp
ENGINE_API UEngine*	GEngine = NULL;
```

**GEngine可以说是一切开始的地方了**。翻看引擎源码，到处也可以看见从`GEngine->`出来的引用。



## GamePlayStatics

既然我们在引擎内部C++层次已经有了**访问World**、**操作Level**的能力，那么在暴露出的蓝图系统里，UE为了我们的使用方便，也在**Engine层次**为我们提供了便利操作蓝图函数库。

```c++
UCLASS ()
class UGameplayStatics : public UBlueprintFunctionLibrary 
```

我们在蓝图里见到的`GetPlayerController`、`SpawActor`和`OpenLevel`等都是来至于这个类的接口。这个类比较简单，相当于一个C++的静态类，只为蓝图暴露提供了一些静态方法。在想借鉴或者是查询某个功能的实现时，此处往往会是一个入口。

## 总结

从结构上而言，我们已经来到了最根源的地方。GEngine仿佛就是一棵大树的根，当我们拎起它的时候，也会带出整个游戏世界的各个对象。但目前这些对象：==Object->Actor + Component->Level->World->WorldContext->GameInstance->Engine==，确实已经足够表达UE游戏世界的各个部分。

那作为GamePlay部分而言，我们还有一个问题：UE是如何把在该对象结构上表达游戏逻辑的？
如果说：“程序 = 数据 + 算法”的话，那==UE的GamePlay我们已经讨论完了数据部分==，而下篇我们将开始讨论UE的**游戏逻辑“算法”部分**。



# GamePlay架构（四）Pawn

## Component

`Actor`可以说是由`Component`组成的，所以`Component`其实是我们对象树里最底层的员工了。在UE里，Component表达的是“功能”的概念。比如说你要实现一个可以响应的WASD移动的功能，或者是VR里抓取的功能，甚至是嵌套另一个Actor的功能，这些都是一个个组件。==正确理解“功能”和“游戏业务逻辑”的区分是理解Component的关键要点==。

==所以我们在这一个层级上要编写的逻辑，是实现一个个“与特定游戏无关”的功能==。理想情况下，等你的一个游戏完成，你那些已经实现完成的Components是可以无痛迁移到下一个游戏中用的。换言之，一旦你发现你在Component中含有游戏的业务逻辑代码，这就是所谓的“Bad Smell”了，要警惕游戏架构是否恰当，是否没有很清晰的概念划分。

## Actor

如果说UE是一个大国家的话，那Actor无疑就是人口最大的民族了。StaticMeshActor，CameraActor……我们天天口里嚷嚷的也都是它。和Unity的`Prefab`对应的，在UE里我们用的最多的也是`BlueprintActor`了，我们也常常自定义我们的Actor子类来组装其他Component和Actor，然后再编写一些协作逻辑代码，就似乎完成了一个骁勇善战的特种兵，接下来就可以撒豆成兵般的往Level中扔了。

用的越广泛越多，往往错的也越多。似乎是受到了一种朴素的子承父业的精神感染，也或许是我们的面向对象编程都学得太好的缘故，我们都非常倾向于直接在Actor里堆砌逻辑。右键一个BlueprintActor，刚添加完Component，就立马撸起袖子来，Event、Function和Variable一个个罗列开来，噼里啪啦无不快活！但是且慢，这是最好的方式了吗？让我们一路带着这个问题，试着从UE角度去推演一下，重走一下Actor进化之路。在本章节旅程的终点，我保证，我们可以比较清楚的回答这个问题。

其实所有的游戏引擎在构建完节点树之后，都会面临这么一个问题，**我的游戏逻辑写在哪里？** 有的原始的如**Cocos2dx懒得想那么多，干脆就直接码在Node里面得了，所以你翻看Cocos2dx的源码你就会经常发现它的逻辑和表现往往是交杂在一起的，简单直接暴力美学，面向对象继承玩得溜**。

而**面向组合阵营的领军Unity则干脆就把Component思想再应用极致一点，我的逻辑为什么不能也是一个组件**？所以Unity里的ScriptComponent也是这种组合思想的体现，模型统一架构优雅，MonoBehavior立大功了！但是在一个Component（ScriptComponent）里去操作管理其他的Components，本身却其实并不是那么优雅，因为有些Component之上的协调管理的事务，从层次上来说，应该放在更高的一个概念上实现。

UE在思考这个问题时，却是感觉有些理想主义，颇有些C++的理念，力求不为你不需要的东西付代价，宁愿有时候折衷，也想保住最优性能。UE的架构中也大量应用了各种继承，有些继承链也能拉得很长，同时一方面也吸纳了组合的优点，我们也能见到UE的源码中类的成员变量也是组合了好多其他对象。所以接下来的该介绍的就是==UE综合应用这两种思想的设计产物==。**面向对象派生下来的Pawn和Character**，**支持组合的Controller**。

## Pawn

那么第二个至关重要的的问题是，**哪些Actor需要附加逻辑？**

在游戏中，我们之所以会觉得一个角色生动，是因为它会响应我们的交互，并给出恰当的反应。而我们所谓的**游戏业务逻辑，实际上编写的就是该如何对玩家的输入提供反馈**。同样，一个Actor想要变得“生动”，就得有响应外部输入的能力，否则就只是自动运转麻木的机器人。但是在一个比较大型的3D游戏中，Actor有千千万万，然后并不是所有的Actor都需要和玩家互动，能直接面圣和玩家互动的Actor也是比较少的。

我们经常都只是操作我们的“角色”，让“角色”和场景里的其他物体互动。比如FPS游戏里我们操作的主角或者是FlappyBird里的那只小鸟。所以从这一点上来看，UE中Actor就立马又可以划分出一个类别了，这些Actor们可谓是玩家们的宠儿，它们是玩家们的亲卫兵，对，它的名字就是==Pawn==!

<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201143143.png" alt="image-20210527201143143" style="zoom:67%;" />

同其他AInfo一样，UE也是从Actor中再派生出了APawn，并定义了3块基本的模板方法接口：

1. 可被`Controller`控制
2. `PhysicsCollision`表示
3. `MovementInput`的基本响应接口

==Pawn就是那些可以被玩家（你或AI）控制的Actor==！再考察到UE是做FPS游戏起家的，所以你可以想象这个Pawn就相当于战场里最基本的士兵的表示。一个士兵在战场中首先需要表达自身的存在（`PhysicsCollision`），可以移动（`MovementInput`），然后可以响应输入和处理逻辑（`Controller`）。

你也可以想象成**提线木偶**，那个==木偶就是Pawn==，而==提线的是Controller==。Pawn表达的最关键点是可被玩家操纵的能力。因为UE从FPS进化过来的关系，所以附带的物理表示和移动也一并加了进去，应该也是为了方便的缘故。

❓**思考：为何Actor也能接受Input事件？**

- 我上述的对`Pawn`的描述可能会让你觉得，似乎Pawn既然就是用来被玩家控制的，那么理所当然的我们应该在Pawn上同时实现对输入的接受。但我们会发现实际上`EnableInput`接口却是在`Actor`上的，同时`InputComponent`也是在`Actor`里面的，意味着实际上你也可以在Actor上绑定处理输入事件。官方的输入事件处理流程图也是表明了这一点：

<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201544265.png" alt="image-20210527201544265" style="zoom:67%;" />

- 首先应该不难理解**输入的处理功能**可以实现化出`InputComponent`，而“输入”的种类也有很多，我们也不能确定和分类哪些Actor的子类该接受哪些种类的输入事件；同时又因为`Actor`也是由**Component组件化**组装而成的，UE不可能为了输入的处理就改变`Component`的组织方式，所以还不如泛泛的在`Actor`的基类里提供`InputComponent`的集成，这样反而保证了灵活性。
- 理解这个问题的要点在于正确区分“输入响应”和“逻辑控制”。比如说WASD移动，Actor拥有最基本的输入响应，它可以响应WASD的按键事件。但是按键了之后呢？该如何移动？**Pawn就定义了一个基本的MovementInput套路**，相当于把WASD的输入响应再往前包装处理了一步。**而“逻辑控制”指的是更高层上的比如寻路或自动巡逻等行为**。
- 作为`GamePlay`中至关重要的一个逻辑概念，让我再罗嗦强调一遍应该不为过吧。==Pawn实现的是“可被控制”的概念==。因为“被控制了”之后经常要被移动（UE对FPS是真爱啊），所以Pawn就索性把移动的接口也定义了一下（当然，为了灵活性，内部转交给`MovementComponent`再处理），既然能移动了，但也不能随便在地图里乱走吧，所以碰撞（物理表示）看来也是需要的啊，好吧，那就加上，齐活了。



## DefaultPawn，SpectatorPawn，Character

![image-20210527201808498](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201808498.png)

### DefaultPawn

因为我们每次想自己搞Pawn都得从Pawn派生过来，然后再一个个添加组件。UE知道我们大家都很懒，所以提供了一个默认的Pawn：DefaultPawn，默认带了一个`DefaultPawnMovementComponent`、`spherical CollisionComponent`和`StaticMeshComponent`。也是上述Pawn阐述过的**三件套**，只不过都是默认套餐。

### SpectatorPawn

UE的FPS做的太好了，就会有一些观众想要观战。观战的玩家们虽然也在当前地图里，但是我们并不需要真正的去表示它们，只要给他们一些摄像机“漫游”的能力。所以==派生于DefaultPawn的SpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。==

### Character

因为我们是人，所以在游戏中，代入的角色大部分也都是人。大部分游戏中都会有用到人形的角色，既然如此，UE就为我们直接提供了一个==人形的Pawn==来让我们操纵。

像人一样行走的`CharacterMovementComponent`， 尽量贴合的`CapsuleComponent`，再加上骨骼上蒙皮的网格。**同样的三件套，不一样的配方**。

有些人一开始的时候会困惑应该选择Pawn还是Character，其实从继承体系中就可以了解到**Character只不过是Pawn的加强特化版本**。一般来说，如果你控制的角色是人形的带骨骼的，那就选择Character吧。而如果是VR中的一双手（假设只有一双手），因为移动模式和显示都算不太上人形，顶多只能算是个漂浮的“幽灵”，所以还是用Pawn方便些。后期如果你想加上人形模型和IK了，那么再把Mesh替换成SkeletalMesh也就行了。Pawn因为是基础款，所以提供了最大的灵活性。



# GamePlay架构（五）Controller

