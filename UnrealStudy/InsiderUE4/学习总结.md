# GamePlay架构（一）Actor和Component

## UObject

UE创世，万物皆UObject，接着有Actor。藉着UObject提供的元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等，UE可以构建一个Object运行的世界。

<img src="学习总结.assets\image-20210525175503021-1621936563697.png" alt="image-20210525175503021" style="zoom:67%;" />

## Actor

<img src="学习总结.assets\image-20210525175557946.png" alt="image-20210525175557946" style="zoom:50%;" />

脱胎自`Object`的`Actor`也多了一些本事：Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)。

❓**思考：为何Actor不像GameObject一样自带Transform？**

- 因为UE跟贴近C++一些的缘故，所以设计哲学上就更偏向于C++的哲学：==不为你不需要的东西付代价==。一个Transform再加上附带的逆矩阵之类的表示，内存占用上其实也是挺可观的。

- 经过了UE的权衡和考虑，把Transform封装进了`SceneComponent`，当作`RootComponent`。

  

## Component

`UActorComponent`也是派生于UObject的一个子类，这意味着其实Component也是有UObject的那些通用功能的。

`TSet<UActorComponent*> OwnedComponents` 保存着这个Actor所拥有的所有Component，一般其中会有一个`SceneComponent`作为RootComponent。`TArray<UActorComponent*> InstanceComponents` 保存着**实例化的Components**。实例化是个什么意思呢，就是你在蓝图里Details定义的Component，当这个Actor被实例化的时候，这些附属的Component也会被实例化。

一个Actor若想可以被放进Level（关卡）里，就必须实例化`USceneComponent* RootComponent`。

<img src="学习总结.assets\image-20210525175923625.png" alt="image-20210525175923625" style="zoom:67%;" />

ActorComponent下面**最重要的一个Component就非SceneComponent莫属了**。SceneComponent提供了**两大能力**：

- 一是Transform
- 二是SceneComponent的互相嵌套。

❓**思考：为何ActorComponent不能互相嵌套？而在SceneComponent一级才提供嵌套？**

- ActorComponent下面当然不是只有SceneComponent，一些UMovementComponent，AIComponent，或者是我们自己写的Component，都是会直接继承ActorComponent的。但很奇怪的是，ActorComponent却是不能嵌套的，在UE的观念里，好像只有带Transform的SceneComponent才有资格被嵌套，好像Component的互相嵌套必须和3D里的transform父子对应起来。
- 从功能上来说，UE更倾向于编写功能单一的Component（如UMovementComponent），而不是一个整合了其他Component的大管家Component（当然如果你偏要这么干，那UE也阻止不了你）。

**❓思考：Actor的SceneComponent哲学**

​	//toCopy

❓**思考：Actor之间的父子关系是怎么确定的？**

- 你应该已经注意到了Actor里面的`TArray<AActor*> Children`字段，所以你可能会期望看到Actor:AddChild之类的方法，很遗憾。在UE里，==Actor之间的父子关系却是通过Component确定的==。同一般的Parent:AddChild操作原语不同，UE里是通过**Child:AttachToActor**或**Child:AttachToComponent**来创建父子连接的。

  ```c++
  void AActor::AttachToActor(AActor* ParentActor, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && ParentActor)
      {
          USceneComponent* ParentDefaultAttachComponent = ParentActor->GetDefaultAttachComponent();
          if (ParentDefaultAttachComponent)
          {
              RootComponent->AttachToComponent(ParentDefaultAttachComponent, AttachmentRules, SocketName);
          }
      }
  }
  void AActor::AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules& AttachmentRules, FName SocketName)
  {
      if (RootComponent && Parent)
      {
          RootComponent->AttachToComponent(Parent, AttachmentRules, SocketName);
      }
  }
  ```

- Actor父子之间的“关系”隐含了许多数据，而这些数据都是在Component上提供的。==Actor其实更像是一个容器，只提供了基本的创建销毁，网络复制，事件触发等一些逻辑性的功能==，而把父子的关系维护都交给了具体的Component，**所以更准确的说，其实是不同Actor的SceneComponent之间有父子关系，而Actor本身其实并不太关心。**

📚**聊一聊ChildActorComponent**

![image-20210525181105823](学习总结.assets\image-20210525181105823.png)

同作为最常用到的Component之一，`ChildActorComponent`担负着**Actor之间互相组合的胶水**。这货在**蓝图里静态存在的时候**其实并不真正的创建Actor，而是在之后**Component实例化**的时候才真正创建。

```c++
void UChildActorComponent::OnRegister()
{
    Super::OnRegister();
    if (ChildActor)
    {
        if (ChildActor->GetClass() != ChildActorClass)
        {
            DestroyChildActor();
            CreateChildActor();
        }
        else
        {
            ChildActorName = ChildActor->GetFName();
            USceneComponent* ChildRoot = ChildActor->GetRootComponent();
            if (ChildRoot && ChildRoot->GetAttachParent() != this)
            {
                // attach new actor to this component
                // we can't attach in CreateChildActor since it has intermediate Mobility set up
                // causing spam with inconsistent mobility set up
                // so moving Attach to happen in Register
                ChildRoot->AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
            }
            // Ensure the components replication is correctly initialized
            SetIsReplicated(ChildActor->GetIsReplicated());
        }
    }
    else if (ChildActorClass)
    {
        CreateChildActor();
    }
}
void UChildActorComponent::OnComponentCreated()
{
    Super::OnComponentCreated();
    CreateChildActor();
}
```

这就导致了一个问题，当你把一个ActorClass拖进Level后，这个Actor实际是已经实例化了,你可以直接调整这个Actor的属性。但是你把它拖到另一个Actor Class里，它只会给你空空白白的ChildActorComponent的DetailsPanel，你想调整Actor的属性，就只能等生成了之后，用蓝图或代码去修改。这一点来说，其实还是挺不方便的，我个人觉得应该是还有优化的空间。

> UE终于听到了人民群众的呼声，在4.14里增加了Child Actor Templates来支持在子ChildActor的DetailsPannel里查看和修改属性。



# GamePlay架构（二）Level和World

> 由一个或多个Level组成一个World。

## Level

在UE的世界中，我们之前已经有了空气（C++）,土壤（UObject），物件（Actor）。而现在UE又施展神力创建了一片片大陆（Level），在这片大陆上（.map文件），Actor们秩序井然，各种地形拔地而起，植被繁茂，天空雾云缭绕，圣光普照，这也是玩家们降生开始精彩冒险的地方。

![image-20210525181811179](学习总结.assets\image-20210525181811179.png)

可以从ULevel的前缀U看出来**Level（大陆）也确实是继承于UObject（土壤）**的。那既然同属于Object下面的各Actor们都拥有了一定的智能能力（支持蓝图脚本），Level自然也得体现出大地的意志，所以**默认带了一个土地公（ALevelScriptActor）**，允许我们在关卡里编写脚本，可以对本关卡里的所有Actor通过名字呼之则来，**关卡蓝图实际上就代表着该片大陆上的运行规则**。

在Level已经有了管理者之后，一开始大家都挺满意，但渐渐的就发现，**好像各个Level需要的功能好像都差不多**，都是修改一下光照，物理等一些属性。所以为了方便起见，**UE便给每一个Level也都默认配了一个书记官（Info）**，他一一记录着本Level的各种规则属性，在UE需要的时候便负责相告。更重要的是，在Level需要有其他管理人员一起协助的时候，他也记录着`GameMode`的名字来让UE可以指派。

前面我们说过，有一些Actor是不“显示”的（**没有SceneComponent**），是不能“摆放”到Level里的，但是它依然可以在关卡里出力。其中一个家族系列就是`AInfo`和其子类。今天我们只简单介绍一下跟Level直接相关的一位书记官：==AWorldSettings==。

![image-20210525182200300](学习总结.assets\image-20210525182200300.png)

> 虽然名字叫做WorldSettings，但其实只是跟Level相关

❓**思考：为何AWorldSettings要放进在Actors[0]的位置？而ALevelScriptActor却不用？**

```c++
void ULevel::SortActorList()
{
    //[...]
    TArray<AActor*> NewActors;
    TArray<AActor*> NewNetActors;
    NewActors.Reserve(Actors.Num());
    NewNetActors.Reserve(Actors.Num());
    // The WorldSettings tries to stay at index 0
    NewActors.Add(WorldSettings);
    // Add non-net actors to the NewActors immediately, cache off the net actors to Append after
    for (AActor* Actor : Actors)
    {
        if (Actor != nullptr && Actor != WorldSettings && !Actor->IsPendingKill())
        {
            if (IsNetActor(Actor))
            {
                NewNetActors.Add(Actor);
            }
            else
            {
                NewActors.Add(Actor);
            }
        }
    }
    iFirstNetRelevantActor = NewActors.Num();
    NewActors.Append(MoveTemp(NewNetActors));
    Actors = MoveTemp(NewActors);   // Replace with sorted list.
    // Add all network actors to the owning world
    //[...]
}
```

- 实际上通过这一段代码可知，**Actors们的排序依据**是把那些**“非网络”的Actor放在前面**，而把**“网络可复制”的Actor们放在后面**，然后加一个起始索引标记`iFirstNetRelevantActor`，相当于为网络Actor划分了一个缓存，从而加速了网络复制时的检测速度。`AWorldSettings`因为都是静态的数据提供者，在游戏运行过程中也不会改变，不需要网络复制，所以也就可以一直放在前列，而如果再加个规则，一直放在第一个的话，也能同时把AWorldSettings和其他的前列Actor们再度区分开，在需要的时候也能加速判断。**ALevelScriptActor因为是代表关卡蓝图，是允许携带“复制”变量函数的，所以也有可能被排序到后列**。

**❓思考：既然ALevelScriptActor也继承于AActor,为何关卡蓝图不设计能添加Component？**

- 平常我们在创建Actor的时候，我们蓝图界面是可以创建Component的。那为什么在关卡蓝图里，却不能这么做（没有提供该界面功能）？虽然在图里标出了Level中拥有**ModelComponents**，但那其实只是**针对BSP应用的一个子集**。通过源码发现，其实UE自己也是在C++里往`ALevelScriptActor`添加**UInputComponent**来**实现关卡蓝图可以响应事件**。

- 其实既然ALevelScriptActor是个Actor，那意味着我们当然可以为它添加组件，实际上也确实可以这么做。比如你可以在关卡蓝图里这么干：

  <img src="学习总结.assets\image-20210525182911023.png" alt="image-20210525182911023" style="zoom:67%;" />

❓那么好好想想，为啥`UE`要给你这么一个**关卡蓝图界面**呢？

- 在此，我也只能进行一番猜测，`ALevelScriptActor`作为一个特化的Actor，却把Components列表界面给隐藏了，说明UE其实是不希望我们去复杂化关卡构成的。
- 假设说UE开放了关卡Component，那么我们在创建组件时就必然要考虑一个问题：哪些是ActorComponent，哪些是LevelComponent，再怎么ALevelScriptActor本质是个Actor，但Level的概念还是要突出，ALevelScriptActor的Actor本质是要隐藏的。所以用户就会多一些心智负担，可能混淆。而如果像这样不开放，大家的思路就都转向先创建个Actor，然后再往之上添加component，思路会比较统一清晰。
- 再之，从游戏逻辑的组织上来说，Level其实更应该表现为一个Actor的容器。UE其实也是不鼓励在Level里编写太复杂的逻辑的。所以才接着会有了之后的GameMode,Controller那些真正的逻辑控制类（后续会再细讨论）。



## World

终于，到了把大陆们（Level）拼装起来的时候了。可以用==SubLevel==的方式：

<img src="学习总结.assets\image-20210525183442256.png" alt="image-20210525183442256" style="zoom:80%;" />

也支持`WorldComposition`的方式自动把项目里的所有Level都组合起来，并设置摆放位置：

<img src="学习总结.assets\image-20210525183500177.png" alt="image-20210525183500177" style="zoom:80%;" />

简单本质来说，就是==一个World里有多个Level==，这些Level在什么位置，是在一开始就加载进来，还是Streaming运行时加载。**UE里每个World支持一个PersistentLevel和多个其他Level**：

![image-20210525183602080](学习总结.assets\image-20210525183602080.png)

**Persistent的意思是一开始就加载进World**，**Streaming是后续动态加载的意思**。Levels里保存有所有的、当前已经加载的Level，`StreamingLevels`保存整个World的**Levels配置列表**。PersistentLevel和CurrentLevel只是个快速引用。在编辑器里编辑的时候，CurrentLevel可以指向其他Level，但**运行时CurrentLevel只能是指向PersistentLevel**。

❓**思考：为何要有主PersistentLevel？**

- 首先，World至少得有一个Level，就像你也得先出生在一块大陆上才可以继续谈起去探索别的新大陆。所以这块玩家出生的大陆就是主Level了。当然了，因为我们也可以同时配置别的Level一开始就加载进来，其实跟PersistentLevel是差不多等价的，但再考虑到另一问题：Levels拼接进World一起之后，各自有各自的worldsetting，那整个World的配置应该以谁的为主？
- ==World的Settings也是以PersistentLevel为主的==，但这也并不以为着其他Level的Settings就完全没有作用了，本篇也无法一一列出所有配置选项来说明，简单来说，就是**需要在整个世界范围内起作用的配置选项（比如VR的WorldToMeters，KillZ，WorldGravity其他大部分都是）就是需要从主PersistentLevel的配置中提取**。而一些配置选项可以在单独Level中起作用的，比如在编辑Level时的**光照质量配置就是一个个Level单独的**，目前这种配置很少，但可能以后也会增加。

**❓思考：Levels们的Actors和World有直接关系吗？**

- 当别的Level被添加进当前World之后，我们能直接在WorldOutliner里看到其他Level的Actor们。

![image-20210525184037168](学习总结.assets\image-20210525184037168.png)

- 但这并不代表着World直接引用了Level里的Actor们。TActorIteratorBase（World的Actor迭代器）内部的实现也只是在遍历Levels来获得所有Actor。当然World为了更快速的操作Controllers和Pawn也都保存了引用。但**Levels却共享着World的一个PhysicsScene**，这也https://learn.unrealengine.com/course/3536489?r=False&ts=637454196686960980意味着**Levels里的Actors的物理实体其实都是在World里的**，这也好理解，毕竟物理的碰撞之类的当然要是全局的了。再说到导航，**World在拼接Level的时候，也是会同时把两个Level的导航网格给“拼接”起来的**。当然目前还不是深入细节的时候，现在只要从大局上明白World-Level-Actor的关系。

## 总结

==Level作为Actor的容器，同时也划分了World==，一方面支持了Level的动态加载，另一方面也允许了团队的实时协作，大家可以同时并行编辑不同的Level。一般而言，一个玩家从游戏开始到结束，UE会创造一个GameWorld给玩家并一直存在。**玩家切换场景或关卡，也只是在这个World中加载释放不同的Level**。既然Level拥有了管理者（LevelScriptActor），玩家可以编写特定关卡的逻辑，那么我们能否对World这种层次编写逻辑呢？答案是肯定的，不过本文篇幅有限，敬请期待下篇。



# GamePlay架构（三）WorldContext，GameInstance，Engine

## WorldContext

**一个游戏里是只有一个World吗**？==答案是否定的==，首先`World`就不是只有一种类型，比如**编辑器**本身就也是一个World，里面显示的**游戏场景也是一个World**，这两个World互相协作构成了我们的编辑体验。然后点播放的时候，引擎又可以生成新的类型World来让我们测试。简单来说，UE其实是一个平行宇宙世界观。
以下是一些世界类型：

```c#
namespace EWorldType
{
	enum Type
	{
		None,		// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels
		Game,		// The game world
		Editor,		// A world being edited in the editor
		PIE,		// A Play In Editor world
		Preview,	// A preview world for an editor tool
		Inactive	// An editor world that was loaded but not currently being edited in the level editor
	};
}
```

而UE用来管理和跟踪这些`World`的工具就是==WorldContext==：

<<<<<<< HEAD
![image-20210527194057422](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527194057422.png)
=======
![image-20210527194057422](学习总结.assets\image-20210527194057422.png)
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

`FWorldContext`保存着`ThisCurrentWorld`来指向**当前的World**。而当需要从一个World切换到另一个World的时候（比如说当点击播放时，就是从Preview切换到PIE），FWorldContext就用来保存**切换过程信息**和**目标World上下文信息**。所以一般在切换的时候，比如OpenLevel，也都会需要传`FWorldContext`的参数。对于独立运行的游戏，WorldContext只有唯一个。**而对于编辑器模式，则是一个WorldContext给编辑器，一个WorldContext给PIE（Play In Editor）的World**。一般来说我们不需要直接操作到这个类，引擎内部已经处理好各种World的协作。不仅如此，**FWorldContext还保存着World里Level切换的上下文**：

```c#
struct FWorldContext
{
    [...]
	TEnumAsByte<EWorldType::Type>	WorldType;

	FSeamlessTravelHandler SeamlessTravelHandler;

	FName ContextHandle;

	/** URL to travel to for pending client connect */
	FString TravelURL;

	/** TravelType for pending client connects */
	uint8 TravelType;

	/** URL the last time we traveled */
	UPROPERTY()
	struct FURL LastURL;

	/** last server we connected to (for "reconnect" command) */
	UPROPERTY()
	struct FURL LastRemoteURL;

}
```

这里的`TravelURL`和`TravelType`就是负责设定下一个Level的**目标**和**转换过程**。

```c++
// Traveling from server to server.
UENUM()
enum ETravelType
{
	/** Absolute URL. */
	TRAVEL_Absolute,
	/** Partial (carry name, reset server). */
	TRAVEL_Partial,
	/** Relative URL. */
	TRAVEL_Relative,
	TRAVEL_MAX,
};

void UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )
{
	FWorldContext &Context = GetWorldContextFromWorldChecked(InWorld);
	// set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().
	Context.TravelURL    = NextURL;
	Context.TravelType   = InTravelType;
    [...]
}
```

粗略的流程是：UE在**OpenLevel**的时候， 先设置当前World的Context上的`TravelURL`，然后在`UEngine::TickWorldTravel`的时候判断TravelURL非空，来真正执行Level的切换。具体的Level切换详细流程比较复杂，目前先从大局上理解整体结构。总而言之，==WorldContext既负责World之间切换的上下文，也负责Level之间切换的操作信息。==

❓**思考：为何Level的切换信息不放在World里？**

- 因为UE有一个逻辑，一个World只有一个PersistentLevel（见上篇），而当我们OpenLevel一个PersistentLevel的时候，实际上引擎做的是先释放掉当前的World，然后再创建个新的World。所以如果我们把下一个Level的信息放在当前的World中，就不得不在释放当前World前又拷贝回来一遍了。
- 而`LoadStreamLevel`的时候，就只是在当前的World中载入对象了，所以其实就没有这个限制了。

```c++
void UGameplayStatics::LoadStreamLevel(UObject* WorldContextObject, FName LevelName,bool bMakeVisibleAfterLoad,bool bShouldBlockOnLoad,FLatentActionInfo LatentInfo)
{
	if (UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject))
	{
		FLatentActionManager& LatentManager = World->GetLatentActionManager();
		if (LatentManager.FindExistingAction<FStreamLevelAction>(LatentInfo.CallbackTarget, LatentInfo.UUID) == nullptr)
		{
			FStreamLevelAction* NewAction = new FStreamLevelAction(true, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo, World);
			LatentManager.AddNewAction(LatentInfo.CallbackTarget, LatentInfo.UUID, NewAction);
		}
	}
}
```

❓**思考：为何World和Level的切换要放在下一帧再执行？**

- 首先`Level`的加载显然是比较慢的，需要载入Map，相应的Mesh，Material……等等。所以这个操作就必须异步化，异步的话其实就剩下两种方式，一种是先记录下来信息之后再执行；一种是命令模式立马往队列里压个命令之后再执行。注意，因为`OpenLevel`还要相应在主线程生成相应**Actor对象**，所以有些部分还是要在主线程完成的。这两种模式其实都可以达成需求，前者更加简单明了，后者相对统一。UE也是个进化过来的引擎，也并不是所有的代码都完美无缺。猜想其实也是一开始这么简单就这么做了，后来也没有特别大的改动的动力就一直这样了。引擎最终比的是生产效率的提高，确实也不是代码有多优雅。



## GameInstance

那么这些WorldContexts又是保存在哪里的呢？追根溯源：

<<<<<<< HEAD
![image-20210527195134128](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195134128.png)
=======
![image-20210527195134128](学习总结.assets\image-20210527195134128.png)
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

`GameInstance`里会保存着**当前的WorldConext**和**其他整个游戏的信息**。明白了==GameInstance是比World更高的层次==之后，我们也就能明白为何那些独立于Level的逻辑或数据要在`GameInstance`中存储了。

这一点其实也很好理解，大凡游戏引擎都会有一个`Game`的概念，不管是叫Application还是Director，它都是玩家能直接接触到的最根源的操作类。而UE的`GameInstance`因为继承于`UObject`，所以就**拥有了动态创建的能力**，所以我们可以通过指定`GameInstanceClass`来让UE使用我们**自定义的GameInstance子类**。所以不论是C++还是BP，==我们通常会继承于GameInstance，然后在里面编写应用于整个游戏范围的逻辑==:star:。

因为经常有初学者会问到：我的Level切换了，变量数据就丟了，我应该把那些数据放在哪？再清晰直白一点，==GameInstance就是你不管Level怎么切换，还是会一直存在的那个对象==！



## Engine

让我们继续再往上，终于得见UE大神：

<<<<<<< HEAD
![image-20210527195358337](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527195358337.png)
=======
![image-20210527195358337](学习总结.assets\image-20210527195358337.png)
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

此处`UEngine`分化出了两个子类：`UGameEngine`和`UEditorEngine`。众所周知，UE的编辑器也是UE用自己的引擎渲染出来的，采用的也是`Slate`那套UI框架。好处有很多，比如跨平台比较统一，UI框架可以复用一套控件库，Dogfood等等，此处不再细讲。所以**本质上来说，UE的编辑器其实也是个游戏**！我们是在编辑器这个游戏里面创造我们自己的另一个游戏。话虽如此，但比较编辑器和游戏还是有一定差别的，所以UE会在不同模式下根据编译环境而采用不同的具体Engine类，而在==基类UEngine==里通过一个`WorldList`保存了所有的`World`。

- `Standlone Game`：会使用UGameEngine来创建出唯一的一个GameWorld，因为也只有一个，所以为了方便起见，就直接保存了`GameInstance`指针。
- 而对于编辑器来说，EditorWorld其实只是用来预览，所以并不拥有OwningGameInstance，而PlayWorld里的`OwningGameInstance`才是间接保存了GameInstance.

目前来说，因为UE还不支持同时运行多个World（当前只能一个，但可以切换），所以`GameInstance`其实也是唯一的。提前说些题外话，虽然目前网络部分还没涉及到，但是当我们在Editor里进行MultiplePlayer的测试时，每一个Player Window里都是一个World。如果是DedicateServer模式，那DedicateServer也会是一个World。

最后实例化出来的`UEngine`实例用一个**全局的GEngine变量**来保存。至此，我们已经到了引擎的最根处:

```c++
//UnrealEngine\Engine\Source\Runtime\Engine\Private\UnrealEngine.cpp
ENGINE_API UEngine*	GEngine = NULL;
```

**GEngine可以说是一切开始的地方了**。翻看引擎源码，到处也可以看见从`GEngine->`出来的引用。



## GamePlayStatics

既然我们在引擎内部C++层次已经有了**访问World**、**操作Level**的能力，那么在暴露出的蓝图系统里，UE为了我们的使用方便，也在**Engine层次**为我们提供了便利操作蓝图函数库。

```c++
<<<<<<< HEAD
UCLASS ()
class UGameplayStatics : public UBlueprintFunctionLibrary 
=======
UCLASS ()class UGameplayStatics : public UBlueprintFunctionLibrary 
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6
```

我们在蓝图里见到的`GetPlayerController`、`SpawActor`和`OpenLevel`等都是来至于这个类的接口。这个类比较简单，相当于一个C++的静态类，只为蓝图暴露提供了一些静态方法。在想借鉴或者是查询某个功能的实现时，此处往往会是一个入口。

## 总结

从结构上而言，我们已经来到了最根源的地方。GEngine仿佛就是一棵大树的根，当我们拎起它的时候，也会带出整个游戏世界的各个对象。但目前这些对象：==Object->Actor + Component->Level->World->WorldContext->GameInstance->Engine==，确实已经足够表达UE游戏世界的各个部分。

那作为GamePlay部分而言，我们还有一个问题：UE是如何把在该对象结构上表达游戏逻辑的？
如果说：“程序 = 数据 + 算法”的话，那==UE的GamePlay我们已经讨论完了数据部分==，而下篇我们将开始讨论UE的**游戏逻辑“算法”部分**。



# GamePlay架构（四）Pawn

## Component

`Actor`可以说是由`Component`组成的，所以`Component`其实是我们对象树里最底层的员工了。在UE里，Component表达的是“功能”的概念。比如说你要实现一个可以响应的WASD移动的功能，或者是VR里抓取的功能，甚至是嵌套另一个Actor的功能，这些都是一个个组件。==正确理解“功能”和“游戏业务逻辑”的区分是理解Component的关键要点==。

==所以我们在这一个层级上要编写的逻辑，是实现一个个“与特定游戏无关”的功能==。理想情况下，等你的一个游戏完成，你那些已经实现完成的Components是可以无痛迁移到下一个游戏中用的。换言之，一旦你发现你在Component中含有游戏的业务逻辑代码，这就是所谓的“Bad Smell”了，要警惕游戏架构是否恰当，是否没有很清晰的概念划分。

## Actor

如果说UE是一个大国家的话，那Actor无疑就是人口最大的民族了。StaticMeshActor，CameraActor……我们天天口里嚷嚷的也都是它。和Unity的`Prefab`对应的，在UE里我们用的最多的也是`BlueprintActor`了，我们也常常自定义我们的Actor子类来组装其他Component和Actor，然后再编写一些协作逻辑代码，就似乎完成了一个骁勇善战的特种兵，接下来就可以撒豆成兵般的往Level中扔了。

用的越广泛越多，往往错的也越多。似乎是受到了一种朴素的子承父业的精神感染，也或许是我们的面向对象编程都学得太好的缘故，我们都非常倾向于直接在Actor里堆砌逻辑。右键一个BlueprintActor，刚添加完Component，就立马撸起袖子来，Event、Function和Variable一个个罗列开来，噼里啪啦无不快活！但是且慢，这是最好的方式了吗？让我们一路带着这个问题，试着从UE角度去推演一下，重走一下Actor进化之路。在本章节旅程的终点，我保证，我们可以比较清楚的回答这个问题。

其实所有的游戏引擎在构建完节点树之后，都会面临这么一个问题，**我的游戏逻辑写在哪里？** 有的原始的如**Cocos2dx懒得想那么多，干脆就直接码在Node里面得了，所以你翻看Cocos2dx的源码你就会经常发现它的逻辑和表现往往是交杂在一起的，简单直接暴力美学，面向对象继承玩得溜**。

而**面向组合阵营的领军Unity则干脆就把Component思想再应用极致一点，我的逻辑为什么不能也是一个组件**？所以Unity里的ScriptComponent也是这种组合思想的体现，模型统一架构优雅，MonoBehavior立大功了！但是在一个Component（ScriptComponent）里去操作管理其他的Components，本身却其实并不是那么优雅，因为有些Component之上的协调管理的事务，从层次上来说，应该放在更高的一个概念上实现。

UE在思考这个问题时，却是感觉有些理想主义，颇有些C++的理念，力求不为你不需要的东西付代价，宁愿有时候折衷，也想保住最优性能。UE的架构中也大量应用了各种继承，有些继承链也能拉得很长，同时一方面也吸纳了组合的优点，我们也能见到UE的源码中类的成员变量也是组合了好多其他对象。所以接下来的该介绍的就是==UE综合应用这两种思想的设计产物==。**面向对象派生下来的Pawn和Character**，**支持组合的Controller**。

## Pawn

那么第二个至关重要的的问题是，**哪些Actor需要附加逻辑？**

在游戏中，我们之所以会觉得一个角色生动，是因为它会响应我们的交互，并给出恰当的反应。而我们所谓的**游戏业务逻辑，实际上编写的就是该如何对玩家的输入提供反馈**。同样，一个Actor想要变得“生动”，就得有响应外部输入的能力，否则就只是自动运转麻木的机器人。但是在一个比较大型的3D游戏中，Actor有千千万万，然后并不是所有的Actor都需要和玩家互动，能直接面圣和玩家互动的Actor也是比较少的。

我们经常都只是操作我们的“角色”，让“角色”和场景里的其他物体互动。比如FPS游戏里我们操作的主角或者是FlappyBird里的那只小鸟。所以从这一点上来看，UE中Actor就立马又可以划分出一个类别了，这些Actor们可谓是玩家们的宠儿，它们是玩家们的亲卫兵，对，它的名字就是==Pawn==!

<<<<<<< HEAD
<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201143143.png" alt="image-20210527201143143" style="zoom:67%;" />
=======
<img src="学习总结.assets\image-20210527201143143.png" alt="image-20210527201143143" style="zoom:67%;" />
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

同其他AInfo一样，UE也是从Actor中再派生出了APawn，并定义了3块基本的模板方法接口：

1. 可被`Controller`控制
2. `PhysicsCollision`表示
3. `MovementInput`的基本响应接口

==Pawn就是那些可以被玩家（你或AI）控制的Actor==！再考察到UE是做FPS游戏起家的，所以你可以想象这个Pawn就相当于战场里最基本的士兵的表示。一个士兵在战场中首先需要表达自身的存在（`PhysicsCollision`），可以移动（`MovementInput`），然后可以响应输入和处理逻辑（`Controller`）。

你也可以想象成**提线木偶**，那个==木偶就是Pawn==，而==提线的是Controller==。Pawn表达的最关键点是可被玩家操纵的能力。因为UE从FPS进化过来的关系，所以附带的物理表示和移动也一并加了进去，应该也是为了方便的缘故。

❓**思考：为何Actor也能接受Input事件？**

- 我上述的对`Pawn`的描述可能会让你觉得，似乎Pawn既然就是用来被玩家控制的，那么理所当然的我们应该在Pawn上同时实现对输入的接受。但我们会发现实际上`EnableInput`接口却是在`Actor`上的，同时`InputComponent`也是在`Actor`里面的，意味着实际上你也可以在Actor上绑定处理输入事件。官方的输入事件处理流程图也是表明了这一点：

<<<<<<< HEAD
<img src="E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201544265.png" alt="image-20210527201544265" style="zoom:67%;" />
=======
<img src="学习总结.assets\image-20210527201544265.png" alt="image-20210527201544265" style="zoom:67%;" />
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

- 首先应该不难理解**输入的处理功能**可以实现化出`InputComponent`，而“输入”的种类也有很多，我们也不能确定和分类哪些Actor的子类该接受哪些种类的输入事件；同时又因为`Actor`也是由**Component组件化**组装而成的，UE不可能为了输入的处理就改变`Component`的组织方式，所以还不如泛泛的在`Actor`的基类里提供`InputComponent`的集成，这样反而保证了灵活性。
- 理解这个问题的要点在于正确区分“输入响应”和“逻辑控制”。比如说WASD移动，Actor拥有最基本的输入响应，它可以响应WASD的按键事件。但是按键了之后呢？该如何移动？**Pawn就定义了一个基本的MovementInput套路**，相当于把WASD的输入响应再往前包装处理了一步。**而“逻辑控制”指的是更高层上的比如寻路或自动巡逻等行为**。
- 作为`GamePlay`中至关重要的一个逻辑概念，让我再罗嗦强调一遍应该不为过吧。==Pawn实现的是“可被控制”的概念==。因为“被控制了”之后经常要被移动（UE对FPS是真爱啊），所以Pawn就索性把移动的接口也定义了一下（当然，为了灵活性，内部转交给`MovementComponent`再处理），既然能移动了，但也不能随便在地图里乱走吧，所以碰撞（物理表示）看来也是需要的啊，好吧，那就加上，齐活了。



## DefaultPawn，SpectatorPawn，Character

<<<<<<< HEAD
![image-20210527201808498](E:\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210527201808498.png)
=======
![image-20210527201808498](学习总结.assets\image-20210527201808498.png)
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6

### DefaultPawn

因为我们每次想自己搞Pawn都得从Pawn派生过来，然后再一个个添加组件。UE知道我们大家都很懒，所以提供了一个默认的Pawn：DefaultPawn，默认带了一个`DefaultPawnMovementComponent`、`spherical CollisionComponent`和`StaticMeshComponent`。也是上述Pawn阐述过的**三件套**，只不过都是默认套餐。

### SpectatorPawn

UE的FPS做的太好了，就会有一些观众想要观战。观战的玩家们虽然也在当前地图里，但是我们并不需要真正的去表示它们，只要给他们一些摄像机“漫游”的能力。所以==派生于DefaultPawn的SpectatorPawn提供了一个基本的USpectatorPawnMovement（不带重力漫游），并关闭了StaticMesh的显示，碰撞也设置到了“Spectator”通道。==

### Character

因为我们是人，所以在游戏中，代入的角色大部分也都是人。大部分游戏中都会有用到人形的角色，既然如此，UE就为我们直接提供了一个==人形的Pawn==来让我们操纵。

像人一样行走的`CharacterMovementComponent`， 尽量贴合的`CapsuleComponent`，再加上骨骼上蒙皮的网格。**同样的三件套，不一样的配方**。

有些人一开始的时候会困惑应该选择Pawn还是Character，其实从继承体系中就可以了解到**Character只不过是Pawn的加强特化版本**。一般来说，如果你控制的角色是人形的带骨骼的，那就选择Character吧。而如果是VR中的一双手（假设只有一双手），因为移动模式和显示都算不太上人形，顶多只能算是个漂浮的“幽灵”，所以还是用Pawn方便些。后期如果你想加上人形模型和IK了，那么再把Mesh替换成SkeletalMesh也就行了。Pawn因为是基础款，所以提供了最大的灵活性。



# GamePlay架构（五）Controller

<<<<<<< HEAD
=======
如上文所述，UE从`Actor`中分化了一些专门可供玩家“控制”的`Pawn`，那我们这篇就专门来谈谈该怎么个控制法！**所谓的控制，本质指的就是我们游戏的业务逻辑**。比如说玩家按A键，角色自动找一个最近的敌人并攻击，这个自动寻找目标并攻击的逻辑过程，就是我们所谈的控制。

## MVC

典型的，对于游戏：

- “==显示==”指的是游戏的UI，是屏幕上显示的3D画面，或是手柄上的输入和震动，也可以是VR头盔的镜片和定位，是与玩家直接交互的载体；
- “==数据==”指的是Mesh，Material，Actor，Level等各种元素组织起来的**内存数据表示**；
- “==算法==”可以是各种渲染算法，物理模拟，AI寻路，本文咱们就先暂时特指游戏开发者们编写的游戏业务逻辑。

抽象这三个变化，并归纳关系，就是**典型的MVC模式**了：

![image-20210531162441198](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\UnrealStudy\InsiderUE4\学习总结.assets\image-20210531162441198.png)

对于简单的游戏或者引擎来说，有时并不需要把这三者分的很清，如Cocos2dx就没有Controller，它的MVC就是混杂在一起，因为代码量少所以也还算勉强能凑合；Unity的MonoBehavior其实也相当于把MC放在了一起，用得方便的同时也得小心太顺手了出现组件之间互相网状引用一团乱麻的情况；UE在这个问题上的思考就有些一脉相承，既然Actor们形形色色，我们之前也谈过甚至有AInfo这种书记官，那为何不让一些Actor专门来承载逻辑呢？于是，`Actor`再度分化出`Controller`。下面我们就来一一介绍Actor旗下Controller家族的指挥官们。

## AController

虽然我在之前已经一再的剧透过AController是继承自AActor的一个子类，但是为了更好理解思考UE里的Controller机制，请先把脑袋放空，也别去偷看UE里的源码，像张无忌一样暂时忘记AController这回事，问自己一个问题：如果我想实现一种机制去控制游戏里的Actor，该怎么设计？巧妇难为无米之炊，咱们先来看看当前手上都有些什么：

1. **UObject**，反射序列化等机制
2. **UActorComponent**，功能的载体，一定程度的嵌套组装能力（SceneComponent）
3. **AActor**，基础的游戏对象，Component的容器
4. **APawn**，分化出来的AActor，物理表示和基本的移动能力，当前正翘首以待。
5. **没了**，在控制Actor这个层级，我们还暂时不需要去考虑Level等更高层次的对象

针对`APawn`，再想想我们希望达成的控制愿景，没事，你尽管放开想象的想，做不做得到咱们先放一边，但至少别在一开始就被想象力限制住了。“控制”本身虽然只是一段逻辑算法代码，但是它也需要有个载体去承载和运行，某种意义上来说也算得上是个实体。所以下面我们不妨就脑洞大开，以“控制”这个实体的视角口吻，讲讲“**我，作为一个——控制**”希望拥有哪一些本领：

1. **能够和Pawn对应起来**，理想情况下，极端的灵活性应该是多对多。我希望我能同时控制多个Pawn，当然，一个Pawn也可以被多个我的兄弟姐妹们一起控制。想想那些RTS游戏和多人协作游戏，你应该能明白我有时候需要协调调度Pawn们走个方阵，有时候也得多人合作才能操纵得了一台机甲。当然越灵活也往往意味着越容易出错，但总之我们需要一个和Pawn关联的机制。
2. **多个控制实例**，在需要的时候，我不介意可以克隆出多个我来，比如一段逻辑A，我们希望可以有多个实例在同时运行。就像行为树一样，可以有多个运行实例，彼此算法一样，但互不干扰。
3. **可挂载释放**，我可以选择当前控制PawnA，也可以选择之后把它释放掉不再控制让她自生自灭，然后再另寻新欢控制PawnB，我必须拥有灵活的运行时增删控制Pawn的能力。
4. **能够脱离Pawn存在**，我思故我在，就算当前没有任何Pawn控制，我也可以继续存在，这样我就可以延时动态的选择Pawn对象。有些Pawn值得我去等。
5. **操纵Pawn生死的能力**，谁规定必须一定去控制世界当前存在的Pawn才行。当世界里没有Pawn可供我控制时，我希望可以自己造一个出来。你要说她是玩具、亦或傀儡也好，我不在乎。有时候我很羡慕暗黑里的沉沦魔巫师，身边总是围绕着一群沉沦魔，一个沉沦魔挂了，他可以紧接着再复活一个出来，这样永远都不会感动寂寞，你说多好？那索性再霸道一点吧，要是我这个控制实体不在了，我**希望可以选择是否带Pawn们跟我一起走，没了我，她们都傻得让人心疼**。当然如果有哪个Pawn能让我这个霸道总裁爱上，我也愿意陪她一起去死。
6. **根据配置自动生成**，我（控制）虽然只是一段代码，但也不能无中生有，所以也得有个机制可以生成我这个控制实体，不过想来这应该是组织里更上层领导的事，但至少他应该知道怎么创建我出来。
7. **事件响应**，游戏事件的一些控制关心的事件应该能够传到我这里，我可以酌情处理。同样，Pawn也可以向我汇报，我会好好研究决定的，嗯。
8. **持续的运行**，没事的时候，我喜欢听世界大钟的每一次Tick，跟我的心跳同步起来，就仿佛真的活过来一样，可以自主的做一些我想做的事，这是我最自在的时候。
9. **自身有状态**，你累了要休息，我也一样。我可以选择自身的状态，选择工作或者是休息，也可以选择今天是哪个Pawn和心情最配。
10. **拥有一定的扩展继承组合能力**，一方面我希望我的家族开枝散叶繁荣昌盛，我的一身本领继承自我的父亲，而我也将有我的儿，大家各有天赋。另一方面，那些普通的Actor们都可以身背各个Component，更高贵的我当然也想有。
11. **保存数据状态**，听说金鱼的记忆只有7秒，可是我却想记住你一辈子。所以我希望我能拥有一些记忆，人的过去成就了现在，也将指引着未来。以前有一个人跟我说过，当你不能再拥有的时候，唯一能做的就是令自己不要忘记。
12. **可在世界里移动**，我可以选择帐中千里之外遥控Pawn，也可以选择附身在一个Pawn身上，这样我才能多角度无死角的观察我可爱的Pawn们，嘿嘿。
13. **可探查世界的对象**，我要有眼睛，让我干活，基本的我得看得见知道当前世界里已经有哪些对象吧，否则不就抓瞎了嘛。
14. **可同步**，这年头，要是不能适应网络环境，可真的没有竞争力。这个Object，Actor基本都有的能力，我当然也得有。位于服务器或客户端上的我也必须有能力在其他客户端上影分身，让他们都跟随我的步伐一致行动。

在仔细考察了**"控制"的需求**和**手头上的原料**之后，我们试着从UE的角度来权衡一下。首先**Controller不能是一个Component**，一是因为**Component的层级太低，表达的是功能的概念而非逻辑**；二是**Component必须依附于Actor存在，而我们的Controller希望能独立存在**。

其次如果从UObject直接继承下来UController，倒是也可行，UObject也能复制同步，其他的控制Pawn的能力和事件响应等倒也是能改改接口想想办法，但是要想在世界里移动，就得有个位置表示，再加上还希望能容纳Components，这就麻烦了，基本就是把Actor的工作再做一套，有点累人，搞起来也怕两套班子出错闹矛盾。

再来考察下从AActor继承下来AController怎么样，Actor比Object多了一些我们正需要的配置动态生成、输入事件响应、Tick、可继承、可容纳Component、可在世界里出现、可在网络间同步。好了，现在就差控制Pawn的能力，那我们就在这个分化出来的AController增加一些控制Pawn的接口，这个思路正是和我们从Actor从分化出Pawn的时候不谋而合！现在我们来看看UE里的AController：



<img src="学习总结.assets\v2-4151952d1f2ab74fcc78d7c3bd215e0d_720w.png" alt="img" style="zoom:67%;" />

跟我们的设计八九不离十，我们再一一仔细验证一番：关联Pawn的能力，有Possess和UnPossess，源码里也有PawnPendingDestroy等这些函数（未一一列出）；GameMode中也保存着AIControllerClass和PlayerControllerClass的配置，用于在适当的时候Spanw出Controller；继承于Actor也就有了EnableInput和Tick；Controller本身还可以继续派生下去（如AIController和PlayerController），也可以容纳Components；也带着一个SceneComponent所以可以摆放在世界中；自身也可以添加成员变量来记忆存储游戏状态；自身也有一个FName StateName（Playing、Spectating、Inactive），切换自身的状态（运行，观察，非激活）；因为跟Pawn是平级的关系，只在运行的时候引用关联，所以对彼此独立存在不做强制约束，提高了灵活性。一个Pawn自身上也可以配置策略：

```c++
namespace EAutoReceiveInput{
    enum Type
    {
        Disabled,
        Player0,
        Player1,
        Player2,
        Player3,
        Player4,
        Player5,
        Player6,
        Player7,
    };
}
TEnumAsByte<EAutoReceiveInput::Type> AutoPossessPlayer;
enum class EAutoPossessAI : uint8
{
    /** Feature is disabled (do not automatically possess AI). */
    Disabled,
    /** Only possess by an AI Controller if Pawn is placed in the world. */
    PlacedInWorld,
    /** Only possess by an AI Controller if Pawn is spawned after the world has loaded. */
    Spawned,
    /** Pawn is automatically possessed by an AI Controller whenever it is created. */
    PlacedInWorldOrSpawned,
};
EAutoPossessAI AutoPossessAI;
TSubclassOf<AController> AIControllerClass;
```

❓**思考：Controller和Pawn必须1:1吗？**

- 观察UE实现里我们发现Controller里只是保存了一个Pawn指针，而不是数组，这和一开始希望的多对多关系有些出入。理想和现实总是有差距，一个愿景落实到工程实践上也不免得有一些妥协。首先我们再来梳理理解一下这个Possess(拥有/占用)的概念。一个Controller能灵活的Possess/UnPossess一个Pawn，虽然一次只能控制一个，但在游戏中我们也可以在不同的Pawn中切换，比如操纵一个主角坐进然后控制一辆汽车，或者端起固定的机关枪扫射，这些功能琢磨一下其实只是涉及操作实体Pawn的变化。如果我们能妥善的用好Pawn和Controller的切换功能，大部分基本的游戏功能也是能够比较方便的实现的。

❓**思考：为何Controller不能像Actor层级嵌套？**

- 我们都知道Actor可以藉着身上的SceneComponent互相嵌套。那么AController同样也是Actor，为何不也实现这么一个父子机制？从功能上来说，一个Controller可以有子Controllers，听起来也是非常灵活强大啊。但是冷静想一下，Controller表达的“控制”的概念，所以在这里你实际上想要表达的是一种“控制”互相嵌套的概念，感觉又给“控制”给分了层，有“大控制”，也有“小控制”，但是“控制”的“大小”又是个什么概念呢？我们应该怎么划分控制的大小？“控制”本质上来说就是一些代码，不管怎么设计，目的都是用来表达游戏游戏逻辑的。

❓**思考：Controller可以显示吗？**

- 既然Actor本身可以带着Mesh组件来渲染显示，那Controller可不可以呢？是不是Controller都是不可见的？这个答案可说是也可以说不是，因为Controller本身确实就是一个特殊点的Actor而已，你依然可以在Controller中添加Mesh组件，添加别的子Actor等，所以从这个方面说Controller是有可以渲染显示的能力的。但是一个控制者毕竟只是表达一个逻辑的概念，所以为了分工明确，UE就干脆在Controller的构造函数里把自己给隐藏了：

  ```c#
      bHidden = true;
  #if WITH_EDITORONLY_DATA
      bHiddenEd = true;
  #endif // WITH_EDITORONLY_DATA
  ```

❓**思考：Controller的位置有什么意义？**

- 既然Controller本身只是控制者，那它在场景中的位置和移动有什么意义吗？Controller为何还需要个SceneComponent?意义在于如果Controller本身有位置信息，就可以利用该信息更好的控制Pawn的位置和移动。首先说下Controller的Rotation，这个比较好理解一点，如果我想让我的Pawn和Controller保持旋转朝向一致，因为是Controller作主控制Pawn的关系，所以Controller就得维护自己的Rotation。再来说位置，如果Controller有自己的位置，这样在Respawn重新生成Pawn的时候，你就可以选择在当前位置创建。因此为了自动更新Controller的位置，UE还提供了一个bAttachToPawn的开关选项，默认是关闭的，UE不会自动的更新Controller的位置信息；而如果打开，就会把Controller附加到Pawn的子节点里面去，让Controller跟随Pawn来移动。你可以把这两种模式想象成一种是上帝视角在千里之外心电感应控制Pawn，另一种是骑在Pawn肩上来指挥。
  当然如果这个Controller确实只是纯朴的逻辑控制的话（如AIController），那确实位置也没什么意义。所以UE甚至还隐藏了Controller的一些更新位置的接口，尽量避免让人手动去操纵。
- UE这里其实想说的是，这些更新位置的操作还是让我来为你管理吧，我真的担心你会用错搞出什么乱子来。顺便再说些题外话，**对于PlayerController来说，因为玩家需要一个视角来观察世界，所以常常PlayerController常常会扛着个摄像机出现**（蓝图里没有，但是会运行时生成PlayerCameraManager和CameraActor），所以就算没有角色可供操作，玩家也依然希望是可以视角漫游观察整个世界的（试试看把默认Level里的PlayerStart删掉后运行看看）。这个时候PlayerController常常会默认创建出一个ASpectatorPawn或者DefaultPawn（根据GameMode里配置），我们虽然看不见Pawn，但依然可以观察世界，靠得就是跟Controller关联的旋转和摄像机。

❓**思考：哪些逻辑应该写在Controller中？**

- 如同当初我们在思考Actor和Component的逻辑划分一样，我们也得要划分哪些逻辑应该放在Pawn中，哪些应该放在Contrller中。上文我们也说过，Pawn也可以接收用户输入事件，所以其实只要你愿意，你甚至可以脱离Controller做一个特立独行的Pawn。那么在哪些时候需要Controller？哪些逻辑应该由Controller掌管呢？可以从以下一些方面考虑：
  - 从概念上，Pawn本身表示的是一个“能动”的概念，重点在于“能”。而Controller代表的是动到“哪里”的概念，重点在于“方向”。**所以如果是一些Pawn本身固有的能力逻辑，如前进后退、播放动画、碰撞检测之类的就完全可以在Pawn内实现**；而对于一些可替换的逻辑，或者智能决策的，就应该归Controller管辖。
  - 从对应上来说，如果一个逻辑只属于某一类Pawn，那么其实你放进Pawn内也挺好。**而如果一个逻辑可以应用于多个Pawn，那么放进Controller就可以组合应用了**。举个例子，在战争游戏中，假设说有坦克和卡车两种战车（Pawn），只有坦克可以开炮，那么开炮这个功能你就可以直接实现在坦克Pawn上。而这两辆战车都有的自动寻找攻击目标功能，就可以实现在一个Controller里。
  - 从存在性来说，Controller的生命期比Pawn要长一些，比如我们经常会实现的游戏中玩家死亡后复活的功能。Pawn死亡后，这个Pawn就被Destroy了，就算之后再Respawn创建出来一个新的，但是Pawn身上保存的变量状态都已经被重置了。所以**对于那些需要在Pawn之外还要持续存在的逻辑和状态，放进Controller中是更好的选择**。

## APlayerState

我们上文提到过Controller希望也能有一些记忆，保存住一些游戏状态。那么到底应该怎么保存呢？AController自身当然可以添加成员变量来保存，这些变量也可以网络复制，一般来说也够用。但是终究还是遗忘了一个最重要的数据状态。整个游戏世界构建起来就是为了玩家服务的，而玩家在游戏过程中，肯定要存取产生一些状态。而**Controller作为游戏业务逻辑最重要的载体，势必要和玩家的状态打交道。所以Controller如果可以动态存取玩家的状态就会大为方便了**。因此我们会在Controller中见到：

```c#
 /** PlayerState containing replicated information about the player using this controller (only exists for players, not NPCs). */
    UPROPERTY(replicatedUsing=OnRep_PlayerState, BlueprintReadOnly, Category="Controller")
    class APlayerState* PlayerState;
```

而`APlayerState`的继承体系是：

![img](学习总结.assets\v2-ba203b15c1e9356d5aa7fe6bf2fd556c_720w.png)

至于**为啥APlayerState是从AActor派生的AInfo继承下来**的，我们聪明的读者相信也能猜得到了，所以也就不费口舌论证了。无非就是**贪图AActor本身的那些特性：网络复制等**。而AInfo们正是这种不爱表现的纯数据书呆子们的大本营。而这个PlayerState我们可以通过在GameMode中配置的PlayerStateClass来自动生成。

注意，这个**APlayerState也理所当然是生成在Level中的，跟Pawn和Controller是平级的关系，Controller里只不过保存了一个指针引用罢了**。注释里说的PlayerState只为players存在，不为NPC生成，指的是**PlayerState是跟UPlayer对应的，换句话说当前游戏有多少个真正的玩家，才会有多少个PlayerState，而那些AI控制的NPC因为不是真正的玩家，所以也不需要创建生成PlayerState**。

但是UE把PlayerState的引用变量放在了Controller一级，而不是PlayerController之中，说明了**其实AIController也是可以设置读取该变量的**。一个AI智能能够读取玩家的比分等状态，有了更多的信息来作决策，想来也没有什么不对嘛。

:star:Controller和网络的结合很紧密，很多机制和网络也非常强关联，但是在这里并不详细叙述，这里先可以单纯理解成Controller也可以当作玩家在服务器上的代理对象。把PlayerState独立构成一个Actor还有一个好处，当玩家偶尔因网络波动断线，因为这个连接不在了，所以该Controller也失效了被释放了，服务器可以把对应的该PlayerState先暂存起来，等玩家再紧接着重连上了，可以利用该PlayerState重新挂接上Controller，以此提供一个比较顺畅无缝的体验。至于AIController，因为都是运行在Server上的，Client上并没有，所以也就无所谓了。

❓**思考：哪些数据应该放在PlayerState中？**

- 从应用范围上来说，**PlayerState表示的是玩家的游玩数据**，所以那些关卡内的其他游戏数据就不应该放进来（GameState是个好选择），另外**Controller本身运行需要的临时数据也不应该归PlayerState管理**。而玩家在切换关卡的时候，APlayerState也会被释放掉，所有**PlayerState实际上表达的是当前关卡的玩家得分等数据**。这样，**那些跨关卡的统计数据等就也不应该放进PlayerState里了**，应该放在外面的GameInstance，然后用SaveGame保存起来。

## 总结

在游戏里，如果要评劳模，那Controller们无疑是最兢兢业业的，虽然有时候蛮横霸道了一些，但是经常工作在第一线，下面的Pawn们常常智商太低，上面的Level，GameMode们又有点高高在上，让他们直接管理数量繁多的Pawn们又有点太折腾，于是事无巨细的真正干那些脏活累活的还得靠Controller们。本文虽然没有在网络一块留太多笔墨，但是Controller也是同时作为联机环境中最重要的沟通渠道，身兼要职。

回顾总结一下本文要点，UE在Pawn这个层级演化构成了一个最基本和非常完善的`Component-Actor-Pawn-Controller`的结构：

<img src="学习总结.assets\v2-117fa2fe09c46ed2dac388278f028df0_r.jpg" alt="preview" style="zoom:67%;" />

通过分化出来后的Actor的互相控制，既充分利用了现有的机制功能，又提供了足够的灵活性，而且做的更改还很少，不用再设计额外另一套框架。读者朋友们，现在我们如果翻到第一小节，想想UE最初从Object分化出Actor的那一刻，是不是有很多感慨和感动呢？一个最初的很简单的游戏对象表示，慢慢演化派生充实起来，彼此之间通力配合，竟也能优雅的运转起来。

有时候架构的设计和搭建是一脉相承的，最初的时候选择了什么样的模型和骨架，后面再设计别的逻辑框架等其他模块，也基本上都得跟最初的设计配合着来。所以有时候往往也会发现，怎么感觉我架构设计的方案可选择数量并不多啊？其实是因为如果一开始铺垫的好，接下来的设计水到渠成自然而然，让你感觉不到用心设计的力气。UE以Actor的视角来看待世间万物，自然得到的是一个Actor繁荣昌盛的世界；Unity以Component来组装万物，得到的就是个各种插件组件组装出的世界；而如果如Cocos2dx一般万物都是Node,那么自然也会得到一棵挂满各种Node的世界之树。这也算是游戏引擎的基因吧。

本想着一篇介绍完Controller、PlayerController和AIController这三个对象，但是Controller本身是UE里极为重要的核心概念，自身的功能非常的丰富，牵扯的模块也比较多，因此想抽离阐述最核心的概念和功能并不是一件容易的事。花了这么长的篇幅，只讨论揣摩了`Controller`的设计过程和最基本的职责（还有输入网络等都没有解释），顺便先简单介绍了下`PlayerState`出场（PlayerState实际上是跟UPlayer关联更大一些，PlayerController等后续章节会继续讨论它），对于PlayerController和AIController，目前也只是语焉不详的含糊带过。不过还是希望读者们能从中吸取到设计的营养，把握清楚概念了，才能更好的组织游戏逻辑，开发出更好的游戏。



# GamePlay架构（六）PlayerController和AIController

上文我们谈到了Component-Actor-Pawn-Controller的结构，追溯了AController整个家族的崛起和身负的使命。本篇我们继续来探讨Controller家族中最为人所知的`PlayerController`和`AIController`。

作为一个Controller，我们讨论的依然是该如何控制。我们已经知道了==Controller可以Possess并控制Pawn==，但是Controller本身又是怎么驱动起来的呢？**一个游戏里的控制角色大抵都可以分为两类：玩家和AI**。不管是单机游戏或者分屏多玩家，还是网络玩家联机对战，游戏都是为了玩家服务的，所以也必然会有一个或多个玩家，就算是如《山》那种纯看的游戏，也是有一个“可观察不可动”的玩家的。而AI的实体的数量就可以是零或者多个。

## APlayerController

让咱们先从简单的单机游戏开始讨论吧，比如一款单机FPS游戏，这个游戏里已经用各种各样的Actor们构建完成了世界场景，你的主角和敌人Pawn们也都在整装待发，这个时候你思考这么一个问题，我该怎么玩这个游戏？壮丽的舞台已经准备好了，就等你入场了。先抛开具体的引擎而言，**首先你需要能看见**（拥有Camera和位置），其次你**必须能响应输**入（玩家按WASD你应该能接收到），然后你可以**根据输入操控一些Pawn（Possess然后传递Input）**，这样一个单机游戏中的简单玩家控制器就差不多了。**一个游戏中只有一个PlayerController，在不同的关卡中你可以使用不同的PlayerController，但是同一时刻响应的只能是一个PlayerController**。

插上多个手柄，咱们再拓展一下，比如像**《街霸》那种单PC但是多玩家对抗或者协作的游戏**。两个玩家可以分别用两个手柄，或者一个用键盘一个用鼠标，甚至是键盘上的不同区域，形式可以多种多样。这个时候如果依然只有一个PlayerController，实现起来其实也是可行的，把两个手柄——所有的输入都由这个PlayerController来接收，然后在PlayerController内部再分别根据情况去处理不同的Pawn。但是这种方式的缺点显然也在于很容易把玩家1、2的输入和控制混杂在一起，没有清晰的区分开。**因此，为了支持这种情况，我们可以开始允许游戏中同时出现多个PlayerController，每个PlayerController甚至都可以拥有自己的Viewport（分屏或者不同窗口），这样我们通过配置，可以精确的路由手柄1的输入给玩家1，各自的逻辑也很好的区分和复用。**

再插上网线继续，**到了网游时代，我们的游戏就开始允许有多人联机对战了**。玩家在自己的PC上控制的只是自己的本地的角色，而屏幕游戏里其他的玩家角色是由网线另一端的玩家控制的。为了更好的适应这种情况，我们就又得扩展一下PlayerController的概念，PlayerController不仅能控制本地的Pawn，而且还能“控制”远程的Pawn（**实际上是通过Server上的PlayerController控制Server上的Pawn，然后再复制到远程机器上的Pawn实现的**）。

因此我们来看看==UE里的PlayerController==：

<img src="学习总结.assets\v2-88131e55febd8886e0f3c87b92c526e8_r.jpg" alt="preview" style="zoom:67%;" />

PlayerController因为是直接跟玩家打交道的逻辑类，因此是UE里使用最多的类之一。UE4.13.2版本里1632行的.h文件和4686行的.cpp文件，里面实现了很多的功能，初阅读起来往往深陷其中不得要领。但是在上述的分析了之后，我们也可以在其中大概归纳出几个模块：

- ==Camera的管理==，目的都是为了控制玩家的视角，所以有了`PlayerCameraManager`这一个关联很紧密的摄像机管理类，用来方便的切换摄像机。`PlayerController`的ControlRotation、ViewTarget等也都是为了**更新Camera的位置**。因为跟Camera的关系紧密，而Camera最后输出的是屏幕坐标里的图像，所以为了方便一些拾取的**HitResult函数**也都是实现在这里面。渲染章节会再详细介绍UE的摄像机管理。
- ==Input系统==，包括构建`InputStack`用来路由输入事件，也包括了自己对输入事件的处理。所以包含了`UPlayerInput`来委托处理。
- ==**UPlayer关联**==，既然顾名思义是`PlayerController`，那自然要和Player对应起来，这也是==PlayerController最核心的部分==。**一个UPlayer可以是本地的LocalPlayer，也可以是一个网络控制UNetConnection**。`PlayerController`只有在`SetPlayer`之后，才可以开始正常工作。
- ==HUD显示==，用于在当前控制器的摄像机面前一直显示一些UI，这是从UE3迁移过来的组件，现在用`UMG`的比较多，等介绍UI模块的时候再详细介绍。
- ==Level的切换==，PlayerController作为网络里通道，在一起进行Level Travelling的时候，也都是先通过PlayerController来进行RPC调用，然后由PlayerController来转发到自己World中来实际进行。
- ==Voice==，也是为了方便网络中语音聊天的一些控制函数。

简单来说，`PlayerController`作为玩家直接控制的实体，很多的跟玩家直接相关的操作也都得委托它来完成。目前来说`PlayerController`里旗下的100+的函数也大概可以分为以上几大模块，也根据需要重载了Controller里的一些其他函数。

**UE的思想是具象化一个“玩家实体”**，并把所有的跟该玩家相关的操作和接口都交给它完成。一般其他的游戏引擎只是个“功能引擎”，提供了一些图形渲染UI系统等组件，但是在`GamePlay`这个层次就都非常欠缺了，一般都需要开发者自己搭建一套。而回想你写过的游戏，是不是也往往有一个**Player类**（一般是单件或者全局变量）？里面几乎是放着所有跟该玩家相关的业务逻辑代码。**UE里的PlayerController就是这种概念，优点当然是直接方便好理解，缺点也如你所见，会代码膨胀得比较快**。不过目前来说还算能接受，**等某一块功能真的比较大了之后，可以再把它抽出一个单独的类来，如`PlayerInput`和`PlayerCameraManager`一样**。

❓**思考：哪些逻辑应该放在PlayerController中？**

- 回想我们上篇的问题：“哪些逻辑应该写在Controller中？”，该处的答案观点在本处也依然适用。不过我还想再补充几点：
  - 对实现游戏逻辑来说，如果是**按照MVC的视角**，那么View对应的是Pawn的表现，而**PlayerController对应的是Controller的部分**，那Model就是游戏业务逻辑的数据了。拿超级马里奥游戏来举例子，把问题先局限在一个关卡内，假设要实现的是金币的逻辑，那么View指的是游戏右上角的金币数目UI，而玩家用PlayerController来控制马里奥来蹦跳行走，而**马里奥（Pawn）**通过触碰金币的事件又上报给PlayerController来相应增加金币。而**PlayerController存储金币的数据就是在PlayerState中**。即PlayerState中有一个**int coin**，也有相应的AddCoin(int coin)。**而PlayerController的职责应该是一边控制Pawn，一边负责内部正确的调用PlayerState的Coin接口。**那么PlayerController里的成员变量有什么用？根据单一职责原则，我们写在哪个类里的变量应该尽量只符合该类的作用，所以PlayerController里的变量的意义在于更好的实现控制。比如假设玩家在一个关卡内可以按AABB来作弊获得100金币，但是限最多3次。那么这个按键的响应就应该由PlayerController来接收，然后调用AddCoin(100)，并更新PlayerController里的成员变量CoinCheatCount。也或者想实现马里奥的加速跑，也可以在PlayerController里增加`Speed`的成员变量。
  - **记住PlayerController是可被替换的，不同的关卡里也可能是不一样的。比如马里奥在水下的时候控制的方式明显就不一样**，所以就不能像“Player”单件类那样什么都往里面塞。这样一旦被替换掉了之后数据就都丢失了。
  - PlayerController也不一定存在，考虑一下如果把马里奥做成联机游戏，那么对方玩家被同步过来的将只有PlayerState，对方玩家的PlayerController只在服务器上存在。所以这个时候，如果你把金币数据放在PlayerController里的话就非常尴尬了。所以为了扩展性来说，还是根据职责分明的原则来正确划分业务逻辑会比较好。
  - ==在任一刻，Player:PlayerController:PlayerState是`1:1:1`的关系==。**但是PlayerController可以有多个备选用来切换，PlayerState也可以相应多个切换**。`UPlayer`的概念会在之后讲解，但目前**可以简单理解为游戏里一个全局的玩家逻辑实体**，**而PlayerController代表的就是玩家的意志，PlayerState代表的是玩家的状态**。

## AAIController

从某种程度上来说，AI也可以算是一个Player，只不过它不需要接收玩家的控制，可以自行决策行动。从**玩家控制的逻辑**需要有一个载体一样，**AI的逻辑算法也需要有一个运行的实体**。而这就是UE里的`AIController`：

<img src="学习总结.assets\v2-a0c2148ff8331da1b70ab4157e19f1c2_r.jpg" alt="preview" style="zoom: 67%;" />

同PlayerController对比，少了Camera、Input、UPlayer关联，HUD显示，Voice、Level切换接口，但也增加了一些AI需要的组件：

- ==Navigation==，用于智能根据==导航寻路==，其中我们常用的`MoveTo`接口就是做这件事情的。而在移动的过程中，因为少了玩家控制的来转向，所以多了一个`SetFocus`来控制当前的Pawn视角朝向哪个位置。
- ==AI组件==，运行**启动行为树**，使用黑板数据，探索周围环境，以后如果有别的AI算法方法实现成组件，也应该在本组件内组合启动。
- ==Task系统==，让AI去完成一些任务，也是实现`GameplayAbilities`系统的一个接口。目前简单来说GameplayAbilities是为Actor添加额外能力属性集合的一个模块，比如HP，MP等。其中的GamePlayEffect也是用来实现Buffer的工具。另外GamePlayTags也是用来给Actor添加标签标记来表明状态的一种机制。目前来说该两个模块似乎都是由Epic的Game Team在维护，所以完成度不是非常的高，用的时候也往往需要根据自己情况去重构调整。

本文重点不在于讨论AI内部的各种组件功能，因此我们先把目光聚焦在AIController对象本身上。同PlayerController一样，**AIController也只存在于Server上（单机游戏也可看作是Server）**。游戏里必须有玩家参与，而AI可以没有，所以AIController并不一定会存在。我们可以在Pawn上配置AIControllerClass来让该Pawn产生的时候自动为它分配一个`AIController`，之后自动释放。

❓**思考：哪些逻辑应该放在AIController中？**

- 我们依然要思考这个问题，**大部分思想和原则和PlayerController是一样的**，只不过AI算法的多种多样，所以我们**推荐尽量利用UE提供的行为树、黑板等组件实现，而不是直接在AIController硬编码再度实现**。也请把目光仅仅局限在当前的Pawn身上，不要在里面写其他无关的逻辑。另外，**因为AIController都是在关卡内比较短暂存在的，一般不太有跨Level的数据保存，所以你可以用AIController的成员变量来保存状态**。而如果真的需要用到PlayerController的状态，则也可以引用一个PlayerState过来。如果想引用关卡的全局状态，也可以引用GameState，再更高级别的，甚至可以直接和GameInstance接触。
- 但是AIController也可以通过配置`bWantsPlayerState`来获得自己的PlayerState，所以PlayerState其实也并不是跟`UPlayer`绑定的，毕竟从本质上来说APlayerState也只是个AInfo（AActor），跟其他Actor一样可以有多个，并没有什么稀奇的，区别是你自己怎么创建并利用它。

## 总结

到此，我们也算讨论完了**Actor（Pawn）层次的控制**，在这个层次上，我们关注的焦点在于如何更好的控制游戏世界里各种Actor交互和逻辑。UE采用了分化Actor的思维创建出AController来控制APawn们，因为玩家玩游戏也全都是控制着游戏里的一个化身来行动，所以UE抽象总结分化了一个APlayerController来上接Player的输入，下承Pawn的控制。对于那些自治的AI实体，UE给予了同样的尊重，创建出AIController，包含了一些方便的AI组件来实现游戏逻辑。并利用PlayerState来存储状态数据，支持在网络间同步。

![preview](学习总结.assets\v2-3bd34e0947e07fe6b4e54b025977b3ac_r.jpg)

上图应该可以比较清晰的阐明，UE是如何充分利用Actor的本身机制来反过来实现对Actor的逻辑控制，相信亲爱的读者朋友们也能自行体会到它的优雅之处。对比其他的游戏引擎，往往它们都止步于Actor这一个层次，只提供了最基本的对象层次，美名其曰交给玩家控制。UE为我们提供了这一套简洁强大的机制，大大方便了我们编写逻辑的难度。

 
>>>>>>> 4142ca8657e3e44233f288049249965af72362f6
