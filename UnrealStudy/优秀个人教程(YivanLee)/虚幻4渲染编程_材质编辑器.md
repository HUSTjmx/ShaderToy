## 自定义光照模型

![img](https://pic2.zhimg.com/80/v2-0c2c33bd32b708dcd5eebd59edcab13d_720w.jpg)

读过我前面一些博客的朋友对虚幻4的渲染流程有了一些大致的了解之后，那么我们现在可以开始着手开始修改虚幻4引擎了·。我们有些时候需要实现某些效果，就需要动手自己改引擎了。这是customnode或者是纯material无法做到的。有些人可能就要反驳了，“我纯用材质编辑器也能实现卡通材质啊”。但是无法忽略的一点是：在材质编辑器里制作的卡通材质无法接受光影。这时候有些人就想出了骚操作，用蓝图自己实现一个光源，渲染一张depthmap的RT然后传到material里去。这种方法其实过于麻烦，这相当于你抛弃掉了虚幻4的光照系统。这是得不偿失的。

阅读下面的内容你需要具备一下知识：

（1）C++

（2）对虚幻引擎及其渲染模块有一定了解，如果不了解可以先读读我之前的一些文章。

（3）HLSL

那么下面就以这个卡通材质为例，让我们一步步来定制自己的渲染管线，来看一下虚幻的GBuffer的数据有哪些吧：

![img](https://pic2.zhimg.com/80/v2-f2df11cbc694e6fe469ef7f348f13735_720w.jpg)

首先你得下载好一个源码版引擎，我使用的是4.19版引擎。也许在未来引擎会做更新，单应该变化不大。然后打开如下的文件：

![img](https://pic1.zhimg.com/80/v2-69e1c367f96b3d8a003a5f70a66f0208_720w.jpg)

首先找到EngineTypes.h，找到EMaterialSamplerType这个枚举。这个枚举将会控制材质编辑器里的那个下展栏。然后我们加入我们的枚举成员MSM_MyShadingModel UMETA(DisplayName="MyShadingModel")编译引擎后你将会看到如下的样子：

![img](https://pic3.zhimg.com/80/v2-ba6a063f0b008a7e6bb5bf09aa530ba2_720w.jpg)

你将能在材质编辑器里找到自己的ShadingModel材质的枚举类型。



这一步只是让编辑器有了一个切换枚举，并不会让材质编辑的UI发生什么变化，比如material的节点上多出几个pin，禁用几个pin或者别的什么变化。现在我们需要激活几个pin接口，让我们能把变量“连上去”



接下来找到Material.cpp 我们找到bool UMaterial::IsPropertyActive(EMaterialProperty InProperty)这个函数。然后做如下图所示修改

![img](https://pic3.zhimg.com/80/v2-68ff4005889b3d71b2b108c0bd9ec8ae_720w.jpg)

这样就能让材质编辑器在我们切换shadingmodel枚举的时候，实时增加一个CustomData的pin接口给我们用啦。

![img](https://pic3.zhimg.com/80/v2-dab0152ca4ff364484fcc14801082dee_720w.jpg)

有了这个东西之后，我们还要让材质编辑器在切换瞬间告诉我们的shader：“我们应该用我们自定义的shader啦”。如何告诉shader应该跑我们MSM_MyShadingModel的shading分支逻辑呢？答案是使用宏。

打开MaterialShared.cpp，找到FMaterial::SetupMaterialEnvironment(

EShaderPlatform Platform,

const FUniformExpressionSet& InUniformExpressionSet,

FShaderCompilerEnvironment& OutEnvironment

)

这个函数我们做如下修改：添加如下代码

case MSM_MyShadingModel: OutEnvironment.SetDefine(TEXT("MATERIAL_SHADINGMODEL_MyShadingModel"), TEXT("1")); break;

![img](https://pic4.zhimg.com/80/v2-a2414e1a2f2ac128edfc3c482e0bc57b_720w.jpg)

这个字符串会被压进shader里，成为宏。

做完这些我们就可以编译引擎了。可能会等待半小时左右。

编译好引擎之后，我们开始对shader层进行修改。

首先打开DefferedShadingCommon.ush文件，找到下图所示区域并做如下修改：在#define SHADINGMODELID_EYE 9后面添加#define SHADINGMODELID_MyShadingModel 10 并且把SHADINGMODELID_NUM后的数字改为11

![img](https://pic1.zhimg.com/80/v2-8168617a8eaa21dc70f1c15d58c2fd80_720w.jpg)

这个宏将作为我们shader跑哪根线路的判断依据。还是在这个文件里，翻到DefferedShadingCommon.ush的最底部，找到float3 GetShadingModelColor(uint ShadingModelID)函数，在case SHADINGMODELID_EYE: return float3(0.3f, 1.0f, 1.0f);后面添加 case SHADINGMODELID_MyShadingModel: return float3(0.4f, 0.0f, 0.8f);//紫色

如下图所示：

![img](https://pic4.zhimg.com/80/v2-2e7e48430ce4e28055c6a045b6f5dd37_720w.jpg)

做完这个修改以后，我们就能在编辑器的ShadingModle预览模式下看到如下效果：

![img](https://pic4.zhimg.com/80/v2-dab87fa3008b83521891316474394217_720w.jpg)

你能看到我们定义的颜色已经能在debug模式下看到了。说明一切顺利！！

下一步来到ShadingModelsMaterial.ush 找到void SetGBufferForShadingModel函数。我们在这个函数的最后面做如下修改：

![img](https://pic3.zhimg.com/80/v2-39019d54d277e24df9976a8f849ddcd2_720w.jpg)

这里的MATERIAL_SHADINGMODEL_MyShadingModel是从c++层那里塞进来的，然后把这个ShadingModle的ID保存到GBuffer里作为后面管线使用的数据。这一步是给DefferedShadingCommon.ush使用的。

完成之后我们需要打开BassPassCommon.ush，打开CustomData的写入权限

![img](https://pic2.zhimg.com/80/v2-4b7f86135022db6bfe787c82442199c9_720w.jpg)

这一步的目的是当我们的shadingmode为MyShadingModel的时候，将CustomData的信息写入GBuffer。



然后来打DefferdLightingCommon.ush 找到GetDynamicLighting函数，我们对这个函数做如下修改：

![img](https://pic2.zhimg.com/80/v2-5419fd201a95481a74171635fa9c78b5_720w.jpg)

当然做了这个修改之后我们还需要对SurfaceShading函数再做修改：

打开ShadingModels.ush做如下修改：

![img](https://pic2.zhimg.com/80/v2-9b4f43de2df49122033efeb2f4257e75_720w.jpg)

完成这一步之后，我们还要对透明模式下的代码进行修改。打开BasePassPixelShader做如下修改：

完成这一步之后，我们还要对透明模式下的代码进行修改。打开BasePassPixelShader做如下修改：

![img](https://pic1.zhimg.com/80/v2-d0c3c18ac3c3053ab4bb6cdeef29656c_720w.jpg)

那么就完成了对引擎shader的定制啦！

![img](https://pic1.zhimg.com/80/v2-5e13acb20836b731f52741fa0e2bdfdc_720w.jpg)

引擎的定制对项目还是很重要的，官方其实考虑更多的是通用和兼容，但是这往往就导致一点：用虚幻4做出来的游戏都长得差不多。不知道大家有没有发现这点。其实我对这点感受还是很明显的，现在的demo或者视频瞟一眼就知道是不是虚幻做的，因为大家的shader效果是一样的。这就会导致大量的同质化作品的出现，无法使你的项目脱颖而出。比如超龙珠斗士Z，那么精美的卡通渲染，肯定对引擎进行了大量的定制。

有没有发现，我们自己激活的哪个CustomData0 这个接口的名字在你切换成Eye的时候，它会变成其他名字。鉴于强烈的强迫症，看这个CustomData0真的很不舒服，所以我们就来自己定义一下材质输入接口的名字吧：



我们在Engine/Source/Editor/UnrealEd/Private/MaterialGraph.cpp的529行左右找到GetCustomDataPinName函数，然后做如下修改

![img](https://pic4.zhimg.com/80/v2-bf1f4865cb71b939b670238b41ab02b7_720w.jpg)

编译后你将会看到：

![img](https://pic3.zhimg.com/80/v2-2ba6549d648d7a3862cb2a740d902752_720w.jpg)

总得来说自己在延迟管线建个shadingmodle我们要做的事情如下：

（1）修改材质编辑器，不管是修改ShadingModel的Enum还是材质编辑器输出接口都是为了在材质编辑器层加入我们的光照模型和所需要的资源。

（2）在SetupMaterialEnvironment函数中把Shad ing ModelID设置进去，在Shader层也要对应修改让BasePass的时候把MaterialID渲染进Buffer中供LightingPass使用

（3）增加LightingPass的BRDF处理函数。



## 布料,丝绸纱皮革棉

现在的游戏对质感要求越来越高（我估计是硬件越来越好，可编程管线越来越来越完善）。游戏的画面已经越来越接近影视级，软光栅能被玩到这种水平也是令人惊叹。随着实时光线追踪追踪时代就要到来，这种差距只会越来越小，很多影视的制作思路和方法会被游戏借鉴甚至采用。

话题转回来，我们现在游戏仍然在大规模使用软光栅的办法，所以想要模拟出尽可能真实的游戏世界，我们还是需要很多trick。下面就一起来探索一下游戏世界中布料衣物的shading方法。本人只是个小技术美术，如有错误还请各路大神斧正。

**FORWARD DECLARATION：**

文章内容过于浅显，如有错误还请斧正。

**【第一小节：棉&布】**

还是老规矩，先上效果

![img](https://pic3.zhimg.com/v2-570e83a7de8ff535bde3958a9cd2a2e2_b.jpg)

![img](https://pic3.zhimg.com/80/v2-0e45956687c6bc7887bae43f702e5cb6_720w.jpg)

游戏里的这种短毛绒的感觉是有一套开发解决方案的，现在大致有四种方式来制作这种东西。**第一种是**：法线贴图+特殊高光着色+特殊AO。这种方式非常适合于手游，而且能出比较好的效果

![img](https://pic1.zhimg.com/80/v2-dca3230464f0b31268fd5f79275d7420_720w.jpg)手游巨省性能毛布

上面这个十分小的图就是这种方式做出来的，很抱歉这里我不能截完整衣服的效果图，但是就看这一小块应该能领悟到我说的意思了吧。因为手游的性能瓶颈，我们想要制造毛绒感只能在其他地方下功夫，高光计算部分就是个不错的地方。

**第二种是**：置换+法线+特殊高光着色。这个就是我最上面那个棉的制作方式。但是由于使用到了置换，所以性能嘛。。。。。不过端游是可以用的哈！

**第三种是**：视差+法线+特殊高光着色+特殊AO。这个效果就是我下面的那个毛毯。AO使用的是三维AO

**第四种是**：第四种就是Ray Casting的方式了嘛，这种方式巨费无比但是效果很好。



**【第二小节：丝绸&纱】**

![img](https://pic1.zhimg.com/80/v2-0aa286dcfa80ce20b9a1e2255cb3f6f0_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-e21935a946d41d2b12402d547a35ed6e_720w.jpg)



丝绸和纱的做法目前有两种方式：

**第一种**：半透+Tilling+特殊高光计算。这种方式效果其实比较好，但是就是透明乱序会令人十分头疼，解决办法就是我们自己再计算一次剔除。

剔除有几个办法，第一种是shader里强制剔除，还有一种是再渲染一个pass来剔除。这类文章很多啦我这里就不多说了。

![img](https://pic4.zhimg.com/v2-3c218951f4740d871106f4c16e587da7_b.jpg)

多渲染一个pass来剔除（上面那个水印是我CSDN博客地址，详细做法可以找这个地址去看我的博客）

![img](https://pic4.zhimg.com/80/v2-9b7ea4259f8d02dbc707a291c2858d83_720w.jpg)shader里计算剔除

**第二种**：使用AlphaTest来做透明+特殊高光计算+特殊Diffuse计算，但是这种办法有个问题，就是边缘锐利，我们可以用alpha dither的方式把锐利的边缘戳孔来解决，这种方式就不会有透明乱序的问题，我的第一幅图那个纱就是使用这种办法制作的。因为纱还有各向异性，所以需要使用各向异性高光。



最后就是Diffuse计算了。布料的Diffuse会有一点奇怪的地方，其实布料不应该使用默认PBR的那套diffuse计算方式的，所以虚幻提供了cloth特殊光照模型，请用那个光照模型来制作布料。那布料的diffuse和普通PBR的diffuse到底有什么区别呢。请看下面的图

![img](https://pic4.zhimg.com/80/v2-1dd8b1de7fe629f101e6f59adefe962f_720w.jpg)

可以看到，纺织物的漫反射方式和普通物体的区别还是很大的。最终宏观表现就是，纺织物的暗部不会很黑。

**【第三小节：皮革】**

其实皮革是所有布料里面最好做的，使用标准PBR模型就能轻易制作出来。皮革是介于金属和非金属之间的可以理解为半导体，主要使用细节法线tilling来使其与塑料产生区别。

上面说了这么多理论，其实并没有什么用哈。很多专栏或者博客也许会在上面就戛然而止然后发表文章了，然而真的并没有什么用。本专栏一向是本着一定要亲手做出来才行的宗旨。所以下面就来实现它们吧：

**首先先来说说布料**：

虚幻非常贴心地已经帮我们实现了布料材质模型了，其实如果没有，我们使用前几章介绍的知识也能自己做一个这种光照模型，当然它这里有了的话我们就直接用了。

![img](https://pic4.zhimg.com/80/v2-052578d991041485e89d04050670198f_720w.jpg)

我这里简单做了个材质球，这个其实就已经满足了我们对布料漫反射的要求了，再来上一次布料应该的漫反射模型：

![img](https://pic2.zhimg.com/80/v2-9dc76fa190086140363aa53552039fb9_720w.jpg)

所以这里就不难理解为啥会有一个fuzzy color了。我们再来看看这个光照模型的代码

![img](https://pic4.zhimg.com/80/v2-2fc478568a54d5eaa955451fa8b8ac4f_720w.jpg)

是不是一切就很清晰了呢，其实就是想模拟布料的那种特殊的漫反射。

首先光照模型对了之后，后面再加上法线再加上细节tilling，对布料效果的模拟还是十分棒的。

**其次就是丝绸了**

丝绸的尴尬点就在于如果你使用半透明的混合方式来制作，我们不得不解决透明乱序。

透明乱序的解决方法：

![img](https://pic3.zhimg.com/80/v2-06910f27ebaaee4d15f3c93caee46516_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-89e1f30987efdbd0155476b033362265_720w.jpg)

在shader种比较深度然后来手动剔除。

![img](https://pic4.zhimg.com/80/v2-ceadbd45fc75b974dd6bbb0ea5887aaf_720w.jpg)水印是我CSDN博客，可以去我原博客看我的这篇文章

![img](https://pic1.zhimg.com/80/v2-c7ed44ac5a7a51f0401670ff1b4bd148_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-96203b53db5a3e315445494f56fd26cc_720w.jpg)

但是这种手动剔除其实是剔除不干净的，仔细看手指的地方。再渲染一个pass的方式能完美解决但是消耗感觉过高了。所以干脆使用其他办法。

虚幻官方的头发给了我们一个新思路，使用alphatest然后再锐利的边缘扎孔。

![img](https://pic4.zhimg.com/80/v2-c501e6937834f56d07250a6108d6c2ef_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-4da270da632addafe07710e11e59ca1e_720w.jpg)

感觉这种方式也挺不错呢，虽然渐变过渡永远比不上alpha blend，这个就看自己的权衡了吧。



## 各向异性材质&玻璃材质

各向异性材质

![img](https://pic2.zhimg.com/v2-9dfca80e3b35b4e4142ea3ddfea4f469_b.webp)

玻璃材质

![img](https://pic1.zhimg.com/v2-42473ef5a7543a919efa81ca7b05448c_b.jpg)

![img](https://pic3.zhimg.com/80/v2-fd64c031be35b528b77998a8a60dc62a_720w.jpg)

材质编辑器篇的很多效果都非常简单，可以不改源码就能快速实现了。

### 

**各向异性：**

我们之前的高光会使用dot（N，H）来计算，不管你是PBR还是什么计算模型。各向异性的话是使用切线和H来计算，而不是N和H来计算。

![img](https://pic2.zhimg.com/80/v2-b495fa015f70ea79eadba866c75ab6e9_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-1d52843a3ebe2998532f2cd2e602ab79_720w.jpg)

**玻璃材质：**

其实玻璃材质可以分为以下几部分：

（1）漫反射

玻璃可以认为它没有漫反射，或者非常微弱。

（2）透射

因为玻璃是透明的，后面的光从玻璃里面透射出来会把玻璃本身的颜色透射出来。

（3）折射

光穿过玻璃会产生偏移

（4）反射

其中漫反射和反射部分的可以用PBR的计算方式来解决，下面来解决折射。因为我们使用的是光栅化渲染所以我们如果用光栅化思想来理解折射的话，一句话概括为（对背景图扰动）。

于是我们可以得到下面的材质：

![img](https://pic2.zhimg.com/80/v2-410f7a35b9bfe28f94ce13001bd4464d_720w.jpg)



## Modify RenderPipeline in ME

As we all know, we can't modify the main render pipeline of unreal engine 4。We can only edit our shader in the material editor. If we want to do something special which material editor can't meet our needs, Using c++ to modify the engine is currently the only viable method. My previous article has detailed implementation steps for this method.

[小IVan：虚幻4渲染编程(材质编辑器篇)【第二卷：自定义光照模型】](https://zhuanlan.zhihu.com/p/36840778)

However, Using c++ to modify the engine is not a good way. Because This method is very inconvenient. Below I will introduce a way to modify the rendering pipeline directly in the material editor.

Let's see the results first.

![img](https://pic4.zhimg.com/80/v2-8ad070d8aeb7ff0693cf469a3f3f87ab_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-921e1006ee368b2ecb98517abc3cc6b2_720w.jpg)

The code shown above is relatively simple, but the goal of modifying the rendering pipeline directly in the material editor has been achieved.

First we need to modify the source code of CustomNode。

![img](https://pic4.zhimg.com/80/v2-bc2cba798f82beec59095031b48044af_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-53ba1cf41d8dac3c3f883fd4e35e52fc_720w.jpg)

Compile the engine, then open the material editor to add a CustomNode and you will see the following result.

![img](https://pic3.zhimg.com/80/v2-6be58a948a17cd882ae3cc55f17a3cde_720w.jpg)

If you write a macro to def, the macro will be pushed into the shader, and the rendering pipeline will get the macros.

![img](https://pic4.zhimg.com/80/v2-6805e6df9c555cd8cd80d2ca13dbf9a7_720w.jpg)

Then we can write our code into the engine shader, which can be easily enabled using the material editor.

![img](https://pic1.zhimg.com/80/v2-4e6e10bfbd5213a21bb3fd728cbe9498_720w.jpg)