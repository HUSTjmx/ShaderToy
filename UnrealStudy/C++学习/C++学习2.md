# UE4中处理事件和代理

## 处理通过虚函数实现的事件

Unreal 提供的一些 `Actor` 和 `Component` 类包括**虚函数**形式的事件处理程序。 这一小节将讲述如何通过重写问题中的**虚拟函数**来自定义这些处理程序。创建新类：
![image-20210308154447507](C++学习2.assets/image-20210308154447507.png)

添加代码：

==MyTriggerVolume.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/BoxComponent.h"
#include "MyTriggerVolume.generated.h"

UCLASS()
class TEST1_API AMyTriggerVolume : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AMyTriggerVolume();

	UPROPERTY()
		UBoxComponent* TriggerZone;

	UFUNCTION()
		virtual void NotifyActorBeginOverlap(AActor* OtherActor)override;

	UFUNCTION()
		virtual void NotifyActorEndOverlap(AActor* OtherActor)override;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==MyTriggerVolume.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "MyTriggerVolume.h"
#include "Engine/Engine.h"

// Sets default values
AMyTriggerVolume::AMyTriggerVolume()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	TriggerZone = CreateDefaultSubobject<UBoxComponent>("TriggerZone");
	TriggerZone->SetBoxExtent(FVector(200, 200, 100));
}

void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s entered me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);
}

void AMyTriggerVolume::NotifyActorEndOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s left me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);
}

// Called when the game starts or when spawned
void AMyTriggerVolume::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AMyTriggerVolume::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

运行结果如下：

![image-20210308155714943](C++学习2.assets/image-20210308155714943.png)

在这个例子中，我们首先声明一个` UPROPERTY` 来保存对组件子对象的引用。 

然后创建两个 UFUNCTION 声明。 这些被标记为虚拟和重写，以便编译器理解我们想要替换父实现，并且我们的函数实现可以依次替换。

在对象的构造函数中，我们使用 CreateDefaultSubobject 函数创建子对象。 然后，我们通过 SetBoxExtent 函数使用一个分别包含 x、 y 和 z 大小的 FVector 来设置盒子的区段(大小)。

在函数的实现中，我们从一些预设的文本创建一个 FString，并使用 FString: : Printf 函数替换一些数据参数。 注意，Actor-GetName ()函数也返回一个 FString，并在传递到 FString: : Printf 之前使用 * 操作符解除引用。 不这样做会导致错误。

然后将这个 FString 传递给全局引擎函数 ==AddOnScreenDebugMessage==，以在屏幕上显示这些信息。

方法的第一个参数告诉引擎允许重复字符串，第二个参数是以秒为单位显示消息的时间长度，第三个参数是颜色，第四个参数是要打印的实际字符串。 尽管可能不会创建一个额外的变量，而只是将信息放在函数调用中，但这会使代码更难阅读。

现在，当Actor的某个组件与其他组件重叠时，它的 UpdateOverlapsfunction 将调用NotifyActorBeginOverlap，虚拟函数调度将调用我们的定制实现。



## 创建绑定到UFUNCTION的代理

指针是一个强大的工具，因为我们能够在运行时分配它们，并可以改变它们在内存中指向的位置。 除了标准类型之外，我们还可以创建**指向函数的指针**，但是这些原始函数指针不适合使用，原因有很多。==代理是一个更安全的函数指针版本==，它使我们能够灵活地调用函数，而不必知道哪个函数被赋值，直到被调用的那一刻。 这种灵活性是选择代理而非静态函数的主要原因之一。 这个例子将会讲述如何将 `UFUNCTION` 关联到代理，以便在执行代理时调用该代理。

我们将使用到上一个例子中创建的`MyTriggerVolume`，和Demo中已有的`InventoryGameMode`来进行该例子的讲解：

首先创建新类：
![image-20210308160329396](C++学习2.assets/image-20210308160329396.png)



==MyTriggerVolume.cpp==

```c++
void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s entered me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);

	//Call our Delegate
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate.ExecuteIfBound();
		}
	}
}
```

==InventoryGameMode.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "InventoryCharacter.h"
#include "InventoryGameMode.generated.h"

DECLARE_DELEGATE(FStandardDelegateSignature)
/**
 * 
 */
UCLASS()
class TEST1_API AInventoryGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
public:
	AInventoryGameMode();

	FStandardDelegateSignature MyStandardDelegate;
};

```

==DelegateListener.h==

```c

	UFUNCTION()
		void EnableLight();

	UPROPERTY()
		UPointLightComponent* PointLight;

```

==DelegateListener.cpp==

```c
// Fill out your copyright notice in the Description page of Project Settings.


#include "DelegateListener.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/GameModeBase.h"
#include "InventoryGameMode.h"


// Sets default values
ADelegateListener::ADelegateListener()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	PointLight = CreateDefaultSubobject<UPointLightComponent>("PointLight");

	RootComponent = PointLight;

	PointLight->SetVisibility(false);

	PointLight->SetLightColor(FLinearColor::Blue);

}

void ADelegateListener::EnableLight()
{
	PointLight->SetVisibility(true);
}

// Called when the game starts or when spawned
void ADelegateListener::BeginPlay()
{
	Super::BeginPlay();

	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate.BindUObject(this, &ADelegateListener::EnableLight);
		}
	}
	
}


// Called every frame
void ADelegateListener::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

`委托`：

![image-20210308164528198](C++学习2.assets/image-20210308164528198.png)



## 注销代理

我们使用代理来处理事件时，有时需要**删除绑定**。 这就像设置一个函数指针对象到` nullptr`，这样它就不再引用已经被删除的对象。上一例子中，`DelegateListener`对EndPlay进行重写代码如下：

 ==DelegateListener.h==

```c++
virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
```

==DelegateListener.cpp==

```c++
void ADelegateListener::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate->Unbind();
		}
	}
}
```

这样可以做到当`Actor`销毁时代理自动注销。

总结：

这个例子结合了本章到目前为止的两个以前的例子。 我们重写 `EndPlay`，这是一个实现为虚函数的事件，这样我们就可以在 `DelegateListener` 销毁后执行代码。 如果没有这样做，代理就会像指针一样晃动，在 DelegateListener 销毁后使其处于无效状态。 使用 BindUObject ()有助于避免大多数这类情况，只有少数不幸的计时情况可能会导致对对象的调用被标记为销毁。 即使在使用 BindUObject ()时，手动解除代理绑定仍然是一个很好的习惯，因为当这些计时错误导致 bug 时，几乎不用去猜测是否是他们的锅。



## 创建接受输入参数的代理

前面例子主要是没有接受任何输入参数的代理，这个例子会讲解如何更改代理的签名让其接受某些输入。我们还是使用上面例子中的`GameMode`

创建一个新类：
![image-20210309115248947](C++学习2.assets/image-20210309115248947.png)

添加代码：

==MyTriggerVolume.cpp==

```c++
void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s entered me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);

	//Call our Delegate
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate.ExecuteIfBound();

			auto Color = FLinearColor(1, 0, 0, 1);
			MyGameMode->MyParameterDelegate.ExecuteIfBound(Color);
		}
	}
}
```

==InventoryGameMode.h==

```c++
DECLARE_DELEGATE(FStandardDelegateSignature)
DECLARE_DELEGATE_OneParam(FParamDelegateSignature, FLinearColor)
/**
 * 
 */
UCLASS()
class NEWTUTORIALPROJECT_API AInventoryGameMode : public AGameModeBase
{
    GENERATED_BODY()
public:
    AInventoryGameMode();
    
    FStandardDelegateSignature MyStandardDelegate;
    
    FParamDelegateSignature MyParameterDelegate;
};
```

==ParamDelegateListener.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/PointLightComponent.h"
#include "ParamDelegateListener.generated.h"

UCLASS()
class TEST1_API AParamDelegateListener : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AParamDelegateListener();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	UFUNCTION()
		void SetLightColor(FLinearColor LightColor);

	UPROPERTY()
		UPointLightComponent* PointLight;

	UFUNCTION()
		virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

};
```

==ParamDelegateListener.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "ParamDelegateListener.h"
#include "Kismet/GameplayStatics.h"
#include "InventoryGameMode.h"

// Sets default values
AParamDelegateListener::AParamDelegateListener()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	PointLight = CreateDefaultSubobject<UPointLightComponent>("PointLight");
	RootComponent = PointLight;

}

// Called when the game starts or when spawned
void AParamDelegateListener::BeginPlay()
{
	Super::BeginPlay();
	
	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);

		if (MyGameMode != nullptr)
		{
			MyGameMode->MyParameterDelegate.BindUObject(this, &AParamDelegateListener::SetLightColor);
		}

	}
}

// Called every frame
void AParamDelegateListener::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void AParamDelegateListener::SetLightColor(FLinearColor LightColor)
{
	PointLight->SetLightColor(LightColor);
}

void AParamDelegateListener::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);

		if (MyGameMode != nullptr)
		{
			MyGameMode->MyParameterDelegate.Unbind();
        }
	}
}
```

编译完成后将ParamDelegateListener拖拽到场景中：
![image-20210309123041237](C++学习2.assets/image-20210309123041237.png)

新的代理签名使用稍微不同的宏进行声明。 注意 `DECLARE delegate OneParam` 结尾的 OneParam 后缀。 

我们还需要指定参数的类型。 就像我们创建一个没有参数的代理一样，我们可以创建一个代理实例作为 GameMode 类的成员。然后，我们创建一个新类型的 `DelegateListener`: 它期望将一个参数传递到它绑定到代理的函数中。 当我们为代理调用 ExecuteIfBound ()方法时，我们需要传入将插入到函数参数中的值。

在我们绑定的函数内部，我们使用参数来设置光线的颜色。 这意味着 `TriggerVolume` 不需要知道关于 `ParamDelegateListener` 的任何信息就可以调用它上面的函数。该代理允许我们最小化两个类之间的耦合。


## 使用代理绑定传递有效负载数据

我们将上一例子中的代码进行一些小修改：

```c++
// Called when the game starts or when spawned
void AParamDelegateListener::BeginPlay()
{
	Super::BeginPlay();
	
	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);

		if (MyGameMode != nullptr)
		{
			MyGameMode->MyParameterDelegate.BindUObject(this, &AParamDelegateListener::SetLightColor,false);
		}

	}
}

// Called every frame
void AParamDelegateListener::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

void AParamDelegateListener::SetLightColor(FLinearColor LightColor, bool EnableLight)
{
	PointLight->SetLightColor(LightColor);
	PointLight->SetVisibility(EnableLight);
}
```

![image-20210309123924977](C++学习2.assets/image-20210309123924977.png)

当我们将函数绑定到代理时，我们指定了一些额外的数据（在这种情况下，布尔值为 false）。 我们可以以这种方式传递多达四个“ ==payload==”变量。 在所使用的 DECLARE delegate * 宏中声明任何参数后，它们将应用于函数。

我们更改代理的函数签名，以便它能够接受额外的参数。

在函数内部，我们使用额外的参数来打开或关闭灯光，具体取决于编译时的值为 true 或 false。

我们不需要更改对 ExecuteIfBound 的调用: 代理系统自动应用参数，这些参数首先通过 ExecuteIfBound 传入。 然后，它应用任何有效负载参数，这些参数始终在调用 BindUObject 的函数引用之后指定。


## 创建多播代理

到目前为止，我们在本章中使用的**标准代理**本质上是**函数指针**：它们允许您对一个特定的**对象实例**调用一个特定的函数。 ==多播代理==是函数指针的集合，每个指针都可能位于不同的对象上，所有这些指针都将在广播代理时调用。本例子之前我们已经处理通过**虚函数**实现的事件，知道了如何创建` TriggerVolume` ，本例将它用于**广播多播代理**。

创建新类：
![image-20210309124357872](C++学习2.assets/image-20210309124357872.png)

==InventoryGameMode.h==

```c++
DECLARE_DELEGATE(FStandardDelegateSignature)
DECLARE_DELEGATE_OneParam(FParamDelegateSignature,FLinearColor)
DECLARE_MULTICAST_DELEGATE(FMulticastDelegateSignature)
/**
 * 
 */
UCLASS()
class TEST1_API AInventoryGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
public:
	AInventoryGameMode();

	FStandardDelegateSignature MyStandardDelegate;

	FParamDelegateSignature MyParameterDelegate;

	FMulticastDelegateSignature MyMulticastDelegate;
};

```

==MyTriggerVolume.cpp==

```c++
if (TheWorld != nullptr)
{
    AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
    AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
    if (MyGameMode != nullptr)
    {
        MyGameMode->MyStandardDelegate.ExecuteIfBound();

        auto Color = FLinearColor(1, 0, 0, 1);
        MyGameMode->MyParameterDelegate.ExecuteIfBound(Color);

        MyGameMode->MyMulticastDelegate.Broadcast();
	}
}
```

==MulticastDelegateListener.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/PointLightComponent.h"
#include "MulticastDelegateListener.generated.h"

UCLASS()
class TEST1_API AMulticastDelegateListener : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AMulticastDelegateListener();

	UFUNCTION()
		void Togglelight();

	UFUNCTION()
		virtual void EndPlay(const EEndPlayReason::Type EndPlayReason)override;

	UPROPERTY()
		UPointLightComponent* PointLight;

	FDelegateHandle MyDelegateHandle;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==MulticastDelegateListener.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "MulticastDelegateListener.h"
#include "Kismet/GameplayStatics.h"
#include "InventoryGameMode.h"

// Sets default values
AMulticastDelegateListener::AMulticastDelegateListener()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	PointLight = CreateDefaultSubobject<UPointLightComponent>("Pointlight");
	RootComponent = PointLight;

}

void AMulticastDelegateListener::Togglelight()
{
	PointLight->ToggleVisibility();
}

void AMulticastDelegateListener::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);

		if (MyGameMode != nullptr)
		{
			MyGameMode->MyMulticastDelegate.Remove(MyDelegateHandle);
		}
	}
}


// Called when the game starts or when spawned
void AMulticastDelegateListener::BeginPlay()
{
	Super::BeginPlay();
	
	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);

		if (MyGameMode != nullptr)
		{
			MyDelegateHandle = MyGameMode->MyMulticastDelegate.AddUObject(this, &AMulticastDelegateListener::Togglelight);
		}

	}
}

// Called every frame
void AMulticastDelegateListener::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

编译后在编辑器中将4个MultiCastDelegateListener拖拽到创建中：角色进入触发体后四个灯同时灭掉了；角色出来触发体再重新进去四个灯又同时亮了：
![image-20210309131001167](C++学习2.assets/image-20210309131001167.png)

以下做一个小验证，将前面例子中的蓝灯再复制一个，运行程序让角色走进触发体中：

![image-20210309131030606](C++学习2.assets/image-20210309131030606.png)

可以看到后来复制出来的才有效果，这个验证说明，这个**非多播代理**只有**最后一个绑定的代理的对象**才能绑定成功，出现新的绑定，之前的绑定会被作废。

------

正如我们可能期望的那样，代理类型需要显式声明为多播代理，而不是标准的单绑定代理。 我们的新 Listener 类与最初的 DelegateListener 非常相似。 主要的区别是，我们需要在` FDelegateHandle` 中存储对代理实例的引用。

当参与者被销毁时，我们使用存储的 FDelegateHandle 作为 Remove ()的参数，从绑定到代理的函数列表中安全地删除自己。

`Broadcast ()`函数是` ExecuteIfBound ()`的==多播等价物==。 与标准代理不同，不需要事先检查代理是否绑定，或者是否使用诸如 ExecuteIfBound 之类的调用进行绑定。` Broadcast ()`是安全的，可以运行，不管绑定了多少个函数，甚至不绑定任何函数。

当我们在场景中有多个多播监听器实例时，它们各自向 GameMode 中实现的多播代理注册。 然后，当 TriggerVolume  进入一个角色时，它广播该代理，并通知每个监听器，使其切换相关点灯的可见性。

多播代理可以采用与标准代理完全相同的方式接受参数。



## 创建自定义事件

自定义代理非常有用，但是它们的一个局限性是：可以由**其他第三方类**在外部广播；也就是说，它们的 `execute / broadcast` 方法是可公开访问的。

有时，我们可能需要一个代理，该代理可由**其他类**在外部**分配**，但只能由**包含它们的类**广播。 这是事件的主要目的。

这一小节，还是基于前面的`GameMode`和`MyTriggerVolume`来进行。创建新类：
![image-20210309131848885](C++学习2.assets/image-20210309131848885.png)

添加代码:

==MyTriggerVolume.h==

```c++
DECLARE_EVENT(AMyTriggerVolume, FPlayerEntered)

UCLASS()
class TEST1_API AMyTriggerVolume : public AActor
{
......
	FPlayerEntered OnPlayerEntered;
......
```

==MyTriggerVolume.cpp==

```c++
...
MyGameMode->MyMulticastDelegate.Broadcast();
OnPlayerEntered.Broadcast();
...
```

==TriggerVolEventListener.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "MyTriggerVolume.h"
#include "Components/PointLightComponent.h"
#include "TriggerVolEventListener.generated.h"

UCLASS()
class TEST1_API ATriggerVolEventListener : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ATriggerVolEventListener();

	UPROPERTY()
		UPointLightComponent* PointLight;

	UPROPERTY(EditAnywhere)
		AMyTriggerVolume* TriggerEventSource;

	UFUNCTION()
		void OnTriggerEvent();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==TriggerVolEventListener.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "TriggerVolEventListener.h"

// Sets default values
ATriggerVolEventListener::ATriggerVolEventListener()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	PointLight = CreateDefaultSubobject<UPointLightComponent>("PointlightX");
	RootComponent = PointLight;
}

ATriggerVolEventListener::OnTriggerEvent()
{
	PointLight->SetLightColor(FLinearColor(0, 1, 0, 1));
}

// Called when the game starts or when spawned
void ATriggerVolEventListener::BeginPlay()
{
	Super::BeginPlay();

	if (TriggerEventSource != nullptr)
	{
		TriggerEventSource->OnPlayerEntered.AddUObject(this, &ATriggerVolEventListener::OnTriggerEvent);
	}
	
}

```

编译完成后。在编辑器中我们拖拽一个`TriggerVolEventListener`到场景中，并且选取`MyTriggerVolume`。运行程序后，角色进去触发体后，`TriggerVolEventListener`中的灯就亮起来了。

![image-20210309133947645](C++学习2.assets/image-20210309133947645.png)

与所有其他类型的**代理**一样，==事件==需要它们自己的**特殊宏函数**。 第一个参数是要将事件实现到的==类==。 这将是唯一能够调用 `Broadcast ()`的类，因此要确保它是正确的类。 第二个参数是新事件函数签名的类型名称。 我们将这种类型的实例添加到类中。 **虚幻文档**建议把` On<x>` 作为一个**变数命名原则**。

![image-20210309134106306](C++学习2.assets/image-20210309134106306.png)

当某些内容与我们的 TriggerVolume 重叠时，我们在自己的事件实例上调用 Broadcast ()。 在新类中，我们创建一个点光源作为被触发事件的视觉表示。

我们还创建了一个指向 `TriggerVolume` 的指针来监听事件。 我们将 `UPROPERTY` 标记为 `EditAnywhere`，因为这允许我们在编辑器中设置它，而不必使用 GetAllActorsOfClass 或其他方法通过编程获取引用。

最后一个是我们的事件处理程序，用于当有东西进入 TriggerVolume 时进行处理。 我们像往常一样在构造函数中创建和初始化点光源。 当游戏启动时，监听器检查 TriggerVolume 引用是否有效，然后将 OnTriggerEvent 函数绑定到 TriggerVolume 事件。 在 OnTriggerEvent 中，我们将灯的颜色更改为绿色。 当某个东西进入 TriggerVolume 时，它会导致 TriggerVolume 在其自己的事件上调用广播。 然后调用我们的 TriggerVolEventListener 的绑定方法，改变灯的颜色。


## 创建一个钟表盘的时间处理器

这个例子将会讲述如何使用前面例子中引入的概念来创建一个`Actor`，告知**其他Actor**游戏中的时间流逝。

创建新类：

![image-20210309134508574](C++学习2.assets/image-20210309134508574.png)


![image-20210309134553662](C++学习2.assets/image-20210309134553662.png)

添加代码：

==TimeOfDayHandler.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "TimeOfDayHandler.generated.h"

DECLARE_MULTICAST_DELEGATE_TwoParams(FOnTimeChangedSignature,int32,int32)

UCLASS()
class TEST1_API ATimeOfDayHandler : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ATimeOfDayHandler();

	FOnTimeChangedSignature OnTimeChanged;

	UPROPERTY()
		int32 TimeScale;
	UPROPERTY()
		int32 Hours;
	UPROPERTY()
		int32 Minutes;
	UPROPERTY()
		float ElapsedSeconds;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};

```

==TimeOfDayHandler.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "TimeOfDayHandler.h"

// Sets default values
ATimeOfDayHandler::ATimeOfDayHandler()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	TimeScale = 0;
	Hours = 0;
	Minutes = 0;
	ElapsedSeconds = 0;
}

// Called when the game starts or when spawned
void ATimeOfDayHandler::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void ATimeOfDayHandler::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	ElapsedSeconds += (DeltaTime * TimeScale);
	if (ElapsedSeconds > 60)
	{
		ElapsedSeconds -= 60;
		Minutes++;

		if (Minutes > 60)
		{
			Hours++;
			Minutes -= 60;
		}

		OnTimeChanged.Broadcast(Hours, Minutes);
	}
}
```

==Clock.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/StaticMeshComponent.h"
#include "Components/SceneComponent.h"
#include "Clock.generated.h"

UCLASS()
class TEST1_API AClock : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AClock();

	UPROPERTY()
		USceneComponent* RootSceneComponent;

	UPROPERTY()
		UStaticMeshComponent* ClockFace;

	UPROPERTY()
		USceneComponent* HourHandle;

	UPROPERTY()
		UStaticMeshComponent* HourHand;

	UPROPERTY()
		USceneComponent* MinuteHandle;

	UPROPERTY()
		UStaticMeshComponent* MinuteHand;

	UFUNCTION()
		void TimeChanged(int32 Hours, int32 Minutes);

	FDelegateHandle MyDelegateHandle;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==Clock.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "Clock.h"
#include "Kismet/GameplayStatics.h"
#include "TimeOfDayHandler.h"

// Sets default values
AClock::AClock()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	RootSceneComponent = CreateDefaultSubobject<USceneComponent>("RootSceneComponent");
	ClockFace = CreateDefaultSubobject<UStaticMeshComponent>("ClockFace");
	
	HourHandle = CreateDefaultSubobject<USceneComponent>("HourHandle");
	HourHand = CreateDefaultSubobject<UStaticMeshComponent>("HourHand");

	MinuteHandle = CreateDefaultSubobject<USceneComponent>("MinuteHandle");
	MinuteHand = CreateDefaultSubobject<UStaticMeshComponent>("MinuteHand");

	auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'"));

	if (MeshAsset.Object != nullptr)
	{
		ClockFace->SetStaticMesh(MeshAsset.Object);
		HourHand->SetStaticMesh(MeshAsset.Object);
		MinuteHand->SetStaticMesh(MeshAsset.Object);
	}

	RootComponent = RootSceneComponent;

	HourHand->AttachToComponent(HourHandle, FAttachmentTransformRules::KeepRelativeTransform);

	MinuteHand->AttachToComponent(MinuteHandle, FAttachmentTransformRules::KeepRelativeTransform);

	HourHandle->AttachToComponent(RootSceneComponent, FAttachmentTransformRules::KeepRelativeTransform);

	MinuteHandle->AttachToComponent(RootSceneComponent, FAttachmentTransformRules::KeepRelativeTransform);

	ClockFace->AttachToComponent(RootSceneComponent, FAttachmentTransformRules::KeepRelativeTransform);

	ClockFace->SetRelativeTransform(FTransform(FRotator(90, 0, 0), FVector(10, 0, 0), FVector(2, 2, 0.1)));

	HourHand->SetRelativeTransform(FTransform(FRotator(0, 0, 0), FVector(0, 0, 25), FVector(0.1, 0.1, 0.5)));

	MinuteHand->SetRelativeTransform(FTransform(FRotator(0, 0, 0), FVector(0, 0, 50), FVector(0.1, 0.1, 1)));
}

void AClock::TimeChanged(int32 Hours, int32 Minutes)
{
	HourHandle->SetRelativeRotation(FRotator(0, 0, 30 * Hours));
	MinuteHandle->SetRelativeRotation(FRotator(0, 0, 30 * Minutes));
}

// Called when the game starts or when spawned
void AClock::BeginPlay()
{
	Super::BeginPlay();

	TArray<AActor*> TimeOfDayHandlers;

	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ATimeOfDayHandler::StaticClass(), TimeOfDayHandlers);

	if (TimeOfDayHandlers.Num() != 0)
	{
		auto TimeOfDayHandler = Cast<ATimeOfDayHandler>(TimeOfDayHandlers[0]);
		MyDelegateHandle = TimeOfDayHandler->OnTimeChanged.AddUObject(this, &AClock::TimeChanged);
	}
	
}

// Called every frame
void AClock::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

运行结果：

![image-20210309144611121](C++学习2.assets/image-20210309144611121.png)

`TimeOfdayHandler `包含一个接受两个参数的代理，因此使用了宏的两个变量。 我们的类包含用于存储小时、分钟和秒的变量，以及时间刻度(timeScale) ，它是一个加速因子，用于加快测试目的的时间。 在处理程序的 Tick 函数中，我们根据自上一帧以来经过的时间累计经过的秒数。 我们检查经过的时间是否超过60秒。 如果是，我们减去60，然后增加分钟。 同样的情况也发生在《分钟》上: 如果超过60分钟，我们减去60分钟，然后增加。 如果更新了“分钟”或“时间” ，我们将广播代理，以让订阅该代理的任何对象知道时间已更改。

==时钟Actor==使用一系列场景组件和静态网格，以建立一个网格层次结构，类似于一个时钟面。 在时钟构造函数中，我们在层次结构中生成组件，并设置它们的初始刻度和旋转。 在 BeginPlay 中，使用 `GetAllActorsOfClass ()`获取所有时间处理程序。 如果至少有一个 TimeOfDayHandler，则时钟访问第一个，并订阅其 TimeChanged 事件。 当时间改变事件触发时，时钟会根据当前时间设置的小时分钟数，转动时针和分针。



## 创建一个重新生成的拾取道具

这个例子将会讲述如何创建一个**拾取道具**，它会在一定的时间后重生，适合作为第一人称射击游戏的弹药或者其他**可拾取道具**

首先，创建新类：
![image-20210309144756205](C++学习2.assets/image-20210309144756205.png)

![image-20210309144853796](C++学习2.assets/image-20210309144853796.png)

添加代码：

==Pickup.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GameFramework/RotatingMovementComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Pickup.generated.h"

DECLARE_DELEGATE(FPickedupEventSignature)
UCLASS()
class TEST1_API APickup : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	APickup();

	virtual void NotifyActorBeginOverlap(AActor* OtherActor)override;

	UPROPERTY()
		UStaticMeshComponent* MyMesh;

	UPROPERTY()
		URotatingMovementComponent* RotatingComponent;

	FPickedupEventSignature OnPickedUp;
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==Pickup.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "Pickup.h"

// Sets default values
APickup::APickup()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	MyMesh = CreateDefaultSubobject<UStaticMeshComponent>("MyMesh");

	RotatingComponent = CreateDefaultSubobject<URotatingMovementComponent>("RotatingC");

	auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));

	if(MeshAsset.Object!= nullptr)
	{
		MyMesh->SetStaticMesh(MeshAsset.Object);
	}

	MyMesh->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
	RotatingComponent->RotationRate = FRotator(10, 0, 10);
}

void APickup::NotifyActorBeginOverlap(AActor* OtherActor)
{
	OnPickedUp.ExecuteIfBound();
}

// Called when the game starts or when spawned
void APickup::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void APickup::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

==PickupSpawner.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "GameFramework/Actor.h"
#include "Components/SceneComponent.h"
#include "PickupSpawner.generated.h"

UCLASS()
class TEST1_API APickupSpawner : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	APickupSpawner();

	UPROPERTY()
		USceneComponent* SpawnLocation;

	UFUNCTION()
		void PickupCollected();

	UFUNCTION()
		void SpawnPickup();

	UPROPERTY()
		APickup* currentPickup;

	FTimerHandle MyTimer;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==PickupSpawner.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "PickupSpawner.h"
#include "Pickup.h"

// Sets default values
APickupSpawner::APickupSpawner()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	SpawnLocation = CreateDefaultSubobject<USceneComponent>("SpawnLocation");
}

void APickupSpawner::PickupCollected()
{
	GetWorld()->GetTimerManager().SetTimer(MyTimer, this, &APickupSpawner::SpawnPickup, 10, false);
	currentPickup->OnPickedUp.Unbind();
	currentPickup->Destroy();
}

void APickupSpawner::SpawnPickup()
{
	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		currentPickup = TheWorld->SpawnActor<APickup>(APickup::StaticClass(), GetTransform());

		currentPickup->OnPickedUp.BindUObject(this, &APickupSpawner::PickupCollected);
	}
}


// Called when the game starts or when spawned
void APickupSpawner::BeginPlay()
{
	Super::BeginPlay();
	SpawnPickup();
	
}

// Called every frame
void APickupSpawner::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

```

编译完之后，在编辑器中将PickupSpawner拖拽到场景中，运行之后我们会看到生成了一个Pickup：

![image-20210309165257536](C++学习2.assets/image-20210309165257536.png)

我们将角色移动到Pickup上会发现Pickup被销毁掉，也就是所谓的被拾取：

![image-20210309165318236](C++学习2.assets/image-20210309165318236.png)

等待10s,会发现又生成了一个新的Pickup

![image-20210309165337006](C++学习2.assets/image-20210309165337006.png)


总结：

像往常一样，我们需要在我们的Pickup里面创建一个代理，我们的 Spawner 可以订阅，这样它就知道什么时候玩家拾取Pickup。 Pickup还包含一个**静态网格**作为**视觉表示**，和一个==旋转 / 移动组件==，使网格旋转作为一种方式吸引玩家的注意力。 在 Pickup 构造函数中，我们加载引擎的一个内置网格作为我们的视觉表示。 我们指定网格将与其他物体重叠，然后在 x 轴和 z 轴上将网格的旋转速率设置为每秒10个单位。 当玩家重叠拾取时，它从第一步开始就发射它的 PickedUp 代理。

这个 `PickupSpawner` 使用了一个场景组件来指定在哪里产生Actor。 它有一个这样做的函数，以及一个标记的 UPROPERTY 引用，该引用指向当前产生的拾取。 在 `PickupSpawner` 构造函数中，我们总是将组件初始化。 当游戏开始时，Spawner 运行它的 SpawnPickup 功能。 这个函数生成我们的 Pickup 的一个实例，然后将 APickupSpawner: : PickupCollected 绑定到新实例上的 onpickedp 函数。 它还存储对当前实例的引用。

当 PickupCollected 运行后，玩家已碰到的Pickup，一个计时器创建后重新等待10秒钟后生成Pickup。 现有的绑定到被收集的拾取器的代理被删除，然后Pickup被销毁。 10秒后，计时器启动，再次运行 SpawnActor，这将创建一个新的Pickup。



# 输入与碰撞

## 轴映射-FPS角色的键盘、鼠标和游戏手柄输入

输入映射有两种类型：==轴映射==和==动作映射==。 轴映射是一个输入，你可以按住它一段==延长的时间==来获得它们的效果(例如，按住 w 键来移动玩家) ，而 Action 映射是==一次性的输入==(例如按下 游戏手柄上的 a 按钮或键盘上的空格键来让玩家跳转)。 在本例中，我们将讲述如何设置键盘、鼠标和游戏轴映射输入控件来移动 FPS 角色。

创建新类:
![image-20210309170323879](C++学习2.assets/image-20210309170323879.png)



并且创建一个基于`Warrior`的蓝图类 ，和一个新的GameMode：

![image-20210309170617675](C++学习2.assets/image-20210309170617675.png)

将GameMode_BP作为目前的GameMode：

![image-20210309170725282](C++学习2.assets/image-20210309170725282.png)

设置GameMode_BP属性：


![image-20210309170823822](C++学习2.assets/image-20210309170823822.png)

然后打开项目设置的Input,我们可以看到有我们之前设置的按键映射，这些我们不需要理会，我们往后添加这次新增的映射：

![image-20210309171848988](C++学习2.assets/image-20210309171848988.png)

在C++中添加代码：

==Warrior.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Warrior.generated.h"

UCLASS()
class TEST1_API AWarrior : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWarrior();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	//移动函数
	UFUNCTION()
		void Forward(float amount);

	UFUNCTION()
		void Back(float amount);

	UFUNCTION()
		void Right(float amount);

	UFUNCTION()
		void Left(float amount);
};
```

==Warrior.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "Warrior.h"

// Sets default values
AWarrior::AWarrior()
{
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}

// Called when the game starts or when spawned
void AWarrior::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AWarrior::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

// Called to bind functionality to input
void AWarrior::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	check(PlayerInputComponent);
	PlayerInputComponent->BindAxis("Forward", this, &AWarrior::Forward);
	PlayerInputComponent->BindAxis("Back", this, &AWarrior::Back);
	PlayerInputComponent->BindAxis("Right", this, &AWarrior::Right);
	PlayerInputComponent->BindAxis("Left", this, &AWarrior::Left);
}

void AWarrior::Forward(float amount)
{
	AddMovementInput(GetActorForwardVector(), amount);
}

void AWarrior::Back(float amount)
{
	AddMovementInput(-GetActorForwardVector(), amount);
}

void AWarrior::Right(float amount)
{
	AddMovementInput(GetActorRightVector(), amount);
}

void AWarrior::Left(float amount)
{
	AddMovementInput(-GetActorRightVector(), amount);
}

```

编译完之后运行我们就可以使用WASD或者是游戏手柄的方向键来控制角色的移动了。

UE4引擎允许将**输入事件**直接连接到`C++ 函数调用`。 输入事件调用的函数是某个类的成员函数。 在前面的例子中，我们将按下 w 键指向 `warrior: : Forward C++ 函数`。 调用 AWarrior: : Forward   的实例是路由控制器输入的实例。 这是由 GameMode 类中作为玩家角色的对象设置控制的。


