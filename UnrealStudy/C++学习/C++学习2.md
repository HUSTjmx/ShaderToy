# UE4中处理事件和代理

## 处理通过虚函数实现的事件

Unreal 提供的一些 `Actor` 和 `Component` 类包括**虚函数**形式的事件处理程序。 这一小节将讲述如何通过重写问题中的**虚拟函数**来自定义这些处理程序。创建新类：
![image-20210308154447507](C++学习2.assets/image-20210308154447507.png)

添加代码：

==MyTriggerVolume.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/BoxComponent.h"
#include "MyTriggerVolume.generated.h"

UCLASS()
class TEST1_API AMyTriggerVolume : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	AMyTriggerVolume();

	UPROPERTY()
		UBoxComponent* TriggerZone;

	UFUNCTION()
		virtual void NotifyActorBeginOverlap(AActor* OtherActor)override;

	UFUNCTION()
		virtual void NotifyActorEndOverlap(AActor* OtherActor)override;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

};
```

==MyTriggerVolume.cpp==

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include "MyTriggerVolume.h"
#include "Engine/Engine.h"

// Sets default values
AMyTriggerVolume::AMyTriggerVolume()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	TriggerZone = CreateDefaultSubobject<UBoxComponent>("TriggerZone");
	TriggerZone->SetBoxExtent(FVector(200, 200, 100));
}

void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s entered me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);
}

void AMyTriggerVolume::NotifyActorEndOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s left me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);
}

// Called when the game starts or when spawned
void AMyTriggerVolume::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AMyTriggerVolume::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

运行结果如下：

![image-20210308155714943](C++学习2.assets/image-20210308155714943.png)

在这个例子中，我们首先声明一个` UPROPERTY` 来保存对组件子对象的引用。 

然后创建两个 UFUNCTION 声明。 这些被标记为虚拟和重写，以便编译器理解我们想要替换父实现，并且我们的函数实现可以依次替换。

在对象的构造函数中，我们使用 CreateDefaultSubobject 函数创建子对象。 然后，我们通过 SetBoxExtent 函数使用一个分别包含 x、 y 和 z 大小的 FVector 来设置盒子的区段(大小)。

在函数的实现中，我们从一些预设的文本创建一个 FString，并使用 FString: : Printf 函数替换一些数据参数。 注意，Actor-GetName ()函数也返回一个 FString，并在传递到 FString: : Printf 之前使用 * 操作符解除引用。 不这样做会导致错误。

然后将这个 FString 传递给全局引擎函数 ==AddOnScreenDebugMessage==，以在屏幕上显示这些信息。

方法的第一个参数告诉引擎允许重复字符串，第二个参数是以秒为单位显示消息的时间长度，第三个参数是颜色，第四个参数是要打印的实际字符串。 尽管可能不会创建一个额外的变量，而只是将信息放在函数调用中，但这会使代码更难阅读。

现在，当Actor的某个组件与其他组件重叠时，它的 UpdateOverlapsfunction 将调用NotifyActorBeginOverlap，虚拟函数调度将调用我们的定制实现。



## 创建绑定到UFUNCTION的代理

指针是一个强大的工具，因为我们能够在运行时分配它们，并可以改变它们在内存中指向的位置。 除了标准类型之外，我们还可以创建**指向函数的指针**，但是这些原始函数指针不适合使用，原因有很多。==代理是一个更安全的函数指针版本==，它使我们能够灵活地调用函数，而不必知道哪个函数被赋值，直到被调用的那一刻。 这种灵活性是选择代理而非静态函数的主要原因之一。 这个例子将会讲述如何将 `UFUNCTION` 关联到代理，以便在执行代理时调用该代理。

我们将使用到上一个例子中创建的`MyTriggerVolume`，和Demo中已有的`InventoryGameMode`来进行该例子的讲解：

首先创建新类：
![image-20210308160329396](C++学习2.assets/image-20210308160329396.png)



==MyTriggerVolume.cpp==

```c++
void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
	auto Messsage = FString::Printf(TEXT("%s entered me"), *(OtherActor->GetName()));
	GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, Messsage);

	//Call our Delegate
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate.ExecuteIfBound();
		}
	}
}
```

==InventoryGameMode.h==

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "InventoryCharacter.h"
#include "InventoryGameMode.generated.h"

DECLARE_DELEGATE(FStandardDelegateSignature)
/**
 * 
 */
UCLASS()
class TEST1_API AInventoryGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
public:
	AInventoryGameMode();

	FStandardDelegateSignature MyStandardDelegate;
};

```

==DelegateListener.h==

```c

	UFUNCTION()
		void EnableLight();

	UPROPERTY()
		UPointLightComponent* PointLight;

```

==DelegateListener.cpp==

```c
// Fill out your copyright notice in the Description page of Project Settings.


#include "DelegateListener.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/GameModeBase.h"
#include "InventoryGameMode.h"


// Sets default values
ADelegateListener::ADelegateListener()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	PointLight = CreateDefaultSubobject<UPointLightComponent>("PointLight");

	RootComponent = PointLight;

	PointLight->SetVisibility(false);

	PointLight->SetLightColor(FLinearColor::Blue);

}

void ADelegateListener::EnableLight()
{
	PointLight->SetVisibility(true);
}

// Called when the game starts or when spawned
void ADelegateListener::BeginPlay()
{
	Super::BeginPlay();

	UWorld* TheWorld = GetWorld();
	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate.BindUObject(this, &ADelegateListener::EnableLight);
		}
	}
	
}


// Called every frame
void ADelegateListener::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}
```

`委托`：

![image-20210308164528198](C++学习2.assets/image-20210308164528198.png)



## 注销代理

我们使用代理来处理事件时，有时需要**删除绑定**。 这就像设置一个函数指针对象到` nullptr`，这样它就不再引用已经被删除的对象。上一例子中，`DelegateListener`对EndPlay进行重写代码如下：

 ==DelegateListener.h==

```c++
virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
```

==DelegateListener.cpp==

```c++
void ADelegateListener::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	UWorld* TheWorld = GetWorld();

	if (TheWorld != nullptr)
	{
		AGameModeBase* GameMode = UGameplayStatics::GetGameMode(TheWorld);
		AInventoryGameMode* MyGameMode = Cast<AInventoryGameMode>(GameMode);
		if (MyGameMode != nullptr)
		{
			MyGameMode->MyStandardDelegate->Unbind();
		}
	}
}
```

这样可以做到当`Actor`销毁时代理自动注销。

总结：

这个例子结合了本章到目前为止的两个以前的例子。 我们重写 `EndPlay`，这是一个实现为虚函数的事件，这样我们就可以在 `DelegateListener` 销毁后执行代码。 如果没有这样做，代理就会像指针一样晃动，在 DelegateListener 销毁后使其处于无效状态。 使用 BindUObject ()有助于避免大多数这类情况，只有少数不幸的计时情况可能会导致对对象的调用被标记为销毁。 即使在使用 BindUObject ()时，手动解除代理绑定仍然是一个很好的习惯，因为当这些计时错误导致 bug 时，几乎不用去猜测是否是他们的锅。


