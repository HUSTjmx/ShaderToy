## 1. 利用基础颜色实现扁平化渲染

1. 首先在场景中添加一个后处理体积。

2. 可以选择勾选`无限体积`

    ![image-20210107113728513](后处理实现NPR.assets/image-20210107113728513.png)

3. 设置曝光

    ![image-20210107113814341](后处理实现NPR.assets/image-20210107113814341.png)

4. 风格化渲染不需要运动模糊，关闭运动模糊

    ![image-20210107113909192](后处理实现NPR.assets/image-20210107113909192.png)

5. 新建一个材质，选择其材质域为`后期处理`：

    ![image-20210107114349348](后处理实现NPR.assets/image-20210107114349348.png)

6. 在蓝图界面，新建一个`Scene Texture`节点：

    ![image-20210107114515780](后处理实现NPR.assets/image-20210107114515780.png)

7. 打开其细节面板，可以看到其包含了`G Buffer`：

    ![image-20210107114628821](后处理实现NPR.assets/image-20210107114628821.png)

8. 链接蓝图

    ![image-20210107114949256](后处理实现NPR.assets/image-20210107114949256.png)

9. 选择后期处理材质

    ![image-20210107115015092](后处理实现NPR.assets/image-20210107115015092.png)

10. 效果

    <img src="后处理实现NPR.assets/image-20210107115107114.png" alt="image-20210107115107114" style="zoom:50%;" />

11. 由于==TAA==的实现原理，所以画面会有抖动。解决方法：可以修改系统默认的抗锯齿方式为`FXAA `：

    ![image-20210107115423859](后处理实现NPR.assets/image-20210107115423859.png)

    另外一种解决方法是：修改材质的应用阶段为：`色调映射之前`

    ![image-20210107115709643](后处理实现NPR.assets/image-20210107115709643.png)

    



## 2. 创建多边形描边

1. 新建材质，蓝图如下：

    ![image-20210107130352077](后处理实现NPR.assets/image-20210107130352077.png)

2. 添加进体积，注意顺序，描边材质在首位。

    ![image-20210107130432688](后处理实现NPR.assets/image-20210107130432688.png)

3. 修改蓝图1，进行UV偏移，然后相减

    ![image-20210107131455434](后处理实现NPR.assets/image-20210107131455434.png)

    <img src="后处理实现NPR.assets/image-20210107131621387.png" alt="image-20210107131621387" style="zoom:50%;" />

4. 新建一个`SceneTexture`节点，选择Id为`PostProcessInput0`，代表经过后期处理流程后的未更改的渲染，然后进行插值，

    ![image-20210107133208814](后处理实现NPR.assets/image-20210107133208814.png)

    <img src="后处理实现NPR.assets/image-20210107133233879.png" alt="image-20210107133233879" style="zoom:50%;" />

5. 可以建立一个材质函数`DepthBias`，用来计算指定方向的深度差，这样就不用将此部分重复四遍了

    ![image-20210107135210662](后处理实现NPR.assets/image-20210107135210662.png)

6. 此时，蓝图为：

    ![image-20210107135502074](后处理实现NPR.assets/image-20210107135502074.png)

    ![image-20210107135443723](后处理实现NPR.assets/image-20210107135443723.png)

7. 可以修改描边的颜色，此外，我们需要对混合系数进行`Clamp`：

    ![image-20210107135939538](后处理实现NPR.assets/image-20210107135939538.png)

    ![image-20210107135955163](后处理实现NPR.assets/image-20210107135955163.png)



##  3. 创建法线描边

1. 和上一节一样，建立一个计算指定轴向的法线差的函数`NormalDelta`，

    ![image-20210107141439883](后处理实现NPR.assets/image-20210107141439883.png)

2. 建立蓝图，和上一节类似：

    ![image-20210107141551804](后处理实现NPR.assets/image-20210107141551804.png)

    ![image-20210107141619460](后处理实现NPR.assets/image-20210107141619460.png)

3. 和上一节的技术结合在一起：

    ![image-20210107142338734](后处理实现NPR.assets/image-20210107142338734.png)

    ![image-20210107142359234](后处理实现NPR.assets/image-20210107142359234.png)



## 4. 对描边效果进行最终完善

1. 目前，移动镜头，会有闪烁的`artifacts`，可以通过在`PolyLine`的出口处加上一个简单的乘法进行控制：

    <img src="后处理实现NPR.assets/image-20210107143826362.png" alt="image-20210107143826362" style="zoom:67%;" />

    | 0.2（Lighting Only）                                         | 20（Lighting Only)                                           |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | ![image-20210107143901384](后处理实现NPR.assets/image-20210107143901384.png) | ![image-20210107143922301](后处理实现NPR.assets/image-20210107143922301.png) |

2. 引入`幂节点`，来控制==对比度==

    <img src="后处理实现NPR.assets/image-20210107144356291.png" alt="image-20210107144356291" style="zoom:50%;" />

    | 2                                                            | 20                                                           |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | ![image-20210107144455050](后处理实现NPR.assets/image-20210107144455050.png) | ![image-20210107144430276](后处理实现NPR.assets/image-20210107144430276.png) |

3. 控制==线宽==， 修改函数，新增一个乘法节点和标量输入：

    <img src="后处理实现NPR.assets/image-20210107145938930.png" alt="image-20210107145938930" style="zoom:67%;" />

4. 以上操作可重复用在Normal上

最终蓝图

![image-20210107150217317](后处理实现NPR.assets/image-20210107150217317.png)



## 5. 调整遮罩以用于多边形描边

这节我们主要是学习如何让后处理只对特定对象生效。以基础颜色为例。

1. 修改`SceneTexture`的Id为：==CustomDepth==。引擎会在场景中寻找启动了`自定义深度`的对象，并且它只会渲染这些对象。

    ![image-20210107151055186](后处理实现NPR.assets/image-20210107151055186.png)

2. 在指定物体的细节面板上，勾选对应选项：

    ![image-20210107151234732](后处理实现NPR.assets/image-20210107151234732.png)

3. 设置后处理材质：

    ![image-20210107152652224](后处理实现NPR.assets/image-20210107152652224.png)

4. 简单例子：

    | 蓝图                                                         | 效果                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | <img src="后处理实现NPR.assets/image-20210107152610336.png" alt="image-20210107152610336" style="zoom:80%;" /> | ![image-20210107152623062](后处理实现NPR.assets/image-20210107152623062.png) |

5. 对于在这种情况下:arrow_down:进行==景深==渲染，会产生错误，只需将阶段进一步前提到`半透明之前`，就可以解决。

    | 前                                                           | 后                                                           |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | <img src="后处理实现NPR.assets/image-20210107153029851.png" alt="image-20210107153029851" style="zoom:80%;" /> | ![image-20210107153046146](后处理实现NPR.assets/image-20210107153046146.png) |

6. 结合描边，可以有如下效果：

    ![image-20210107155758320](后处理实现NPR.assets/image-20210107155758320.png)

6. 描边的时候，进行了UV偏移，如果遮罩不进行就会产生一些`Artifacts`，例如：有些地方的描线过于黑粗。为了解决这个问题，我们需要在`Mask`时，对其进行偏移，首先，新建一个函数`CharaterMaskBias`：

    ![image-20210107160825897](后处理实现NPR.assets/image-20210107160825897.png)

7. 依据上诉函数进行修改：

    ![image-20210107162947874](后处理实现NPR.assets/image-20210107162947874.png)

    ![image-20210107163019906](后处理实现NPR.assets/image-20210107163019906.png)



## 6. 从关卡光照创建遮罩

1. 可以通过==后处理输入0==除以==底色==，来得到场景的==光照遮罩==：

    ![image-20210107163956293](后处理实现NPR.assets/image-20210107163956293.png)

2. 效果

    ![image-20210107164035304](后处理实现NPR.assets/image-20210107164035304.png)

    



## 7. 创建明暗区域的控制功能

上一节的输出作为这里的`A`:arrow_down:。​

![image-20210107165839862](后处理实现NPR.assets/image-20210107165839862.png)

同样的，为了不破坏光照效果，可以修改`混合位置`为`半透明之前`。



## 8. 自定义色带

1. 提取光照遮罩。

    ![image-20210107171937632](后处理实现NPR.assets/image-20210107171937632.png)

2. 新建一个`CurveAtlasRowParameter`节点。

    ![image-20210107172111516](后处理实现NPR.assets/image-20210107172111516.png)

3. 此节点需要指定曲线，在`内容`下新建一个`曲线`

    ![image-20210107173326134](后处理实现NPR.assets/image-20210107173326134.png)

4. 此外，我们还需要一个`曲线图集`：

    ![image-20210107174029460](后处理实现NPR.assets/image-20210107174029460.png)

    曲线图集允许我们存储曲线：

    ![image-20210107174159556](后处理实现NPR.assets/image-20210107174159556.png)

5. 进行填充：

    ![image-20210107174305978](后处理实现NPR.assets/image-20210107174305978.png)

6. 测试：

    | 曲线                                                         | 效果                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | ![image-20210107174656651](后处理实现NPR.assets/image-20210107174656651.png) | ![image-20210107174712154](后处理实现NPR.assets/image-20210107174712154.png) |

7. 和底色混合

    | 蓝图                                                         | 效果                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | ![image-20210107175030989](后处理实现NPR.assets/image-20210107175030989.png) | ![image-20210107174956168](后处理实现NPR.assets/image-20210107174956168.png) |

8. 对于NPR而言，色带是不错的选择：

    | 曲线                                                         | 效果                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | ![image-20210107175245158](后处理实现NPR.assets/image-20210107175245158.png) | ![image-20210107175208045](后处理实现NPR.assets/image-20210107175208045.png) |

    



## 9. 利用Sobel实现模糊效果

1. 首先，新建一个基于==底色==的函数，其形式和前几个基本一样，主要是Id变了，以及**减法变成加法**。

    ![image-20210107192238831](后处理实现NPR.assets/image-20210107192238831.png)

2. 建立初步蓝图：

    ![image-20210107192508470](后处理实现NPR.assets/image-20210107192508470.png)

3. 取曝光为==-3==来调暗，效果如下：

    ![image-20210107192700361](后处理实现NPR.assets/image-20210107192700361.png)

4. 另外一种方法：选择`BlurSampleOffsets`

    ![image-20210107192813700](后处理实现NPR.assets/image-20210107192813700.png)



## 10. 实现分色渲染

![image-20210107193846561](后处理实现NPR.assets/image-20210107193846561.png)

提高对比度。通过两种取整节点，来计算模糊后的基础颜色，会产生高对比度、高饱和度，且只有少数几种颜色的图像。

![image-20210107193945770](后处理实现NPR.assets/image-20210107193945770.png)



## 11. 对画面进行上色

1. 我们使用上一节的输出，作为插值系数，简单的进行上色：

    ![image-20210107194733725](后处理实现NPR.assets/image-20210107194733725.png)

    <img src="后处理实现NPR.assets/image-20210107194815501.png" alt="image-20210107194815501" style="zoom:67%;" />





混合使用

![image-20210107195751640](后处理实现NPR.assets/image-20210107195751640.png)

![image-20210107195957924](后处理实现NPR.assets/image-20210107195957924.png)