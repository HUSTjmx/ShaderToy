# 教程1

## 1. 整体架构

1. 首先，我们需要注意的是在编辑材质时，要小心其细节面板的`用法`分栏，我们需要明确其勾选，否则，很有可能导出后**报错**，部分材质无法显示，例如：一般情况下，哪怕没有勾选，UE4也会启动使用**静态光照**的版本。

2. 为什么编译着色器的数量如此惊人？理由和Unity一样，着色器内分支结构的使用会导致大量的**着色器变体**，每一个变体都要进行编译。

3. 大多数情况，我们无需专门去减少变体数量，保持默认设置即可。

4. 如果需要减少，可以修改如下设置：

   ![image-20210102193112096](材质大师教程1.assets/image-20210102193112096.png)

## 2. 性能

1. 对于材质而言，300以内的材质命令数是合理的（PC），但无论什么硬件环境，过千条的命令数都是不合理的。

## 3. PBR

1. 对于大多数情况，我们只需将`金属度`看作布尔值，`高光值`不用修改，默认使用0.5，着重修改粗糙度即可。

## 4. 压缩和内存

1. 之前也说了，UE4的压缩格式是DXTC或BC，而`矢量置换贴图`则是未压缩，同时，不要因为纹理是灰度图，就选择压缩方式中的`灰度`，这是误导。

   > 具体这些格式细节，可以见RTR4读书笔记

2. 密切关注纹理**信息面板**。

   ![image-20210102201520859](材质大师教程1.assets/image-20210102201520859.png)

3. 勾选`延迟压缩`，会停止在纹理导入时进行其他压缩操作，而变为在保存时进行压缩，这方便开发，是个不错的选项。
4. 法线贴图使用的是特殊的BC5压缩方式，只是要R、G通道。只要使用正确的压缩格式，就无需在着色（蓝图）中使用专门的函数来还原B通道。
5. 帧率问题一般和纹理无关。
6. 可以使用`统计数据窗口`来查看纹理内存使用的详细情况。
7. 使用命令：==stat Memory==，进行查看。

## 5. 纹理池

深入了解纹理如何通过流送、多级渐进纹理、纹理池大小等方面管理可用内存。我们将介绍如何在避免内存遭遇瓶颈的情况下将纹理细节最大化。

1. 根据项目需要，使用命令：r.Straming.PoolSize，来修改纹理池大小，因为项目默认值并不大（==2GB==）。

2. 纹理流送是系统决定使用哪张纹理和相应Mip的过程。

3. 进行纹理分组，方便管理

4. ==合并贴图==，本质是将RGB通道中的不同图像进行组合，例如：三个通道存储了三张纹理的$\alpha$通道。

   > 补充知识可见[纹理](..\实时渲染\实时渲染深入探究2.md)

## 6. 渲染目标

1. 在编辑器或渲染时生成的特殊纹理。

2. 其中，部分情况下使用的`SceneCapture`在**反射**一节也提到过。

3. 关于，怎么将程序纹理渲染进一张贴图中：通过算法生成程序材质，通过蓝图将材质应用到==渲染目标==上，最后将其转化为平常使用的**静态纹理**。

   | 相关对象                                              | 蓝图                                                  |
   | ----------------------------------------------------- | ----------------------------------------------------- |
   | ![](材质大师教程1.assets/image-20210102210233417.png) | ![](材质大师教程1.assets/image-20210102210317469.png) |

> 游戏中，所有雪的实现（在雪地走，雪被挤向两侧），都是基于渲染目标