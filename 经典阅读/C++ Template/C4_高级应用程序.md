[toc]



# 高级应用程序

## 1. 类型区分:star:

:one:在某些时候，对于一个模板参数，如果能够知道它究竟是内建类型、指针类型、类类型或者其他类型，将会是非常有用的。在本章接下来的内容里，我们将开发一种==普遍适用的类型模板==，它能够帮助我们判断给定类型的许多属性。

### 1.1 辨别基本类型

:one:首先，让我们开发一个用于辨别**某个类型是否为基本类型**的模板。在缺省情况下，我们一方面假定一个类型不是一个基本类型，另一方面我们为**所有的基本类型**都特化该模板：

```c++
// types/type1.hpp
// 基本模板：一般情况下T不是基本类型 
template <typename T> 
class IsFundaT 
{ 
public: 
    enum{ Yes = 0, No = 1}; 
};

// ⽤于特化基本类型的宏 
#deﬁne MK_FUNDA_TYPE(T)            \ 
template<> class IsFundaT<T> {        \ 
public:                 \ 
    enum{ Yes = 1, No = 0 };        \ 
};

MK_FUNDA_TYPE(void) 
MK_FUNDA_TYPE(bool) 
MK_FUNDA_TYPE(char) 
MK_FUNDA_TYPE(signed char) 
MK_FUNDA_TYPE(unsigned char)
MK_FUNDA_TYPE(wchar_t) 
MK_FUNDA_TYPE(signed short) 
MK_FUNDA_TYPE(unsigned short) 
MK_FUNDA_TYPE(signed int) 
MK_FUNDA_TYPE(unsigned int) 
MK_FUNDA_TYPE(signed long) 
MK_FUNDA_TYPE(unsigned long) 
#if LONGLONG_EXISTS 
    MK_FUNDA_TYPE(signed long long) 
    MK_FUNDA_TYPE(unsigned long long)
#endif // LONGLONG_EXISTS 
MK_FUNDA_TYPE(ﬂoat) 
MK_FUNDA_TYPE(double) 
MK_FUNDA_TYPE(long double) 
#undef MK_FUNDA_TYPE 
```

具体逻辑很简单，如果有什么不懂，就看书。



### 1.2 辨别组合类型

:one:==组合类型==是指一些构造自其他类型的类型。**简单的组合类型**包括：普通类型、指针类型、引用类型和数组类型——它们都是构造自单一的基本类型。同时，**`class`类型和函数类型**也是组合类型，但这些组合类型通常都会涉及到多种类型。在此，我们先考虑**简单的组合类型**；另外，我们还将使用**局部特化**对简单的组合类型进行区分。接下来，我们将定义一个类，用于描述**简单的组合类型**；而**类类型和枚举类型**将留到后面考虑：

```c++
template<typename T> 
class CompoundT 
{     
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, IsFuncT = 0, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef T BottomT; 
    typedef CompoundT<void> ClassT; 
}; 
```

成员类型`BaseT`指的是：用于构造模板参数类型**`T`的直接类型**；而`BottomT`指的是最终去除指针、引用和数组之后的、**用于构造`T`的原始类型**。例如，如果`T`是`int**`，那么`BaseT`将是`int*`，而`BottomT`将会是`int`类型。对于**成员指针类型**，`BaseT`将会是成员的类型，而`ClassT`将会是**成员所属的类的类型**。例如，如果`T`是一个类型为`int(×::*)()`的成员函数指针，那么`BaseT`将会是函数类型`int()`，而`ClassT`的类型则为`X`。如果`T`不是**成员指针类型**，那么`ClassT`将会是将会是`CompoundT<void>`（这个选择并不是必须的，也可以使用一个`noclass`来作为`ClassT`）。

:two:其中，针对**指针和引用**的局部特化是相当直接的：

```c++
// types/type3.hpp 
template<typename T>
class CompoundT<T&> 
{   // 针对引用的局部特化 
public: 
    enum { IsPtrT = 0, IsRefT = 1, IsArrayT = 0, IsFuncT = 0, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef typename CompoundT<T>::BottomT BottomT; 
    typedef CompoundT<void> ClassT; 
}; 

template<typename T> 
class CompoundT<T*> 
{   // 针对指针的局部特化 
public: 
    enum { IsPtrT = 1, IsRefT = 0, IsArrayT = 0, IsFuncT = 0, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef typename CompoundT<T>::BottomT BottomT; 
    typedef CompoundT<void> ClassT; 
}; 
```

:three:对于**成员指针和数组**，我们可能会使用同样的技术来处理。但是，在下面的代码中我们将发现，与基本模板相比，**这些局部特化**将会涉及到更多的模板参数：

```c++
// types/type4.hpp 
#include <stddef.h> 

template<typename T, size_t N> 
class CompoundT <T[N]> 
{  // 针对数组的局部特化 
public:
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 1, IsFuncT = 0, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef typename CompoundT<T>::BottomT BottomT; 
    typedef CompoundT<void> ClassT; 
}; 

template<typename T> 
class CompoundT <T[]> 
{  // 针对空数组的局部特化
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 1, IsFuncT = 0, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef typename CompoundT<T>::BottomT BottomT; 
    typedef CompoundT<void> ClassT; 
}; 

template<typename T, typename C> 
class CompoundT <T C::*> 
{ // 针对成员指针的局部特化 
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, IsFuncT = 0, IsPtrMemT = 1 }; 
    
    typedef T BaseT; 
    typedef typename CompoundT<T>::BottomT BottomT; 
    typedef C ClassT; 
};
```

细心的读者可能会发现：成员`BottomT`的定义要求根据某种类型`T`，对`CompoundT`模板进行==递归实例化==；当`T`不再是**组合类型**的时候，该递归也就结束了。



### 1.3 辨别函数类型

:one:==函数类型更加难以辨别==，原因在于：**参数的数量**可以是任意的，而且就算借助于模板，也不存在一种有限的语法构造，能够完整地描述**参数个数的不确定性**。

另一方面，存在一种部分解决这个问题的方法：以一个**给定整数**为模板参数**个数的上限**，为不同模板实参列表所对应的函数，提供不同的**局部特化**。其中，最简单的几个局部特化大概如下所示：

```c++
// types/type5.hpp 
template<typename R> 
class CompoundT<R()> 
{ 
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, IsFuncT = 1, IsPtrMemT = 0 }; 
    
    typedef R BaseT(); 
    typedef R BottomT(); 
    typedef CompoundT<void> ClassT; 
};

template<typename R, typename P1> 
class CompoundT<R(P1)> 
{
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, IsFuncT = 1, IsPtrMemT = 0 }; 
    
    typedef R BaseT(P1); 
    typedef R BottomT(P1); 
    typedef CompoundT<void> ClassT;
}; 

template<typename R, typename P1> 
class CompoundT<R(P1, ...)> 
{ 
public: 
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, IsFuncT = 1, IsPtrMemT = 0 }; 
    
    typedef R BaseT(P1); 
    typedef R BottomT(P1); 
    typedef CompoundT<void> ClassT; 
};
...
```

:two:另外，我们也可以借助==SFINAE原则==来解决这个问题：一个重载函数模板（如下面的`test`）的后面可以是一些显式模板实参（如下面的`U`）；而且对于某些重载函数类型而言，该实参是有效的，但是对于其他的重载函数类型，该实参则可能是无效的。实际上，后面使用**重载解析**对枚举类型进行辨别的技术也使用到了这种方法。

原则在这里的主要用处是：找到一种构造，该构造对函数类型是无效的，但是对其他类型都是有效的；或者完全相反。由于前面我们已经能够辨别出几种类型了，所以我们在此可以不再考虑这些类型。因此，针对上面这种要求，**数组类型就是一种有效的构造**；因为数组的元素是不能为void值、引用或者函数的。于是，这启发了我们编写出下面的代码：

```c++
template<typename T> 
class IsFunctionT 
{
private: 
    typedef char One; 
    typedef struct { char a[2]; } Two; 
    
    template<typename U> 
    static One test(...);
    
    template<typename U> 
    static Two test(U (*)[1]); 
    
public: 
    enum { Yes = sizeof(IsFunctionT<T>::test<T>(0)) == 1 }; 
    enum { No = !Yes }; 
};
```

借助于上面这个模板定义，只有对于那些不能作为数组元素类型的类型，`lsFunctionT::Yes`，才是非零值（即为`1`）。另外，我们应该知道该方法也有一个**不足之处**：并非只有**函数类型**不能作为**数组元素类型**，**引用类型和void类型**同样也不能作为数组元素类型。幸运的是，我们可以通过为**引用类型**提供**局部特化**，以及为**void类型**提供**显式特化**，来解决这个不足：

```c++
template<typename T> 
class IsFunctionT<T&> 
{ 
public: 
    enum { Yes = 0 }; 
    enum { No = !Yes }; 
};

template<> 
class IsFunctionT<void> 
{ 
public: 
    enum { Yes = 0 }; 
    enum { No = !Yes }; 
}; 

template<> 
class IsFunctionT<void const>
{ 
public: 
    enum { Yes = 0 }; 
    enum { No = !Yes }; 
};
```

:three:基于上面例子的这些考虑，我们现在就可以重新改写基本的`CompoundT`模板如下：

```c++
template<typename T> 
class CompoundT 
{     //基本模板 
public:
    enum { IsPtrT = 0, IsRefT = 0, IsArrayT = 0, 
          IsFuncT = IsFunctionT<T>::Yes, IsPtrMemT = 0 }; 
    
    typedef T BaseT; 
    typedef T BottomT; 
    typedef CompoundT<void> ClassT;
};
```

实际上，基本模板的这个实现与前面所给出的那些特化并不冲突。因此，在参数个数已经限定的情况下，借助于前面的特化，还可以访问**返回类型**和**参数类型**。



### 1.4 运用重载解析辨别枚举类型

:one:==重载解析==是一个过程，它会根据**函数参数的类型**，在多个同名函数中选择出一个合适的函数。接下来我们将看到，即使没有进行**实际的函数调用**，我们也能够利用**重载解析**，来确定所需要的结果。

总之，对于测试**某个特殊的隐式转型**是否存在的情况，利用重载解析的方法是相当有用的。在此，我们将要利用==从枚举类型到整型的隐式转型==：它能够帮助我们分辨**枚举类型**。

```c++
// types/type7.hpp 
struct SizeOverOne { char c[2]; }; 

template<typename T, 
         bool convert_possible = !CompoundT<T>::IsFuncT && !CompoundT<T>::IsArrayT> 
class ConsumeUDC 
{ 
public:
    operator T() const; 
}; 

// 到函数类型的转型是不允许的
template <typename T> 
class ConsumeUDC<T, false> { }; 

// 到void类型的转型是不允许的 
template <bool convert_possible> 
class ConsumeUDC<void, convert_possible> { }; 

char enum_check(bool); 
char enum_check(char); 
char enum_check(signed char); 
char enum_check(unsigned char); 
char enum_check(wchar_t); 
char enum_check(signed short); 
char enum_check(unsigned short); 
char enum_check(signed int); 
char enum_check(unsigned int); 
char enum_check(signed long); 
char enum_check(unsigned long); 
#if LONGLONG_EXISTS 
	char enum_check(signed long long); 
	char enum_check(unsigned long long);
#endif 
// LONGLONG_EXISTS 
// 避免从ﬂoat到int的意外转型 
char enum_check(ﬂoat); 
char enum_check(double); 
char enum_check(long double); 

SizeOverOne enum_check(...); // 捕获剩余的所有情况

template<typename T> 
class IsEnumT 
{ 
public: 
    enum { Yes = IsFundaT<T>::No && !CompoundT<T>::IsRefT && !CompoundT<T>::IsPtrT 
           && !CompoundT<T>::IsPtrMemT && sizeof(enum_check(ConsumeUDC<T>()))==1 
         }; 
    
    enum { No = !Yes }; 
}; 
```

上面代码的核心在于后面的一个`sizeof`表达式，它的参数是一个**函数调用**。也就是说，该表达式将会返回**函数调用返回值的类型大小**；其中，将应用**重载解析原则**来处理`enum_CHECK()`调用；但另一方面，我们并**不需要函数定义**，因为实际上并没有真正调用该函数。

在上面的例子中，如果实参可以转型为一个整型，那么`enum_check()`，将返回一个`char`值，其大小为`1`。对于其他的所有类型，我们使用了一个==省略号函数==（即`enum_CHECK(...)`），然而，根据==重载解析原则的优先顺序==，**省略号函数**将会是最后的选择。在此，我们对**enum_CHECK()的省略号版本**进行了特殊的处理，让它返回一个大小大于一个字节的类型（即`SizeOverOne`）。

:two:对于函数`enum_check`的调用实参，我们必须仔细地考虑。首先，我们并不知道`T`是如何构造的，或许将会调用一个**特殊的构造函数**。为了解决这个问题，我们可以声明一个返回类型为`T`的函数，然后通过调用这个函数来创建一个`T`。

事实上，更加巧妙的是：对于一个**类类型**`T`，重载解析是有可能选择一个针对整型的`enum_check()`声明的，但前提是该类必须定义一个**到整型的自定义转型**函数。到此，问题已经解决了，因为我们在`ConsumeUDC`模板中已经强制定义了一个**到`T`的自定义转型**，该转型运算符同时也为`sizeof`运算符生成了一个类型为`T`的实参。如果你还没有看出来，让我们来详细地分析这个**调用enum_的表达式**：

- 最开始的实参是一个临时的`ConsumeUDC<T>`对象。
- 如果`T`是一个**基本整型**，那么将会借助于（`ConsumeUdc`的）**转型运算符**来创建一个`enum_check()`的匹配，该`enum_check()`以`T`为实参。
- 如果`T`是一个==枚举类型==，那么将会借助于（`ConsumeUDC`的）**转型运算符**，先把类型转化为`T`，然后调用（从枚举类型到整型的）**类型提升**，从而能够匹配一个**接收整型参数的`enum_check()`函数**（通常而言是`enum_check(int)`）。
- 如果`T`是一个==class类型==，而且已经为该`class`自定义了一个**到整型的转型运算符**，那么这个转型运算符将**不会被考虑**。因为对于以匹配为目的的自定义转型而言，最多只能调用一次；而且在前面已经使用了一个从`ConsumeUDC<T>`到`T`的自定义转型，所以也就**不允许再次调用自定义转型**。也就是说，对`enum_check()`函数而言，**class类型**最终还是未能转型为整型。
- 如果最终还是不能让类型`T`与**整型**互相匹配，那么将会选择`enum_check()`函数的==省略号版本==。

最后，由于我们这里只是为了辨别**枚举类型**，而不是基本类型或者指针类型，所以我们使用了前面已经开发的`lsFundaT`和`CompoundT`类型，从而能够排除这些令`IsEnumT<T>::yes`成为非零的其他类型，最后使得只有枚举类型的`IsEnumT::yes`才等于`1`。



### 1.5 辨别class类型

:one:一种辨别的方法是使用**排除原理**：如果一个类型不是一个基本类型，也不是枚举类型和组合类型，那么该类型就只能是**类类型**。我们可以使用下面这个**直接的模板**，来实现这个原理：

```c++
// types/type8.hpp 
template<typename T> 
class IsClassT 
{ 
public: 
    enum { Yes = IsFundaT<T>::No && IsEnumT<T>::No && !CompoundT<T>::IsPtrT 
           && !CompoundT<T>::IsRefT && !CompoundT<T>::IsArrayT 
           && !CompoundT<T>::IsPtrMemT && !CompoundT<T>::IsFuncT }; 
    
    enum { No = !Yes }; 
}; 
```



### 1.6 辨别所有类型的函数模板

:one:总结之前的各个部分：

```c++
// types/typet.hpp 
#ifndef TYPET_HPP 
#deﬁne TYPET_HPP 

// deﬁne IsFundaT<> 
#include "type1.hpp" 

// 定义基本模板 CompoundT<> (第一个版本) 
#include "type2.hpp" 

// 定义基本模板 CompoundT<> (第二个版本)  
#include "type6.hpp" 

// deﬁne CompoundT<> 的特化
#include "type3.hpp" 
#include "type4.hpp" 
#include "type5.hpp" 

// 定义IsEnumT<> 
#include "type7.hpp" 

// 定义IsClassT<> 
#include "type8.hpp" 

template <typename T> 
class TypeT 
{ 
public: 
    enum { IsFundaT = IsFundaT<T>::Yes, IsPtrT = CompoundT<T>::IsPtrT, 
          IsRefT = CompoundT<T>::IsRefT, IsArrayT = CompoundT<T>::IsArrayT, 
          IsFuncT = CompoundT<T>::IsFuncT, IsPtrMemT = CompoundT<T>::IsPtrMemT,
          IsEnumT = IsEnumT<T>::Yes, IsClassT = IsClassT<T>::Yes 
         };
}; 
#endif 
// TYPET_HPP 
```



### 1.7  后记

:one:对于某个实体，这种能够在程序中获知它的**高层次属性**（诸如类型结构）的能力通常称为==反射==。在这一章中，我们的框架实现了一种**编译期反射**，这种能力也将与==元编程==相得益彰。



## 2. 智能指针

### 2.1 hollder和trulle

:one:本节将介绍两种**智能指针类型**：`Holder`类型独占一个对象；而`Trule`可以使对象的拥有者从一个`Holder`传递给另一个`Holder`。

#### 安全处理异常

:one:比较熟悉，具体见书。

#### holder

:one:它会在下面两种情况下释放**所指向的对象**：本身被释放，或者把另一个指针赋值给它。我们把这种类称为`Holder`，使用该名称的主要理由是：当我们执行各种计算的时候，就意味着安全地持有一个对象。下面就说明如何做到这一点：

```c++
// pointers/holder.hpp 
template <typename T> 
class Holder 
{ 
private: 
    T* ptr;  // 引用它所持有的对象（前提是该对象存在） 
    
public: 
   
    Holder() : ptr(0) {} 
    
    // 针对指针的构造函数: 让该holder引⽤该指针指向的对象 
    explicit Holder (T* p) : ptr(p) { } 
    
    // 析构函数：释放所引用的对象（前提是该对象存在） 
    ~Holder() { delete ptr; } 
    
    // 针对指针的赋值运算符 
    Holder<T>& operator= (T* p) 
    { 
        delete ptr; 
        ptr = p; 
        return *this; 
    } 
    
    // 指针运算符 
    T& operator* () const {
        return *ptr;
    } 
    
    T* operator-> () const 
    { 
        return ptr; 
    } 
    
    // 获取所引用的对象（前提是该对象存在） 
    T* get() const { return ptr; } 
    
    // 释放所引用的对象所有权 
    void release() { ptr = 0; } 
    
    // 和另⼀个holder交换所有权
    void exchange_with (Holder<T>& h) 
    { 
        swap(ptr, h.ptr); 
    } 
    
    void exchange_with (T*& p)
    { 
        swap(ptr, p); 
    } 
    
private: 
    //不向外提供拷贝构造函数和拷贝赋值运算符 
    Holder (Holder<T> const&); 
    
    Holder<T>& operator= (Holder<T> const&); 
};
```

从语义上讲，该`Holder`独占`ptr`所引用对象的所有权。而且，这个对象一定要用`New`操作来创建，因为在销毁`Holder`所拥有对象的时候，需要用到`delete`操作。



#### 资源获取于初始化:star:

:one:`holder`所用到的基本思想是一种称为==资源获取于初始化==或`RAII`的模式。在此，我们可以为释放`policy`引入一些模板参数，从而我们就可以把下面的代码

```c++
void do_something() 
{ 
    // 获取资源 
    RES1* res1 = acquire_resource_1(); 
    RES2* res2 = acquire_resource_2(); 
    … 
    release_resource_2(res); 
    release_resource_1(res); 
}
```

替换为所有符合以下形式的代码：

```c++
void do_something () 
{ 
    Holder<RES1,...> res1(acquire_resource_1()); 
    Holder<RES2,...> res2(acquire_resource_2()); 
    … 
}
```

#### holder的局限

:one:具体见书。（主要是使用上不像裸指针那么方便，特别是参数和返回值都要求裸指针的情况）

```c++
Something* load_something() 
{ 
    Holder<Something> result(new Something); 
    read_something(result.get_pointer()); 
    Something* ret = result.get_pointer(); 
    result.release(); 
    return ret; 
} 
```



#### trule

:one:为了解决上一小节留下的问题，我们引进了一个专门用于传递`Holder`的**辅助类模板**，并把它称为`Trule`。在语言中，它是一个术语，来自于**转移胶囊**的缩写。下面是其定义：

```c++
// pointers/trule.hpp 
#ifndef TRULE_HPP 
#deﬁne TRULE_HPP 
template <typename T> 
class Holder; 

template <typename T> 
class Trule 
{ 
private: 
    T* ptr;  

public: 
    Trule (Holder<T>& h) 
    {
        ptr = h.get(); 
        h.release(); 
    } 
   
    Trule (Trule<T> const& t) 
    { 
        ptr = t.ptr; 
        const_cast<Trule<T>&>(t).ptr = 0;
    } 
 
    ~Trule() { delete ptr; } 
    
private: 
    
    Trule(Trule<T>&);       			// 禁⽌将trule作为左值 
    Trule<T>& operator= (Trule<T>&);	// 禁⽌拷贝赋值 
    friend class Holder<T>;
};
#endif // TRULE_HPP 
```

显然，在拷贝构造函数里有些比较别扭的代码：`trule`，通常是作为那些想传递持有的函数的返回类型，也就是说：**trule对象**总是作为**临时对象**出现；因此它们的类型也就只能是==常引用（Reference to-Const）类型==。然而，由于`trule`不能作为一份拷贝，也不能含有一份拷贝，如果我们希望实现**类似于拷贝的操作**，就必须移除原trule的所有权，我们是通过将**被封装指针置为空**，来实现这种移除操作的.

:two:最后，对于上面实现的`Trule`，只有被`Holder`模板所辨识并且使用之后，才能算是完整的，下面我们就给出针对`Holder`的用法：

```c++
// pointers/holder2extr.hpp 
template <typename T> 
class Holder 
{ 
    … 
public: 
    Holder (Trule<T> const& t) 
    { 
        ptr = t.ptr; 
        const_cast<Trule<T>&>(t).ptr = 0;
    } 
    
    Holder<T>& operator= (Trule<T> const& t) 
    { 
        delete ptr; 
        ptr = t.ptr; 
        const_cast<Trule<T>&>(t).ptr = 0; 
        return *this;
    }
}; 
```

为了充分演示对`Holder/trule`作了哪些改善，我们重写了例子：

```c++
// pointers/truletest.cpp 
#include "holder2.hpp" 
#include "trule.hpp" 
class Something { }; 

void read_something (Something* x) 
{ } 

Trule<Something> load_something() 
{ 
    Holder<Something> result(new Something); 
    read_something(result.get()); 
    return result; 
} 

int main() 
{
    Holder<Something> ptr(load_something()); …
} 
```

最终，我们创建了一对使用起来几乎可以**像普通指针一样方便的类模板**。而且这两个类模板还有附加的好处：在由于**抛出异常**，而导致堆栈展开的情况下，可以管理对象的释放，**防止内存泄漏**。





