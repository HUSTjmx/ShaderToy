[toc]



# 深入模板

## 1. 基础

### 参数化声明

:one:在所属**外围类的外部**进行定义的成员模板可以具有**多个模板参数子句**`template<...>`：一个子句用于该模板自身，另一个子句用于外围类模板。另外，子句的顺序是**从最外围的类模板开始，依次到达内部模板**。

另外，==联合(Union)模板==也是允许的（它往往被看作类模板的一种）：

```c++
template <typename T> 
union AllocChunk 
{ 
    T object; 
    unsigned char bytes[sizeof(T)]; 
}; 
```

:two:==成员函数模板不能被声明为虚函数==。这是一种需要强制执行的限制，因为**虚函数调用机制的普遍实现**都使用了一个**大小固定的表**，每个虚函数都对应表的一个入口。然而**，成员函数模板的实例化个数，要等到整个程序都翻译完毕才能够确定**，这就和表的大小发生了冲突。

相反，==类模板的普通成员可以是虚函数==，因为当类被实例化之后，它们的**个数是固定的**：

```c++
template <typename T> 
class Dynamic {
public: 
    virtual ~Dynamic (); 
    
    template <typename T2> 
    virtual void copy (T2 const&); //错误
}; 
```

:three:每个模板都必须有一个名字，而且在它所属的作用域下，==该名字必须是唯一的==；除非函数模板可以被重载。特别是，**类模板不能和另外一个实体共享一个名称**，这一点和**类类型**是不同的：

```c++
int C; 
class C;

nt X; 
template <typename T> class X;   //错误
```

> 由于外部链接，不能在函数内部声明模板



### 模板参数

:one:现今存在`3`种模板参数：

- 类型参数
- 非类型参数。
- 模板的模板参数。

:two:在**模板声明内部**，**==类型参数==的作用**类似于`typedef`（**类型定义**）。例如，如果`T`是一个模板参数，就不能使用诸如`class T`等形式的**修饰名称**，即使`T`是一个要被**class类型**替换的参数也不可以。

```c++
template <typename Allocator> 
class List 
{ 
    class Allocator* allocator;   /   
    friend class Allocator;       //error
    .. 
}; 
```

:three:==非类型参数==表示的是：在编译期或链接期可以确定的常值。这种参数的类型必须是下面的一种：

- **整型或者枚举类型**。
- **指针类型**，包含：普通对象的指针类型、函数指针类型、指向成员的指针类型。
- **引用类型**：指向对象或者指向函数的引用都是允许的。

> 所以，注意到了吗，或者，我们复习下，==非类型参数不能是浮点数==哦！
>

**非模板参数**的声明也可以使用**关键字**`typename`：

```c++
template <typename T, typename T::Allocator* Allocator>   //后者就是非类型参数
class List; 
```

**函数和数组类型**也可以被指定为**非模板参数**，但要把它们先**隐式地转换**为指针类型，这种转型也称为`decay`：

```c++
template<int buf[5]> class Lexer; 
template<int* buf> class Lexer; 
```

**非类型模板参数的声明**和变量的声明很相似，但它们不能具有`static`、`mutable`等修饰符；只能具有`Const`和`volatile`限定符。但如果**这两个限定符**限定的是**最外层的参数类型**，编译器将会**忽略它们**：

```c++
template<int const length> class Buﬀer;
//等同
template<int length> class Buﬀer; 
```

最后，==非类型模板参数只能是右值==：它们不能被取址，也不能被赋值。

:four:==模板的模板参数==是代表**类模板的占位符**（`placeholder`）。它的声明和**类模板的声明**很类似，但不能使用关键字`struct`和`union`：

```c++
template <template<typename X> class C>  //正确
void f(C<int>* p); 

template <template<typename X> struct C> //错误 
void f(C<int>* p); 

template <template<typename X> union C>  //错误 
void f(C<int>* p); 
```

**模板的模板参数的参数**可以具有**缺省模板实参**。显然，只有在调用时没有指定该参数的情况下，才会应用缺省模板实参：

```c++
template <template<typename T, typename A = MyAllocator> class Container> 
class Adaptation 
{ 
	Container<int> storage; //隐式等同于Container<int,MyAllocator> ... 
}; 
```

对于**模板的模板参数**而言，**它的参数名称**只能被**自身其他参数的声明**使用。下面的假设例子说明了这一点：

```c++
template <template<typename T, T*> class Buf> 
class Lexer 
{ 
    static char storage[5]; 
    Buf<char, &Lexer<Buf>::storage[0]> buf; 
}; 

template <template<typename T> class List> 
class Node 
{ 
    static T* storage; //错误
}; 
```



### 模板实参

:one:有几种不同的方法来**确定模板实参的值**：

- **显式模板实参**：紧跟在模板名称后面，在一对尖括号内部的显式模板实参值。所组成的整个实体称为`template-id`。
- **注入式类名称**：对于具有模板参数`P1`、`P2`的类模板`X`，在它的作用域中，模板名称（即`X`）等同于`template-id`：<P1，P2，....>。
- **缺省模板实参**：如果提供缺省模板实参的话，在类模板的实例中，就可以省略显式模板实参.然而，即使所有的模板参数都具有缺省值，==一对尖括号还是不能省略的==。
- **实参演绎**：对于不是显式指定的函数模板实参，可以在函数的调用语句中，根据函数**调用实参的类型**来演绎出函数模板实参。如果所有的模板实参都可以通过演绎获得，那么在函数模板名称后面就**不需要指定尖括号**。

:two:然而，**某些模板实参**永远也得不到演绎的机会，于是，我们最好把这些实参所对应的参数放在**模板参数列表的开始处**，从而可以显式指定这些参数，而其他的参数仍然可以进行**实参演绎**。

具体讨论见书。

:three:

```c++
template<typename T> RT1 test(typename T::X const*); 
template<typename T> RT2 test(...); 
//
test<int>可能会使第一个函数模板无意义。因为int没有成员类型X
```

不能用`int`来替换第一个模板的参数，并不意味着`&test<int>`是非法的，实际上，这里也是**有效的，也是合法的**。为什么？

==替换失败并非错误原则==（`SFINAE`）**是令函数模板可以重载的重要因素**。然而，它同时也涉及到**值得我们注意的编译期技术**。例如，假设类型`RT1`和`RT2`的定义如下：

> 有二义性时，不能演绎出Func的实参

```c++
typedef char RT1; 
typedef struct { char a[2]; } RT2; 
```

于是，我们就可以在**编译期**检查给定类型`T`**是否具备成员类型**`X`：

```c++
#define type_has_member_type_X(T) (sizeof(test<T>(0)) == 1) 
```

`SFINAE`原则保护的只是：**允许试图创建无效的类型，但并不允许试图计算无效的表达式**。因此，下面的例子是**错误的C++例子**：

```c++
template<int I> 
void f(int (&)[24 / (4 - I)]); 

template<int I> 
void f(int (&)[24 / (4 + I)]); 

int main() 
{ 
    &f<4>;    //错误，替换后第一个除数等于0（不应⽤SFINAE） 
} 
```

即使第`2`个模板支持这种替换，它的除数也不会为`0`，但是这个例子是**错误的**。而且，这种错误只会在**表达式自身**出现，并不会在**模板参数表达式的绑定**中出现。因此，下面的例子是**合法的**：

```c++
template<int N> 
int g() 
{ 
    return N; 
} 

template<int* P> 
int g() 
{ 
    return *P; 
} 

int main() 
{ 
    return g<1>();    //虽然数字1不能绑定到int*参数
}             		  //但是应⽤了SFINAE原则 
```

:star:总结：上面讲的云里雾里，我进行一个总结，但不保证正确：所谓的`SFINAE`是啥意思呢？如果一开始有一个模板，我们调用他，但实参根本不匹配，当然会直接报错。

然后，我们写第二个模板，让这个新模板可以匹配我们的调用，这个时候分两种情况：

- 第一种情况，是直接的类型不匹配（也就是我们的第一个模板的适配情况），那么没事。
- 第二种情况，之前的那个模板是**无效的表达式**，例如，产生了分母`0`，这个时候，哪怕第二个模板已经匹配了，也依然没用。



:four:我们平时使用的**大多数类型**都可以被用作**模板的类型实参**，但有两种情况例外：

- **局部类和局部枚举**（在函数内部定义的）不能作为**模板的类型实参**。
- **未命名的class类型或者未命名的枚举类型**不能作为模板的类型实参——然而，通过`typedef`声明给出的未命名类和枚举，是可以作为模板类型实参的。



:five:**非类型模板实参**是那些替换非类型参数的值。这个值必须是以下几种中的一种：

- 某一个具有正确类型的非类型模板参数。
- **一个编译期整型常值**（或枚举值）。这只有在参数类型和值的类型能够进行匹配，或者值的类型可以**隐式地转换**为参数类型的前提下，才是合法的。
- 前面有**单目运算符**`&`（即取址）的**外部变量或者函数**的名称。对于函数或数组变量，`&`运算符可以省略。这类模板实参可以匹配**指针类型的非类型参数**。
- 对于引用类型的非类型模板参数，前面**没有&运算符的外部变量和外部函数**也是可取的.
- 一个指向成员的指针常量；换句话说，类似`&C::m`的表达式，其中`C`是一个**class类型**，`m`是一个**非静态成员**。这类实参只能匹配**类型为“成员指针”的非类型参数**。

```c++
template <typename T, T nontype_param> 
class C; 

C<int, 33>* c1;       

int a; 
C<int*, &a>* c2;

void f(); 
void f(int); 
C<void(*)(int), f>* c3;    

class X {
    Public: int n; 
    static bool b;
}; 

C<bool&, X::b>* c4;      
C<int X::*, &X::n>* c5;   

template<typename T> 
void templ_func(); 
C<void(), &templ_func<double> >* c6; 
```

> ==模板实参的一个普遍约束==是：在程序创建的时候，**编译器或者链接器要能够确定实参的值**。如果实参的值要等到程序运行时才能够确定(譬如，局部变量的地址)，就不符合“模板是在程序创建的时候进行实例化”的概念了。
>
> 不能作为非类型实参的常值：空指针常量、浮点值、字符串



:six:“==模板的模板实参==”必须是一个**类模板**，它本身具有参数，该参数必须精确匹配它“所替换的模板的模板参数”本身的参数。在匹配过程中，**“模板的模板实参”的缺省模板实参将不会被考虑**，但是如果**“模板的模板参数”具有缺省实参**，那么**模板的实例化过程**是会考虑**模板的模板参数的缺省实参**的。下面是个错误例子：

```c++
template <typename T1, typename T2, template<typename> class Container> 
class Relation 
{ 
public: 
    ... 
private: 
    Container<T1> dom1; 
    Container<T2> dom2; 
}; 

int main() { 
    Relation<int,double,std::list> rel;
	...
}
```

应该这样写：

```c++
#include <memory> 
template <typename T1, typename T2, template<typename T, typename = std::allocator<T> > class Container> 
class Relation
{ 
public: 
    ... 
private: 
    Container<T1> dom1; 
    container<T2> dom2; 
};
```



### 友元

:one:显然，如果要把**类模板的实例**声明为其他类（或者类模板）的友元，**该类模板**在声明的地方必须是**可见的**。然而，**对于一个普通类，就没有这个要求**：

```c++
template <typename T> 
class Tree 
{ 
    friend class Factory;  //正确
    friend class Node<T>;  //错误的, 如果node<T>在这里不可见
}; 
```

