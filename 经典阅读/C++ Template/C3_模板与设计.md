# 模板与设计

## 1. 模板的多态威力

对面向对象的程序设计范例而言，==多态==可以说是一块基石。在`C++`中，这块基石主要是通过**继承和虚函数**来实现的。由于这两个机制（继承和虚函数）都是至少一部分**在运行期进行处理的**，因此我们把这种多态称为==动多态==；我们平常所谈论的**C++多态**指的就是这种动多态。

然而，模板也允许我们使用单一的泛型标记，来关联不同的特定行为；但这种**借助于模板的关联是在编译期进行处理的**，因此我们把这种多态称为==静多态==。在这一章里，我们将重温这两种形式的多态，然后讨论：**在何种情况下，应该使用哪一种多态。**

### 动多态

:one:在这种情况下，==多态的设计思想==主要在于：对于几个相关对象的类型，确定它们之间的一个**共同功能集**；然后在基类中，把这些共同的功能声明为**多个虚函数接口**。

<img src="C3_模板与设计.assets/image-20210922105133728.png" alt="image-20210922105133728" style="zoom:67%;" />

### 静多态

:one:模板也能够被用于实现多态。然而，这种多态并不依赖于在基类中包含公共行为的因素；但仍然存在一种**隐式的公共性**，即应用程序的不同“形状（即类型）”都必须支持某些**使用公共语法的操作**（也就是说，相关的函数必须具有相同的名称）。另外，**具体类之间的定义是互相独立的**。于是，当用具体类对模板进行实例化的时候，这种多态的威力就显示出来了。

<img src="C3_模板与设计.assets/image-20210922105503843.png" alt="image-20210922105503843" style="zoom:67%;" />

```c++
// poly/statichier.hpp 
#include "coord.hpp" 
class Circle 
{ 
    public: 
    void draw() const;
    Coord center_of_gravity() const;
    … 
}; 

class Line 
{ 
    public: 
    void draw() const; 
    Coord center_of_gravity() const; 
    … 
};

… 

// poly/staticpoly.cpp
#include "statichier.hpp" 
#include <vector> 
template <typename GeoObj> 
void myDraw (GeoObj const& obj)
{ 
    obj.draw();
}
...
    
int main() { 
    Line l;

    Circle c, c1, c2; 
    
    myDraw(l);    // myDraw<Line>(GeoObj&) => Line::draw() 
    myDraw(c);    // myDraw<Circle>(GeoObj&) => Circle::draw() 
    ...
}
```



### 动多态和静多态

:one:***术语***

动多态和静多态为不同的C++编程`idioms`提供了支持：

- 通过继承实现的多态是**绑定的和动态的**：
  - 绑定的含义是：对于参与多态行为的类型，具有多态行为的接口是在公共基类的设计中就预先确定的。
  - 动态的含义是：**接口的绑定**是在运行期动态完成的.

- 通过模板实现的多态是**非绑定的和静态的**：
  - 非绑定的含义是：于参与多态行为的类型，它们的接口是没有预先确定的。
  - 静态的含义是：**接口的绑定**是在编译期静态完成的。



:two:通常而言，与动多态相比，静多态被认为具有**更好的类型安全性**；因为静多态在编译期会对所有的绑定操作进行检查。

具体优缺点见书。

:three:这种新形式的静多态带来了**实现设计模式的新方法**。例如，以在C++程序设计中扮演重要角色的==桥模式==为例。我们使用桥模式的目的是：**为了能够在同一接口的多个不同实现中进行切换**。根据`DesignPatternsGoV`所言，我们通常可以使用一个指针来引用具体的实现，然后把所有的调用都委托给这个**包含具体实现的类**，从而达到我们的目的。

<img src="C3_模板与设计.assets/image-20210922111741291.png" alt="image-20210922111741291" style="zoom:67%;" />

<img src="C3_模板与设计.assets/image-20210922111826675.png" alt="image-20210922111826675" style="zoom:67%;" />



### 泛型程序设计

C++模板的每次使用都可以被看成是**泛型程序设计的一个实例**；然而，开发人员却经常认为泛型程序设计本身具有**一个额外的本质特性**：即在一个框架中，设计模板的目的是为了能够得到多种有用的类型组合。



## 2. trait与policy类

### 一个实例：累加一个序列

:one:首先，让我们首先假设所要计算总和的值都是**存储在一个数组**里面的，并且我们还具有一个指向数组第1个元素的指针，以及一个指向数组最后一个元素的后一位的指针，这两个指针之间的所有元素就是我们要进行求总和的元素。现在，让我们先给出一个看起来比较直接的例子：

```c++
// traits/accum1.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP 
template <typename T> 
inline T accum (T const* beg, T const* end) 
{ 
    T total = T(); // 假设T()事实上⽣成⼀个等于0的值
    while (beg != end) 
    { 
        total += *beg; 
        ++beg; 
    } 
    return total; 
} 
#endif // ACCUM_HPP
```

正常调用是没有问题，例如`int`数组，但是如果我们对字符数组使用，会得到意料之外的结果（因为结果溢出了）。我们可以通过引入一个**额外的模板参数**`AccY`来解决这个问题，其中`AccT`描述了变量`total`的类型（同时也是返回类型）。然而，这将会给该模板的所有用户都强加**一个额外的负担**：他们每次调用这个模板的时候，都要指定这个额外的类型。因此，针对我们上面的例子，我们不得不这样编写代码：

```c++
char name[] = "templates"; 
accum<int>(&name[0],&name[length])
```

:two:关于这个额外参数，另一种解决方案是对`accum()`所调用的每个`T`类型都创建**一个关联**，所关联的类型就是用来存储累加和的类型。这种关联可以被看作是类型`T`的一个特征，因此我们也把这个**存储累加和的类型**称为`T`的`trait`。于是，我们可以使用每个模板特化来写出这些关联代码：

```c++
// traits/accumtraits2.hpp 
template<typename T> 
class AccumulationTraits; 

template<> 
class AccumulationTraits<char> 
{ 
public: 
    typedef int AccT; 
}; 

template<> 
class AccumulationTraits<short> 
{ 
public: 
    typedef int AccT; 
}; 

template<> 
class AccumulationTraits<int> 
{ 
public: 
    typedef long AccT; 
}; 

template<> 
class AccumulationTraits<unsigned int> 
{ 
public: 
    typedef unsigned long AccT;
}; 

template<>
class AccumulationTraits<ﬂoat> 
{ 
public: 
    typedef double AccT; 
};
```

在上面代码中，模板` AccumulationTraits `被称为一个`trait`模板，因为它含有它的参数类型的一个`trait`（通常而言，可以存在多个`trait`和多个参数）。对这个模板，我们并**不提供一个泛型的定义**，因为在我们不知道参数类型的前提下，并不能确定应该选择什么样的类型作为**和的类型**。有了这个想法之后，我们就可以这样改写前面的`accum()`模板：

```c++
// traits/accum2.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP 
#include "accumtraits2.hpp" 

template <typename T> 
inline typename AccumulationTraits<T>::AccT accum (T const* beg, T const* end) 
{ 
    typedef typename AccumulationTraits<T>::AccT AccT; 
    AccT total = AccT(); 
    
    while(beg != end) 
    { 
        total += *beg; 
        ++beg; 
    } 
    return total;
} 

#endif 
// ACCUM_HPP 
```

现在，基本内置类型都不会产生结果数值溢出的问题了。进一步而言，如果有新的类型要使用`accum()`模板，那么只需声明`AccumulationTraits`模板的一个**新的显式特化**，来关联`AccT`和该类型即可。我们还看到，任何类型都可以和`AccT`进行关联，来实现这种特性。

:three:***value trait***

显然，我们并不能保证上面的构造函数`AccT()`会返回一个符合条件的值，可以用来开始这个**求和循环**。而且，类型`AccT`也不一定具有一个**缺省构造函数**。我们需要给`AccumulationTraits`添加一个`value trait`：

```c++
// traits/accumtraits3.hpp 

template<typename T> 
class AccumulationTraits; 

template<> 
class AccumulationTraits<char> 
{ 
public: 
    typedef int AccT; 
    static AccT const zero = 0; 
}; 

template<> 
class AccumulationTraits<short> 
{ 
public: 
    typedef int AccT; 
    static AccT const zero = 0; 
}; 

template<> 
class AccumulationTraits<int> 
{ 
public: 
    typedef long AccT;
    static AccT const zero = 0; 
}; 
…
```

```c++
typedef typename AccumulationTraits<T>::AccT AccT; 
AccT total = AccumulationTraits<T>::zero;
while (beg != end) {
    ...
```

然而，这种解决方案的一个缺点是：在所在类的内部，C++只允许我们对**整型和枚举类型**初始化**静态成员变量**。显然，对于诸如**浮点型的其他类型**，也包括我们自己定义的类，就不能使用上面的解决方案。

但若是在源文件中初始化，编译器通常不会知道位于其他文件的定义。因此，我们趋向于实现下面的这种`value trait`：

```c++
 // traits/accumtraits4.hpp 
template<typename T> 
class AccumulationTraits; 

template<> 
class AccumulationTraits<char> 
{ 
public:
    typedef int AccT; 
    static AccT zero() { 
        return 0; 
    } 
}; 

template<> 
class AccumulationTraits<short> 
{ 
public: 
    typedef int AccT; 
    static AccT zero() 
    { 
        return 0; 
    } 
}; 
...
```

下面是`trait`概念的关键部分：`trait`提供了一种配置具体元素（通常是类型）的途径，而该途径主要是用于**泛型计算**。

:four:***参数化trait***

在上一节所使用的`trait`被称为`ﬁxed trait`，因为一旦定义了这个分离的`trait`，就不能在算法中对它进行改写。然而，在有些情况下我们需要对`trait`进行改写。

从原则上讲，**参数化主要的目的在于：添加一个具有缺省值的模板参数**，而且该缺省值是由我们前面介绍的模板决定的。在这种具有缺省值的情况下，许多用户就可以不需要提供这个额外的模板实参；但对于有特殊需求的用户，也可以**改写这个预设的和类型**。对于这个特殊的解决方案，唯一的不足在于：我们并不能对函数模板预设**缺省模板实参**。

就现在的情况而言，通过把算法实现为**一个类**，我们就可以绕过上面这个不足。这同时也说明了：除了函数模板之外，在类模板中也可以很容易地使用`trait`。在我们的应用程序中，唯一的缺点就是：**类模板不能对它的模板参数进行演绎**，而是必须显式提供这些模板参数。因此，我们需要编写如下形式的代码：

```c++
Accum<char>::accum(&name[0], &name[length]) 
```

```c++
// traits/accum5.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP 
#include "accumtraits4.hpp" 
template <typename T, typename AT = AccumulationTraits<T>> 
class Accum 
{ 
public:
    
    static typename AT::AccT accum (T const* beg, T const* end) 
    { 
        typename AT::AccT total = AT::zero(); 
        while (beg != end) 
        { 
            total += *beg; ++beg; 
        } 
        return total; 
    } 
}; 
#endif // ACCUM_HPP 
```

### Policy和Policy类

:one:还可以有其他种类的累积。例如，我们可以对序列中的给定值进行求积；如果这些值是字符串的话，还可以对它们进行连接。在这所有的情况中，针对`accum()`的所有操作，唯一需要改变的只是`total+=*beg`操作。于是，我们就把这个操作称为该累积过程的一个`policy`。因此，**一个Policy类**就是一个提供了一个接口的类，该接口能够在算法中应用一个或多个`Policy`。

下面是一个例子，它说明了如何在我们的**accum类模板**中引入这样的一个接口：

```c++
// traits/accum6.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP 
#include "accumtraits4.hpp" 
#include "sumpolicy1.hpp" 

template <typename T, typename Policy = SumPolicy, typename Traits = AccumulationTraits<T>> 
class Accum 
{
public: 
    typedef typename Traits::AccT AccT; 
    
    static AccT accum (T const* beg, T const* end) 
    { 
        AccT total = Traits::zero(); 
        while (beg != end) 
        { 
            Policy::accumulate(total, *beg); 
            ++beg; 
        } 
        return total; 
    }
}; 
#endif // ACCUM_HPP
```

其中**SumPolicy类**可以编写如下：

```c++
// traits/sumpolicy1.hpp 
#ifndef SUMPOLICY_HPP 
#deﬁne SUMPOLICY_HPP 

class SumPolicy 
{ 
public: 
    template<typename T1, typename T2> 
    static void accumulate (T1& total, T2 const & value) 
    { 
        total += value; 
    } 
}; 
#endif // SUMPOLICY_HPP
```

还有更好的实现方法，之后在讲。

:two:`policy`和`trait`具有许多共同点，但是策略更加注重于行为，而特性则更加注重于类型。

`trait class`：==是一种用于代替模板参数的类==。作为一个类，它可以是有用的类型，也可以是常量；作为一个模板，它提供了一种实现**“额外层次间接性”**的途径，而正是这种**“额外层次间接性”**解决了所有的软件问题。

因此，我们通常都会使用下面这些、并不是非常准确的定义：

- `trait`表述了模板参数的一些自然的额外属性。
- `policy`表述了泛型函数和泛型类的一些**可配置行为**——通常都具有被经常使用的缺省值。

关于两者的更多特征，见书。

:three:还存在另一种实现方法，即使用**类模板**来设计这个`policy class`接口，而这个`policy class`也就被用作**模板的模板实参**。例如，我们可以如下把`SumPolicy`改写成一个模板：

```c++
// traits/sumpolicy2.hpp 
#ifndef SUMPOLICY_HPP 
#deﬁne SUMPOLICY_HPP 

template <typename T1, typename T2> 
class SumPolicy 
{ 
public: 
    static void accumulate (T1& total, T2 const & value) 
    { 
        total += value; 
    } 
};
#endif 
// SUMPOLICY_HPP
```

于是，可以对`Accum`的接口进行修改，从而使用一个**模板的模板参数**，如下：

```c++
// traits/accum8.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP
#include "accumtraits4.hpp" 
#include "sumpolicy2.hpp" 

template<typename T, template<typename, typename> class Policy = SumPolicy, typename Traits = AccumulationTraits<T>> 
class Accum 
{ 
public: 
    typedef typename Traits::AccT AccT; 
    static AccT accum (T const* beg, T const* end) 
    { 
        AccT total = Traits::zero(); 
        while (beg != end) 
        { 
            Policy<AccT,T>::accumulate(total, *beg); 
            ++beg; 
        } 
        return total; 
    } 
}; 
#endif // ACCUM_HPP
```

然而，这种利用模板的模板参数的解决方案也存在一个缺点：`policy`类现在必须被写成模板，而且我们的接口中还定义了**模板参数的确切个数**。遗憾的是，这个定义会让我们无法在`policy`中添加**额外的模板参数**。

:four:在我们结束`trait`和`policy`的介绍之前，让我们来看`accum()`的一个新版本，它添加了处理普通迭代器的功能，而不仅仅是指针。有趣的是，该版本的`accum()`仍然允许我们使用**指针**来调用`accum()`，这是因为**C++标准库**提供了所谓的`iterator trait`。因此，我们可以定义`accum()`的初期版本如下：

```c++
// traits/accum0.hpp 
#ifndef ACCUM_HPP 
#deﬁne ACCUM_HPP 
#include <iterator> 

template <typename Iter> 
inline typename std::iterator_traits<Iter>::value_type accum (Iter start, Iter end) 
{ 
    typedef typename std::iterator_traits<Iter>::value_type VT; 
    VT total = VT(); // 假设VT()际上⽣成⼀0值 
    while (start != end) 
    { 
        total += *start; 
        ++start; 
    } 
    return total; 
}
#endif // ACCUM_HPP 
```

`iterator_trait`结构封装了迭代器的所有相关属性。由于存在一个**适用于指针的局部特化**，所以普通指针类型也能够使用这些`trait`。



### 类型函数

