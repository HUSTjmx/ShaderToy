# IO库

![image-20210313181813948](第八章——IO库.assets/image-20210313181813948.png)

## 1. IO类

到目前为止，我们已经使用过的IO类型和对象都是操纵char数据的。

![image-20210313182039763](第八章——IO库.assets/image-20210313182039763.png)

上诉带`w`的都是对应的**宽字符版本**。

==IO对象无拷贝和赋值==。

### 条件状态

部分表：（完整见P 279）

![image-20210313182522826](第八章——IO库.assets/image-20210313182522826.png)

### 管理条件状态

流对象的`rdstate`成员返回一个`iostate`值，对应流的当前状态。

![image-20210313182749789](第八章——IO库.assets/image-20210313182749789.png)

### 管理缓冲输出

:one:`flush`刷新缓冲区，但不输出任何额外的字符；`ends`向缓冲区插入一个空字符，然后刷新缓冲区。

![image-20210313183131684](第八章——IO库.assets/image-20210313183131684.png)

:two:`unitbuf`操作符，告诉流在接下来的每次写操作之后都进行一次flush操作。而`nounitbuf`则取消之。

```c++
cout << unitbuf;
cout << nounitbuf;
```

:three:当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会线刷新关联的·输出流。标准库将cout和cin关联在一起。



## 2. 文件输入输出

![image-20210313183806173](第八章——IO库.assets/image-20210313183806173.png)

![image-20210313184051640](第八章——IO库.assets/image-20210313184051640.png)

对于已经关联好的流，关联到另外一个文件时，需要先关闭：

```c++
in.close();
in.open(ifile + "2");
```

### 文件模式

![image-20210313184553419](第八章——IO库.assets/image-20210313184553419.png)

指定文件模式有如下限制，见(P 286)

以`out`模式打开文件，会丢弃已有数据（自带`trunc`）。防止的方法是指定`app模式`：

```c++
ofstream app("file2", ofstream::app);
```



## 3. string流

![image-20210313190228647](第八章——IO库.assets/image-20210313190228647.png)

### 使用istringstream

当我们的某些工作是对整行文本进行处理，而其它一些工作是处理行内的单个单词时，通常可以使用`istringstream`。

![image-20210313191527313](第八章——IO库.assets/image-20210313191527313.png)

### 使用ostringstream

当我们逐步构造输出时，希望最后一起打印时，`ostringstream`是很有用的。



# 顺序容器

