# 1. 条款9：使用析构函数防止资源泄露

:one:指针造成内存泄漏的一般情况：

```c++
ALA * readALA(istream& s);
void processAdoptions(istream& dataSource)
{
    while (dataSource) { // 还有数据时,继续循环
        ALA *pa = readALA(dataSource); //得到下一个动物
        pa->processAdoption(); //处理收容动物，如果这里抛异常，造成内存泄露
        delete pa; //删除 readALA 返回的对象
    }
} 
```

堵塞泄漏很容易 ： 

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        ALA *pa = readALA(dataSource);
        try {
        	pa->processAdoption();
        }
        catch (...) { 
            delete pa; // 捕获所有异常避免内存泄漏
            throw; // 当异常抛出时传送异常给调用者
        }
        delete pa; // 当没有异常抛出时避免资源泄漏
    } 
}
```

:two:替代方法是用一个**对象**代替**指针pa**，这个对象的行为与指针相似。当`pointer-like`对象（类指针对象）被释放时，我们能让它的析构函数调用 `delete`。（智能指针）

```c++
//不完整代码
template<class T>
class auto_ptr {
public:
     auto_ptr(T *p = 0): ptr(p) {} // 保存 ptr，指向对象
     ~auto_ptr() { delete ptr; } // 删除 ptr 指向的对象
private:
 	T *ptr; // raw ptr to object
}; 
```

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        auto_ptr<ALA> pa(readALA(dataSource));
        pa->processAdoption();
    }
}
```

隐藏在 `auto_ptr `后的思想是：**用一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源**，这种思想不只是可以运用在指针上，还能用在其它资源的分配和释放上。



# 2. 条款10：在构造函数中防止资源泄露

:one:首先我们需要记得：==C++仅仅能删除被完全构造的对象==（fully contructed objects）, 只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。==在构造 b 的过程中，一个异常被抛出，b 的析构函数不会被调用==。

那么如果我们在**构造函数**中获取堆对象，那么中途**抛异常**，之前的**堆对象不会释放**，会造成**内存泄露**。一个解决方法是**异常处理**`try catch`。

```c++
void testBookEntryClass()
{
    BookEntry *pb = 0;
    try {
        pb = new BookEntry("Addison-Wesley Publishing Company",
        "One Jacob Way, Reading, MA 01867");
        ...
    }
    catch (...) { // 捕获所有异常
        delete pb; // 删除 pb,当抛出异常时
        throw; // 传递异常给调用者
    }
    delete pb; // 正常删除 pb
} 
```

你会发现在 `BookEntry `构造函数里为 Image 分配的内存仍旧被丢失了，这是因为**如果 new 操作没有成功完成，程序不会对 pb 进行赋值操作。如果 BookEntry 的构造函数抛出一个异常，pb 将是一个空值**，所以在 catch 块中删除它，除了让你自己感觉良好以外没有任何作用。

> C++拒绝为没有完成构造操作的对象调用析构函数是有一些原因的，而不是故意为你制造困难。原因是：在很多情况下这么做是没有意义的，甚至是有害的。如果为没有完成构造操作的对象调用析构函数，析构函数如何去做呢？仅有的办法是在每个对象里加入一些字节来指示构造函数执行了多少步？然后让析构函数检测这些字节并判断该执行哪些操作。==这样的记录会减慢析构函数的运行速度==，并使得对象的尺寸变大。C++避免了这种开销，但是代价是不能自动地删除被部分构造的对象。

所以说，还是在**构造函数内部**使用**异常抛出**。

:two:当然最好还是使用**智能指针**，来管理这些局部对象：

```c++
class BookEntry {
    public:
    	... // 同上
    private:
        ...
        const auto_ptr<Image> theImage; // 它们现在是
        const auto_ptr<AudioClip> theAudioClip; // auto_ptr 对象
}; 
```



# 3. 条款11：禁止异常信息传递到析构函数外

:one:在有两种情况下会调用**析构函数**：

- 第一种是在正常情况下删除一个对象，例如对象超出了**作用域**或被显式地 `delete`。
- 第二种是异常传递的堆栈**辗转开解（stack-unwinding）过程** 中，由**异常处理系统**删除一个对象。

遗憾的是**没有办法在析构函数内部区分出这两种情况**。因此在**写析构函数时**你必须保守地假设**有异常被激活**。因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，==C++将调用 terminate 函数==。这个函数的作用正如其名字所表示的： **它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放**。 

:two:我们可以在 `catch` 中放入` try`，但是这总得有一个限度，否则会陷入循环。因此我们在释放时==必须忽略掉所有它抛出的异常==： 

```c++
Session::~Session()
{
    try {
    	logDestruction(this);
    }
    catch (...) { }
} 
```

:three:不允许**异常**传递到**析构函数**外面还有**第二个原因**。如果一个异常被析构函数抛出而没有在函数内部捕获住，那么析构函数就**不会完全运行**（它会停在抛出异常的那个地方上）。



# 4. 条款12：理解“抛出”一个异常与"传递一个参数"或“调用一个虚函数”间的区别

:one:**明显差异**：你调用函数时，**程序的控制权**最终还会返回到函数的调用处，但是当你抛出一个异常时，控制权永远不会回到抛出异常的地方。 

:two:对异常对象进行**强制复制拷贝**，哪怕异常对象是`static`，或者我们通过**引用**来捕获异常，这意味着：==抛出异常运行速度比参数传递要慢==。 

```c++
void passAndThrowWidget()
{
    static Widget localWidget; // 现在是静态变量（static）,一直存在至程序结束
    cin >> localWidget; 
    throw localWidget; // 仍将对 localWidget进行拷贝操作 
} 
```

:three:当异常对象被拷贝时，拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是**对象的静态类型**（static type）所对应**类的拷贝构造函数**，而不是对象的动态类型（dynamic type）对应**类的拷贝构造函数**。

```c++
class Widget { ... };
class SpecialWidget: public Widget { ... };
void passAndThrowWidget()
{
    SpecialWidget localSpecialWidget;
    ...
    Widget& rw = localSpecialWidget; // rw 引用 SpecialWidget 
    throw rw; //它抛出一个类型为 Widget的异常
}
```

:four:传递参数与传递异常的**另一个差异**。一个被异常抛出的对象（刚才解释过，总是一个**临时对象**）可以通过**普通的引用**捕获；它**不需要通过指向 const 对象的引用** （reference-to-const）捕获。**在函数调用中不允许转递一个临时对象到一个非` const `引用类型的参数里**，但是在异常中却被允许。 

:five:参数传递也大为不同，在异常捕获中，不能进行类似`int`到`double`的隐式转换，但依然可以进行两种类型转换：

- 第一种是**继承类**和**基类**之间的转换。

- 第二种是允许从一个**类型化指针**转变成**无类型指针**，所以带有` const void* `指针的` catch `子句能捕获**任何类型的指针类型异常**： 

  ```c++
  catch (const void*) ... //捕获任何指针类型异常 
  ```

:six:传递参数和传递异常间**最后一点差别**是：`catch `子句**匹配顺序**总是取决于它们在程序中**出现的顺序**。但我们最好不要把处理基类异常的` catch `子句放在处理派生类异常的` catch `子句的前面。

> 综上所述，把一个对象传递给函数或一个对象调用虚拟函数与把一个对象做为异常抛出，这之间有三个主要区别。第一、异常对象在传递时总被进行拷贝；当通过传值方式捕获时，异常对象被拷贝了两次。对象做为参数传递给函数时不一定需要被拷贝。第二、对象做为异常被抛出与做为参数传递给函数相比，前者类型转换比后者要少（前者只有两种转换形 式）。最后一点，catch 子句进行异常类型匹配的顺序是它们在源代码中出现的顺序，第一 个类型匹配成功的 catch 将被用来执行。当一个对象调用一个虚拟函数时，被选择的函数位于与对象类型匹配最佳的类里，即使该类不是在源代码的最前头。 



# 5. 条款13：通过引用捕获异常

:one:首先讨论**按指针传递**，在**理论上**这种方法的实现**效率最高**，能够做到**不拷贝对象**。但我们不能简单的使用栈上的指针：

```c++
void someFunction()
{
    exception ex; // 局部异常对象;
    // 当退出函数的生存空间时, 这个对象将被释放。
    ...
    throw &ex; // 抛出一个指针，指向已被释放的对象
} 
```

我们建立一个**堆对象**呢？但又遇到了一个新问题：`catch`子句是否应该**删除**他们接受的指针？这是不可能知道的：一些被调用者可能会传递**全局或静态对象的地址**，另一些可能传递**堆**中建立的异常对象的地址。

```c++
void someFunction()
{
    ...
    throw new exception; 
} 
```

> 通过指针捕获异常也不符合 C++语言本身的规范。四个标准的异常都不是指向对象的指针

:two:**按值传递**，首先是我们已经谈过的`2`次拷贝的问题。而且会产生`sclicing problem`，**派生类的异常对象**被做为**基类异常对象**捕获时， 那它的**派生类行为**就被切掉了。（那么之后的**虚函数调用**就不会符合我们的预期）

:three:最后就是**按引用传递**了。通过引用捕获异常能使你避开上述所有问题。



# 6. 条款14：谨慎使用异常规格

:one:**异常规格**是一个引人注目的特性。它使得代码更容易理解，因为它明确地描述了一个函数可以抛出什么样的异常。但是它不只是一个有趣的注释。编译器在编译时有时能够检测到**异常规格的不一致**。而且如果一个函数抛出一个**不在异常规格范围里的异常**，系统在运行时能够检测出这个错误，然后一个**特殊函数**` unexpected` 将被自动调用。

函数 `unexpected `缺省的行为是**调用函数**`terminate`，而` terminate` 缺省的行为是调用函数` abort`， 所以一个**违反异常规格的程序**其缺省的行为就是 `halt`（停止运行）。在**激活的栈**中的**局部变量**没有被释放，因为 `abort `在关闭程序时不进行这样的清除操作。

```
extern void f1(); // 可以抛出任意的异常 
void f2() throw(int); 
```

`f2 `调用 `f1 `是非常合法的，即使 `f1 `可能抛出一个违反` f2 `异常规格的异常。

:two:因为编译器允许调用一个函数，其**抛出的异常**与发出调用的函数的**异常规格不一 致**，并且这样的调用可能导致你的程序执行被终止，所以在编写软件时应该采取措施把这种**不一致减小到最少**。**第一种好方法**是：避免在**带有类型参数的模板**内使用**异常规格**。

```c++
// a poorly designed template wrt exception specifications
template<class T>
bool operator==(const T& lhs, const T& rhs) throw() //不能抛出任何异常
{
	return &lhs == &rhs;
} 
```

我们几乎不可能为一个**模板**提供一个**有意义的异常规格**。因为模板总是采用不同的方法使用类型参数。解决方法只能是**模板和异常规格不要混合使用**。 

:three:能够避免调用` unexpected `函数的**第二个方法**是：如果在一个函数内调用其它**没有异常规格的函数**时，应该**去除**这个函数的**异常规格**。

:four:避免调用`unexpected `的**第三个方法**是**处理系统本身抛出的异常**。这些异常中最常见的是` bad_alloc`，当内存分配失败时，它被 `operator new`和 `operator new[]`抛出。

:five:有时直接处理` unexpected `异常比防止它们被抛出要简单。C++允许用**其它不同的异常类型**替换`unexpected `异常。

```c++
class UnexpectedException {}; // 所有的 unexpected 异常对象被替换为这种类型对象
void convertUnexpected() // 如果一个 unexpected 异常被抛出，这个函数被调用
{ 
    throw UnexpectedException();
} 
...
set_unexpected(convertUnexpected); 
```

一个 **unexpected异常**将触发调用` convertUnexpected `函数。 `Unexpected `异常被一种 `UnexpectedException` 新异常类型替换。如果被违反的异常规格包含 `UnexpectedException `异常，那么异常传递将继续下去，==好像异常规格总是得到满足==。

:six:另一种把 **unexpected异常**转变成**知名类型**的方法是：替换`unexpected`函数，让其**重新抛出当前异常**，这样异常将被替换为` bad_exception`。

```c++
void convertUnexpected() // 如果一个 unexpected 异常被抛出，这个函数被调用
{ 
	throw; // 它只是重新抛出当前异常
} 
set_unexpected(convertUnexpected); //设置convertUnexpected做为unexpected的替代品
```

如果这么做，你应该在**所有的异常规格**里包含`bad_exception`（或它的**基类**）

综上所述，==异常规格是一个应被审慎使用的特性==。在把它们加入到你的函数之前，应考虑它们所带来的行为是否就是你所希望的行为。



# 7. 条款15：了解异常处理的系统开销

:one:异常是C++的一部分，C++编译器必须支持异常。也就是说，**当不用异常处理时，你不能让编译器生产商消除这方面的开销**。不过这只是理论，**实际上**大部分支持异常的编译器生产商都允许你**自由控制**是否在生成的代码里**包含进支持异常的内容**。

:two:异常处理的**第二个开销**来自于 **try 块**，当你想能够捕获异常时，那都得为此付出代价。不同的编译器实现 try 块的方法不同，所以编译器与编译器间的开销也不一样。粗略地估计，如果你使用 `try `块，代码的尺寸将增加 $5％...10％$并且运行速度也同比例减慢。

编译器为**异常规格**生成的代码与它们为` try `块生成的代码一样多，所以一个异常规格一般花掉与 `try` 块**一样多的系统开销**。（第三个开销？）

:three:核心是**抛出异常的开销**。与一个**正常的函数返回**相比，通过**抛出异常**从函数里返回可能会**慢三个数量级**。这个开销很大。（但是仅仅当你抛出异常时才会有这个开销，一般不会发生）

