# 1. 条款9：使用析构函数防止资源泄露

:one:指针造成内存泄漏的一般情况：

```c++
ALA * readALA(istream& s);
void processAdoptions(istream& dataSource)
{
    while (dataSource) { // 还有数据时,继续循环
        ALA *pa = readALA(dataSource); //得到下一个动物
        pa->processAdoption(); //处理收容动物，如果这里抛异常，造成内存泄露
        delete pa; //删除 readALA 返回的对象
    }
} 
```

堵塞泄漏很容易 ： 

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        ALA *pa = readALA(dataSource);
        try {
        	pa->processAdoption();
        }
        catch (...) { 
            delete pa; // 捕获所有异常避免内存泄漏
            throw; // 当异常抛出时传送异常给调用者
        }
        delete pa; // 当没有异常抛出时避免资源泄漏
    } 
}
```

:two:替代方法是用一个**对象**代替**指针pa**，这个对象的行为与指针相似。当`pointer-like`对象（类指针对象）被释放时，我们能让它的析构函数调用 `delete`。（智能指针）

```c++
//不完整代码
template<class T>
class auto_ptr {
public:
     auto_ptr(T *p = 0): ptr(p) {} // 保存 ptr，指向对象
     ~auto_ptr() { delete ptr; } // 删除 ptr 指向的对象
private:
 	T *ptr; // raw ptr to object
}; 
```

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        auto_ptr<ALA> pa(readALA(dataSource));
        pa->processAdoption();
    }
}
```

隐藏在 `auto_ptr `后的思想是：**用一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源**，这种思想不只是可以运用在指针上，还能用在其它资源的分配和释放上。



# 2. 条款10：在构造函数中防止资源泄露

:one:首先我们需要记得：==C++仅仅能删除被完全构造的对象==（fully contructed objects）, 只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。==在构造 b 的过程中，一个异常被抛出，b 的析构函数不会被调用==。

那么如果我们在**构造函数**中获取堆对象，那么中途**抛异常**，之前的**堆对象不会释放**，会造成**内存泄露**。一个解决方法是**异常处理**`try catch`。

```c++
void testBookEntryClass()
{
    BookEntry *pb = 0;
    try {
        pb = new BookEntry("Addison-Wesley Publishing Company",
        "One Jacob Way, Reading, MA 01867");
        ...
    }
    catch (...) { // 捕获所有异常
        delete pb; // 删除 pb,当抛出异常时
        throw; // 传递异常给调用者
    }
    delete pb; // 正常删除 pb
} 
```

你会发现在 `BookEntry `构造函数里为 Image 分配的内存仍旧被丢失了，这是因为**如果 new 操作没有成功完成，程序不会对 pb 进行赋值操作。如果 BookEntry 的构造函数抛出一个异常，pb 将是一个空值**，所以在 catch 块中删除它，除了让你自己感觉良好以外没有任何作用。

> C++拒绝为没有完成构造操作的对象调用析构函数是有一些原因的，而不是故意为你制造困难。原因是：在很多情况下这么做是没有意义的，甚至是有害的。如果为没有完成构造操作的对象调用析构函数，析构函数如何去做呢？仅有的办法是在每个对象里加入一些字节来指示构造函数执行了多少步？然后让析构函数检测这些字节并判断该执行哪些操作。==这样的记录会减慢析构函数的运行速度==，并使得对象的尺寸变大。C++避免了这种开销，但是代价是不能自动地删除被部分构造的对象。

所以说，还是在**构造函数内部**使用**异常抛出**。

:two:当然最好还是使用**智能指针**，来管理这些局部对象：

```c++
class BookEntry {
    public:
    	... // 同上
    private:
        ...
        const auto_ptr<Image> theImage; // 它们现在是
        const auto_ptr<AudioClip> theAudioClip; // auto_ptr 对象
}; 
```



# 3. 条款11：禁止异常信息传递到析构函数外

:one:在有两种情况下会调用**析构函数**：

- 第一种是在正常情况下删除一个对象，例如对象超出了**作用域**或被显式地 `delete`。
- 第二种是异常传递的堆栈**辗转开解（stack-unwinding）过程** 中，由**异常处理系统**删除一个对象。

遗憾的是**没有办法在析构函数内部区分出这两种情况**。因此在**写析构函数时**你必须保守地假设**有异常被激活**。因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，==C++将调用 terminate 函数==。这个函数的作用正如其名字所表示的： **它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放**。 

:two:我们可以在 `catch` 中放入` try`，但是这总得有一个限度，否则会陷入循环。因此我们在释放时==必须忽略掉所有它抛出的异常==： 

```


```

