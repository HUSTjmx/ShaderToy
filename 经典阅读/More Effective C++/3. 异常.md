# 1. 条款9：使用析构函数防止资源泄露

:one:指针造成内存泄漏的一般情况：

```c++
ALA * readALA(istream& s);
void processAdoptions(istream& dataSource)
{
    while (dataSource) { // 还有数据时,继续循环
        ALA *pa = readALA(dataSource); //得到下一个动物
        pa->processAdoption(); //处理收容动物，如果这里抛异常，造成内存泄露
        delete pa; //删除 readALA 返回的对象
    }
} 
```

堵塞泄漏很容易 ： 

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        ALA *pa = readALA(dataSource);
        try {
        	pa->processAdoption();
        }
        catch (...) { 
            delete pa; // 捕获所有异常避免内存泄漏
            throw; // 当异常抛出时传送异常给调用者
        }
        delete pa; // 当没有异常抛出时避免资源泄漏
    } 
}
```

:two:替代方法是用一个**对象**代替**指针pa**，这个对象的行为与指针相似。当`pointer-like`对象（类指针对象）被释放时，我们能让它的析构函数调用 `delete`。（智能指针）

```c++
//不完整代码
template<class T>
class auto_ptr {
public:
     auto_ptr(T *p = 0): ptr(p) {} // 保存 ptr，指向对象
     ~auto_ptr() { delete ptr; } // 删除 ptr 指向的对象
private:
 	T *ptr; // raw ptr to object
}; 
```

```c++
void processAdoptions(istream& dataSource)
{
    while (dataSource) {
        auto_ptr<ALA> pa(readALA(dataSource));
        pa->processAdoption();
    }
}
```

隐藏在 `auto_ptr `后的思想是：**用一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源**，这种思想不只是可以运用在指针上，还能用在其它资源的分配和释放上。



# 2. 条款10：在构造函数中防止资源泄露

:one:首先我们需要记得：==C++仅仅能删除被完全构造的对象==（fully contructed objects）, 只有一个对象的构造函数完全运行完毕，这个对象才被完全地构造。==在构造 b 的过程中，一个异常被抛出，b 的析构函数不会被调用==。

那么如果我们在**构造函数**中获取堆对象，那么中途**抛异常**，之前的**堆对象不会释放**，会造成**内存泄露**。一个解决方法是**异常处理**`try catch`。

```c++
void testBookEntryClass()
{
    BookEntry *pb = 0;
    try {
        pb = new BookEntry("Addison-Wesley Publishing Company",
        "One Jacob Way, Reading, MA 01867");
        ...
    }
    catch (...) { // 捕获所有异常
        delete pb; // 删除 pb,当抛出异常时
        throw; // 传递异常给调用者
    }
    delete pb; // 正常删除 pb
} 
```

你会发现在 `BookEntry `构造函数里为 Image 分配的内存仍旧被丢失了，这是因为**如果 new 操作没有成功完成，程序不会对 pb 进行赋值操作。如果 BookEntry 的构造函数抛出一个异常，pb 将是一个空值**，所以在 catch 块中删除它，除了让你自己感觉良好以外没有任何作用。

> C++拒绝为没有完成构造操作的对象调用析构函数是有一些原因的，而不是故意为你制造困难。原因是：在很多情况下这么做是没有意义的，甚至是有害的。如果为没有完成构造操作的对象调用析构函数，析构函数如何去做呢？仅有的办法是在每个对象里加入一些字节来指示构造函数执行了多少步？然后让析构函数检测这些字节并判断该执行哪些操作。==这样的记录会减慢析构函数的运行速度==，并使得对象的尺寸变大。C++避免了这种开销，但是代价是不能自动地删除被部分构造的对象。

所以说，还是在**构造函数内部**使用**异常抛出**。

:two:当然最好还是使用**智能指针**，来管理这些局部对象：

```c++
class BookEntry {
    public:
    	... // 同上
    private:
        ...
        const auto_ptr<Image> theImage; // 它们现在是
        const auto_ptr<AudioClip> theAudioClip; // auto_ptr 对象
}; 
```



# 3. 条款11：禁止异常信息传递到析构函数外

:one:在有两种情况下会调用**析构函数**：

- 第一种是在正常情况下删除一个对象，例如对象超出了**作用域**或被显式地 `delete`。
- 第二种是异常传递的堆栈**辗转开解（stack-unwinding）过程** 中，由**异常处理系统**删除一个对象。

遗憾的是**没有办法在析构函数内部区分出这两种情况**。因此在**写析构函数时**你必须保守地假设**有异常被激活**。因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，==C++将调用 terminate 函数==。这个函数的作用正如其名字所表示的： **它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放**。 

:two:我们可以在 `catch` 中放入` try`，但是这总得有一个限度，否则会陷入循环。因此我们在释放时==必须忽略掉所有它抛出的异常==： 

```c++
Session::~Session()
{
    try {
    	logDestruction(this);
    }
    catch (...) { }
} 
```

:three:不允许**异常**传递到**析构函数**外面还有**第二个原因**。如果一个异常被析构函数抛出而没有在函数内部捕获住，那么析构函数就**不会完全运行**（它会停在抛出异常的那个地方上）。



# 4. 条款12：理解“抛出”一个异常与"传递一个参数"或“调用一个虚函数”间的区别

:one:**明显差异**：你调用函数时，**程序的控制权**最终还会返回到函数的调用处，但是当你抛出一个异常时，控制权永远不会回到抛出异常的地方。 

:two:对异常对象进行**强制复制拷贝**，哪怕异常对象是`static`，或者我们通过**引用**来捕获异常，这意味着：==抛出异常运行速度比参数传递要慢==。 

```c++
void passAndThrowWidget()
{
    static Widget localWidget; // 现在是静态变量（static）,一直存在至程序结束
    cin >> localWidget; 
    throw localWidget; // 仍将对 localWidget进行拷贝操作 
} 
```

:three:当异常对象被拷贝时，拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是**对象的静态类型**（static type）所对应**类的拷贝构造函数**，而不是对象的动态类型（dynamic type）对应**类的拷贝构造函数**。

```c++
class Widget { ... };
class SpecialWidget: public Widget { ... };
void passAndThrowWidget()
{
    SpecialWidget localSpecialWidget;
    ...
    Widget& rw = localSpecialWidget; // rw 引用 SpecialWidget 
    throw rw; //它抛出一个类型为 Widget的异常
}
```

:four:传递参数与传递异常的**另一个差异**。一个被异常抛出的对象（刚才解释过，总是一个**临时对象**）可以通过**普通的引用**捕获；它**不需要通过指向 const 对象的引用** （reference-to-const）捕获。**在函数调用中不允许转递一个临时对象到一个非` const `引用类型的参数里**，但是在异常中却被允许。 

:five:参数传递也大为不同，在异常捕获中，不能进行类似`int`到`double`的隐式转换，但依然可以进行两种类型转换：

- 第一种是**继承类**和**基类**之间的转换。

- 第二种是允许从一个**类型化指针**转变成**无类型指针**，所以带有` const void* `指针的` catch `子句能捕获**任何类型的指针类型异常**： 

  ```c++
  catch (const void*) ... //捕获任何指针类型异常 
  ```

:six:传递参数和传递异常间**最后一点差别**是：`catch `子句**匹配顺序**总是取决于它们在程序中**出现的顺序**。但我们最好不要把处理基类异常的` catch `子句放在处理派生类异常的` catch `子句的前面。

> 综上所述，把一个对象传递给函数或一个对象调用虚拟函数与把一个对象做为异常抛出，这之间有三个主要区别。第一、异常对象在传递时总被进行拷贝；当通过传值方式捕获时，异常对象被拷贝了两次。对象做为参数传递给函数时不一定需要被拷贝。第二、对象做为异常被抛出与做为参数传递给函数相比，前者类型转换比后者要少（前者只有两种转换形 式）。最后一点，catch 子句进行异常类型匹配的顺序是它们在源代码中出现的顺序，第一 个类型匹配成功的 catch 将被用来执行。当一个对象调用一个虚拟函数时，被选择的函数位于与对象类型匹配最佳的类里，即使该类不是在源代码的最前头。 



# 5. 条款13：通过引用捕获异常

:one:首先讨论**按指针传递**，在**理论上**这种方法的实现**效率最高**，能够做到**不拷贝对象**。但我们不能简单的使用栈上的指针：

```c++
void someFunction()
{
    exception ex; // 局部异常对象;
    // 当退出函数的生存空间时, 这个对象将被释放。
    ...
    throw &ex; // 抛出一个指针，指向已被释放的对象
} 
```

我们建立一个**堆对象**呢？但又遇到了一个新问题：`catch`子句是否应该**删除**他们接受的指针？这是不可能知道的：一些被调用者可能会传递**全局或静态对象的地址**，另一些可能传递**堆**中建立的异常对象的地址。

```c++
void someFunction()
{
    ...
    throw new exception; 
} 
```

> 通过指针捕获异常也不符合 C++语言本身的规范。四个标准的异常都不是指向对象的指针

:two:**按值传递**，首先是我们已经谈过的`2`次拷贝的问题。而且会产生`sclicing problem`，**派生类的异常对象**被做为**基类异常对象**捕获时， 那它的**派生类行为**就被切掉了。（那么之后的**虚函数调用**就不会符合我们的预期）

:three:最后就是**按引用传递**了。通过引用捕获异常能使你避开上述所有问题。



# 6. 条款14：谨慎使用异常规格

