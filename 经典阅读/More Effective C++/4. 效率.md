# 1. 条例16：牢记80-20准则

:one:==80-20准则==说的是：大约$20 ％$的代码使用了$80 ％$的程序资源；大约 20%的代码耗用了大约 80％的运行时间；大约 20％的代码使用了 80％的内存；大约 20％的代码执行 80％的磁盘访问；80％的维护投入于大约 20％的代码上。

一方面**80-20准则**表示**大多数时间**你能够编写**性能一般的代码**，因为80％的时间里这些代码的效率不会影响到**整个系统的性能**。

而另一方面这条准则也表示如果你的软件出现了**性能问题**，你将面临一个**困难的工作**，因为你不仅必须找到**导致问题的那一小块代码**的位置，还必须寻找方法**提高它们的性能**。

:two:**用经验**猜测程序那**20％的部分**只会**导致心痛**。**正确的方法**是用==profiler程序==识别。

`profiler `告诉你每条语句执行了多少次，或各函数被调用了多少次。这是一个**作用有限的工具**。

**最好的方法**是用尽可能多的数据`profile`你的软件。



# 2. 条款17：考虑使用lazy evaluation（懒惰计算法）

:one:当你使用了` lazy evaluation` 后，**采用此种方法的类**将推迟**计算工作**直到系统需要这些计算的结果。如果不需要结果，将不用进行计算。`lazy evaluation`广泛适用于各种应用领域，所以将分**四个部分**讲述。 

:two:**引用计数**。​

```c++
class String { ... };
String s1 = "Hello";
String s2 = s1; / 调用 string 拷贝构造函数 
```

通常 `string `拷贝构造函数让 `s2 `被` s1 `初始化后，`s1` 和` s2` 都有自己的**”Hello”拷贝**。 这种拷贝构造函数会引起**较大的开销**。然而这时的`s2` 并不需要这个值的拷贝，因为` s2 `没有被使用。

==懒惰能就是少工作==。不应该赋给` s2 `一个 `s1 `的拷贝，而是让 `s2` 与` s1` 共享一个值。仅仅` string `的值被修改时，共享同一个值的方法才会造成差异：

```c++
s2.convertToUpperCase(); 
```

为了这样执行语句，`string `的` convertToUpperCase `函数应该制作` s2 `值的一个拷贝， 在修改前把这个私有的值赋给` s2`。这时我们不能再懒惰了。

:three:**区别对待读取和写入**。

```c++
String s = "Homer's Iliad"; // 假设是一个 reference-counted string
...
cout << s[3]; // 调用 operator[] 读取 s[3]
s[3] = 'x'; // 调用 operator[] 写入 s[3]
```

我们需要在 `operator[]`里采取不同的措施（**读取还是写入**）。**残酷的事实是我们不可能判断出来**。 通过使用` lazy evaluation `和条款 `M30` 中讲述的 `proxy class`，我们可以**推迟**做出是读操作还是写操作的**决定**，直到我们能判断出正确的答案。 

:four:Lazy Fetching（**懒惰提取**）​。

假设你的程序使用了一些**包含许多字段的大型对象**。 这些对象的**生存期**超越了**程序运行期**，所以它们必须被存储在**数据库**里。每一个对都有一个**唯一的对象标识符**，用来从**数据库**中重新获得对象：

```c++
class LargeObject { // 大型持久对象
public:
    LargeObject(ObjectID id); // 从磁盘中恢复对象
    const string& field1() const; // field 1 的值
    int field2() const; // field 2 的值
    double field3() const; // ...
    const string& field4() const;
    const string& field5() const;
    ...
}; 
```

因为` LargeObject` 对象实例很大，为这样的对象获取所有的数据，**数据库操作的开销将非常大**，特别是如果从**远程数据库**中获取数据和通过**网络**发送数据时。而在这种情况下， 不需要读去所有数据。

```c++
void restoreAndProcessObject(ObjectID id)
{
    LargeObject object(id);
    if (object.field2() == 0) {
    	cout << "Object " << id << ": null field2.\n";
    }
} 
```

这里仅仅需要` filed2 `的值，所以为获取其它字段而付出的努力都是浪费。我们可以这样做：

```c++
const string& LargeObject::field1() const
{
    if (field1Value == 0) {
        从数据库中为 filed 1 读取数据，使field1Value 指向这个值;
    }
    return *field1Value;
}
```

:five:Lazy Expression Evaluation（**懒惰表达式计算**）

最后一个例子来自于数字程序，考虑：

```c++
template<class T>
class Matrix { ... }; // for homogeneous matrices
Matrix<int> m1(1000, 1000); // 一个 1000 ＊ 1000 的矩阵
Matrix<int> m2(1000, 1000); // 同上
...
Matrix<int> m3 = m1 + m2; // m1＋m2 
```

这个计算量相当大（1000000 次加法运算），应该建立一个**数据结构**来表示 `m3` 的值是` m1 `与 `m2 `的和，在用一个` enum `表示它们间是**加法操作**。我们大部分时候只需要**庞大矩阵的一小部分数据**，所以我们每次也应该只对这部分进行计算。

