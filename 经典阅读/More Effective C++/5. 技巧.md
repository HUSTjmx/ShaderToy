# 1. 条款25：将构造函数和非成员函数虚拟化

:one:行为与**构造函数**相似，而且因为它能建立不同类型的对象，我们称它为**虚拟构造函数**。**虚拟构造函数**是指能够根据输入给它的**数据的不同**而建立**不同类型的对象**。（有点像工厂函数）

还有一种特殊种类的虚拟构造函数――**虚拟拷贝构造函数**――也有着广泛的用途。**虚拟拷贝构造函数**能返回一个**指针**，指向调用该函数的对象的**新拷贝**。因为这种行为特性，虚拟拷贝构造函数的名字一般都是`copySelf`。

```c++
class TextBlock: public NLComponent {
public:
    virtual TextBlock * clone() const // virtual copy
    { return new TextBlock(*this); } // constructor
    ...
};

class Graphic: public NLComponent {
public:
    virtual Graphic * clone() const // virtual copy
    { return new Graphic(*this); } // constructor
    ...
}; 
```

:star:上述代码的实现利用了较宽松的==虚拟函数返回值类型规则==。被派生类**重定义的虚拟函数**不用必须与基类的虚拟函数具有一样的**返回类型**。如果函数的返回类型是一个**指向基类的指针**（或一个引用），那么派生类的函数可以返回一个**指向派生类的指针**（或引用）。

:two:**非成员函数**也不能成为真正的虚拟函数，但可以根据**参数的不同动态类型**而其行为特性也不同。

```c++
class Graphic: public NLComponent {
public:
    virtual ostream& print(ostream& s) const;
    ...
};

inline ostream& operator<<(ostream& s, const NLComponent& c)
{
    return c.print(s);
} 
```

**具有虚行为的非成员函数**很简单。你编写一个**虚函数**来完成工作，然后再写一个**非虚函数**，它什么也不做**只是调用这个虚函数**。为了避免这个句法花招引起**函数调用开销**， 可以**内联**这个非虚函数。



# 2. 条款26：限制某个类所能产生的对象数量:star:

:one:先考虑只允许建立**零个或一个**的情况。可以将类的**构造函数**声明为`private`，然后使用一个函数来生成（==单例模式==）：

```c++
class PrintJob; // forward 声明
 // 参见 Effective C++条款 34
class Printer {
public:
    void submitJob(const PrintJob& job);
    void reset();
    void performSelfTest();
    ...
    friend Printer& thePrinter();

private:
    Printer();
    Printer(const Printer& rhs);
    ...
};

Printer& thePrinter()
{
    static Printer p; // 单个打印机对象
    return p;
} 
```

在`thePrinter`的实现上有两个微妙的不引人注目的地方，值得我们看一看：

- 第一，唯一的`Pritner`对象是位于**函数里的静态成员**而不是在**类中的静态成员**。
  - **类中的静态对象**实际上==总是被构造（和释放），即使不使用该对象==。与此相反，只有第一次执行函数时，才会建立**函数中的静态对象**，所以如果没有调用函数，就不会建立对象。:star:
  - 把 `Printer` 声明为**类中的静态成员**还有一个缺点，它的**初始化时间不确定**。
- 第二个细微之处是**内联**与**函数内静态对象**的关系。**内联**意味着**编译器**用**函数体**替代该对函数的每一个调用。**非成员函数**还有其它的含义。它还意味着 ==internal linkage==（内部链接）。 “**带有内部链接的函数**可能在程序内被**复制**（也就是说**程序的目标代码**可能包含一个以上的内部链接函数的代码），这种复制也包括**函数内的静态对象**。如果建立一个包含局部静态对象的非成员函数，你==可能会使程序的静态对象的拷贝超过一个==。

:two:我们可能会认为只需简单地计算**对象的数目**，一旦需要太多的对象，就抛出异常，这样做也许会更好。

```c++
 ...
private:
 static size_t numObjects;
 Printer(const Printer& rhs); // 这里只能有一个 printer，所以不允许拷贝
}; 
-----------------------------------------------
size_t Printer::numObjects = 0;
Printer::Printer()
{
    if (numObjects >= 1) {
        throw TooManyObjects();
    }
    ++numObjects;
}

Printer::~Printer()
{
    --numObjects;
}
```

这种限制建立对象数目的方法有**两个较吸引人的优点**。一个是它是直观的，每个人都能理解它的用途。另一个是很容易推广它的用途，可以允许建立对象最多的数量大于1。 

但是这会存在一个显示的问题，考虑一个派生类`ColorPrinter`，以及：

```c++
Printer p;
ColorPrinter cp; 
```

这两个定义会产生多少` Pritner `对象？答案是**两个**：一个是 `p`，一个是 `cp`。在运行时， 当构造` cp `的基类部分时，会抛出` TooManyObjects`异常。或者`Printer`作为成员被包含在其他类中，也会存在这种错误的**抛异常**。本质上是`Printer`可以存在于**三种不同的环境**：本身、其他派生类的基类、被嵌入到更大的对象中。通常我们只考虑限制第一种情况的数量。

:three:考虑[**1**]的情况，我们可以很容易设计出一个**无法衍生出派生类的类**：

```c++
class FSA {
public:
    // 伪构造函数
    static FSA * makeFSA();
    static FSA * makeFSA(const FSA& rhs);
    ...
private:
    FSA();
    FSA(const FSA& rhs);
    ...
};

FSA * FSA::makeFSA()
{ return new FSA(); }

FSA * FSA::makeFSA(const FSA& rhs)
{ return new FSA(rhs); } 
```

下面这个经过修改的 `Printer `类的代码实现，最多允许 `10 `个 `Printer `对象存在： 

```c++
class Printer {
public:
    class TooManyObjects{};
    // 伪构造函数
    static Printer * makePrinter();
    static Printer * makePrinter(const Printer& rhs);
    ...
private:
    static size_t numObjects; 
    static const size_t maxObjects = 10; // 见下面解释
    Printer();
    Printer(const Printer& rhs);
};

// Obligatory definitions of class statics
size_t Printer::numObjects = 0;
const size_t Printer::maxObjects;

Printer::Printer()
{
    if (numObjects >= maxObjects) {
    	throw TooManyObjects();
    }
    ...
}

Printer::Printer(const Printer& rhs)
{
    if (numObjects >= maxObjects) {
    	throw TooManyObjects();
    }
    ...
}

Printer * Printer::makePrinter()
{ 
	return new Printer; 
}

Printer * Printer::makePrinter(const Printer& rhs)
{ 
	return new Printer(rhs); 
} 
```

:four:一个**具有对象计数功能的基类**。

把**初始化静态成员**撇在一边不说，上述的方法使用起来就像咒语一样灵验，但是另一方面也有些繁琐。如果有大量像 `Printer` 需要**限制实例数量的类**，就必须一遍又一遍地编写一样的代码，每个类编写一次。应该有一种方法能够自动处理这些事情。

很容易地能够编写一个**具有实例计数功能的基类**，然后让像 `Printer `这样的类从该基类继承。我们使用一种更好的方法封装全部的计数功能，不但封装**维护实例计数器的函数**，而且也封装**实例计数器本身**。

```c++
template<class BeingCounted>
class Counted {
public:
    class TooManyObjects{}; // 用来抛出异常
    static int objectCount() { return numObjects; }
    
protected:
    Counted();
    Counted(const Counted& rhs);
    ~Counted() { --numObjects; }
    
private:
	static int numObjects;
 	static const size_t maxObjects;
	void init(); // 避免构造函数的代码重复
};

template<class BeingCounted>
Counted<BeingCounted>::Counted()
{ 
	init(); 
}

template<class BeingCounted>
Counted<BeingCounted>::Counted(const Counted<BeingCounted>&)
{ 
	init(); 
}

template<class BeingCounted>
void Counted<BeingCounted>::init()
{
    if (numObjects >= maxObjects) throw TooManyObjects();
    ++numObjects;
} 
```

现在我们能修改`Printer`类，这样使用 `Counted `模板： 

```c++
class Printer: private Counted<Printer> {
public:
    // 伪构造函数
    static Printer * makePrinter();
    static Printer * makePrinter(const Printer& rhs);
    ~Printer();
    void submitJob(const PrintJob& job);
    void reset();
    void performSelfTest();
    ...
    using Counted<Printer>::objectCount; // 参见下面解释
    using Counted<Printer>::TooManyObjects; // 参见下面解释
    
private:
    Printer();
    Printer(const Printer& rhs);
 }; 
```

`Counted `所做的大部分工作对于 `Printer `的用户来说都是隐藏的，但是这些用户可能很想知道有当前多少 `Printer `对象存在。`Counted `模板提供了 `objectCount `函数，用来提供这种信息，但是因为我们使用 `private` 继承，这个函数在` Printer `类中成为了` private`。为了恢复该函数的` public `访问权，我们使用 `using `声明。

最后还有一点需要注意，必须定义` Counted `内的**静态成员**。对于` numObjects `来说，这很容易——我们只需要在` Counted `的实现文件里定义它即可： 

```c++
template<class BeingCounted> // 定义 numObjects
int Counted<BeingCounted>::numObjects; // 自动把它初始化为 0 
```

对于 `maxObjects `来说，简单的方法就是什么也不做。我们不对` maxObject `进行初始化。而是让**此类的客户端**提供合适的初始化。`Printer`的作者必须把这条语句加入到一个实现文件里：

```c++
const size_t Counted<Printer>::maxObjects = 10;
```



# 3. 条款27：要求或禁止在堆中产生对象:star:

==不在堆中分配对象，从而保证某种类型的类不会发生内存泄漏==。如果你在**嵌入式系统**上工作，就有可能遇到这种情况，发生在嵌入式系统上的**内存泄漏**是极其严重的。

**:one:要求在堆中建立对象** 

让我们先从**必须在堆中建立对象**开始说起。为了执行这种限制，你必须找到一种方法禁止以调用`new`以外的其它手段建立对象。**非堆对象**在定义它的地方被自动构造，在**生存时间**结束时自动被释放，所以只要禁止使用**隐式的构造函数和析构函数**，就可以实现这种限制。

把这些调用变得不合法的一种**最直接的方法**是把**构造函数**和**析构函数**声明为 `private`。 这样做副作用太大。没有理由让这两个函数都是` private`。**最好让析构函数成为 private**， 让构造函数成为 `public`。可以引进一个专用的**伪析构函数**，用来访问真正的**析构函数**。

```c++
class UPNumber {
public:
    UPNumber();
    UPNumber(int initValue);
    UPNumber(double initValue);
    UPNumber(const UPNumber& rhs);
    // 伪析构函数 (一个 const 成员函数， 因为即使是 const 对象也能被释放。)
    void destroy() const { delete this; }
    ...
private:
	~UPNumber();
};

//然后客户端这样进行程序设计：
UPNumber n; // 错误! (在这里合法， 但是当它的析构函数被隐式地调用时，就不合法了)
UPNumber *p = new UPNumber; //正确
...
delete p; // 错误! 试图调用 private 析构函数
p->destroy(); // 正确 
```

**另一种方法**是把**全部的构造函数**都声明为 `private`。这种方法的缺点是一个类经常有许多构造函数，类的作者必须记住把它们都声明为` private`。否则如果这些函数就会由编译器生成，构造函数包括**拷贝构造函数**，也包括**缺省构造函数**。

通过限制访问一个**类的析构函数或它的构造函数**来阻止建立**非堆对象**，但是在**条款 26** 已经说过，这种方法也禁止了**继承和包容**（containment）。通过把**析构函数**声明为`protected`（同时它的构造函数还保持`public`）就可以解决继承的问题。

:two:**判断一个对象是否在堆中**。​

`UPNumber` 构造函数不可能判断出它是否做为**堆对象的基类**而被调用。也就是说对于`UPNumber`的构造函数来说没有办法侦测到下面两种环境的区别：

```c++
NonNegativeUPNumber *n1 = new NonNegativeUPNumber; // 在堆中
NonNegativeUPNumber n2; //不再堆中
```

或许我们会想到，在`operator new`操作种，设置一个**标志位**，代表是在堆上建立的对象，但是呢，会有诸多问题：例如`new`一个数组、编译器代码执行顺序等问题，具体分析见书。这个思路没有错，我们可以利用这样一个事实：程序的地址空间被做为**线性地址管理**，程序的**栈**从地址空间的**顶部向下扩展**，**堆**则从**底部向上扩展**：

![image-20210701104909460](5. 技巧.assets/image-20210701104909460.png)

在以这种方法管理**程序内存**的系统里（也有很多不是这样），可能会想能够使用下面这个函数来判断**某个特定的地址**是否在堆中： 

```c++
bool onHeap(const void *address)
{
    char onTheStack; // 局部栈变量
    return address < &onTheStack;
} 
```

这个函数背后的思想很有趣。在` onHeap `函数中` onTheSatck `是一个**局部变量**。因此它在**栈**上。当调用 `onHeap` 时，它的**栈框架**（`stack frame`）(也就是它的` activation record`) 被放在**程序栈的顶端**，因为**栈**在结构上是**向下扩展**的（趋向**低地址**），`onTheStack `的地址肯定比**任何栈中的变量或对象**的地址小。如果参数 `address` 的地址小于 `onTheStack `的地址， 它就不会在**栈**上，而是肯定在**堆**上。 

但我们别忘了**静态对象**，一般系统完整的情况如下：

![image-20210701105415776](5. 技巧.assets/image-20210701105415776.png)

而我们貌似完美的`onHeap`不能辨别**堆对象**和**静态对象**。继续修补程序？令人伤心的是不仅**没有一种可移植的方法**来判断对象**是否在堆上**，而且连能在多数时间正常工作的**“准可移植”的方法**也没有。

如果你发现自己实在为**对象是否在堆中**这个问题所困扰，一个可能的原因是你想知道**对象是否能在其上安全调用 delete**。幸运的是，“判断是否能够删除一个指针”比“判断一个指针指向的事物是否在堆上”要容易。因为对于前者我们只需要一个` operator new `返回的**地址集合**。

```c++
void *operator new(size_t size)
{
 void *p = getMemory(size); //调用一些函数来分配内存，处理内存不够的情况
 把 p 加入到一个被分配地址的集合;
 return p;
}

void operator delete(void *ptr)
{
    releaseMemory(ptr); // return memory to free store
    从被分配地址的集合中移去 ptr;
}

bool isSafeToDelete(const void *address)
{
    返回 address 是否在被分配地址的集合中;
} 
```

有**三种因素**制约着对这种设计方式的使用（具体见书）。更好的方法是使用一种抽象`mixin`基类

```c++
class HeapTracked { // 混合类; 跟踪从 operator new 返回的 ptr
public: 
    class MissingAddress{}; // 异常类，见下面代码
    virtual ~HeapTracked() = 0;
    static void *operator new(size_t size);
    static void operator delete(void *ptr);
    bool isOnHeap() const;
    
private:
    typedef const void* RawAddress;
    static list<RawAddress> addresses;
}; 
```

```c++
// mandatory definition of static class member
list<RawAddress> HeapTracked::addresses;

// HeapTracked 的析构函数是纯虚函数，使得该类变为抽象类。
// (参见 Effective C++条款 14). 然而析构函数必须被定义，所以我们做了一个空定义。.
HeapTracked::~HeapTracked() {}

void * HeapTracked::operator new(size_t size)
{
    void *memPtr = ::operator new(size); // 获得内存
    addresses.push_front(memPtr); // 把地址放到 list 的前端
    return memPtr;
}

void HeapTracked::operator delete(void *ptr)
{
    //得到一个 "iterator"，用来识别 list 元素包含的 ptr；有关细节参见条款 35
    list<RawAddress>::iterator it = find(addresses.begin(), addresses.end(), ptr);
    // 如果发现一个元素则删除该元素
    if (it != addresses.end()) { 
        addresses.erase(it); 
        ::operator delete(ptr); 
    } 
    else { 
        // 否则 ptr 就不是用 operator new 分配的，所以抛出一个异常
        throw MissingAddress();
    }
}

bool HeapTracked::isOnHeap() const
{
    // 得到一个指针，指向*this 占据的内存空间的起始处，有关细节参见下面的讨论
    const void *rawAddress = dynamic_cast<const void*>(this);
    // 在 operator new 返回的地址 list 中查到指针
    list<RawAddress>::iterator it = find(addresses.begin(), addresses.end(), rawAddress);
    return it != addresses.end();
} 
```

使用这个类，即使是最初级的程序员也可以在类中加入**跟踪堆中指针**的功能。他们所需要做的就是让他们的类从` HeapTracked` 继承下来。例如我们想判断` Assert `对象指针指向的是否是**堆对象**： 

```c++
class Asset: public HeapTracked {
private:
    UPNumber value;
    ...
}; 
```

`HeapTracked `这样的**混合类**有一个缺点，它不能用于**内建类型**。

:three:**禁止堆对象** 

与此相反的领域是“**禁止在堆中建立对象**”。通常对象的建立这样**三种情况**：对象被直接实例化；对象做为派生类的基类被实例化；对象被嵌入到其它对象内。我们将按顺序地讨论它们。

**禁止用户直接实例化对象很简单**，因为总是调用` new `来建立这种对象，你能够禁止用户调用` new`。你不能影响 `new `操作符的**可用性**，但是你能够利用` new `操作符总是调用 `operator new `函数这点（参见条款 M8），来达到目的。可以自己声明这个函数，而且可以把它声明为` private`。

```c++
class UPNumber {
private:
    static void *operator new(size_t size);
    static void operator delete(void *ptr);
    ...
}; 

//test
UPNumber n1; // okay
static UPNumber n2; // also okay
UPNumber *p = new UPNumber; // error! attempt to call private operator new
```

把 `operator new `声明为 `private `就足够了，但是把 `operator new `声明为` private`，而 把` operator delete `声明为` public`，这样做有些怪异，所以除非有绝对需要的原因，否则不要把它们分开声明。

有趣的是，把 `operator new` 声明为` private `经常会阻碍` UPNumber` 对象做为一个位于**堆中的派生类对象的基类**被实例化。因为` operator new `和 `operator delete` 是==自动继承的==， 如果 `operator new `和 `operator delete `没有在派生类中被声明为 `public`（ overwrite），它们就会继承基类中` private `的版本。 

`UPNumber` 的 `operator new `是` private `这一点，不会对包含 `UPNumber` 成员对象的**对象的分配**产生任何影响： 

```c++
class Asset {
public:
    Asset(int initValue);
    ...
        
private:
 	UPNumber value;
};

Asset *pa = new Asset(100); // 正确, 调用Asset::operator new 或::operator new, 不是UPNumber::operator new 
```

正像没有可移植的方法来判断地址是否在堆中一样，也没有可移植的方法判断地址**是否不在堆中**，但学下上诉技巧总是好的。



# 4. 条款28：灵巧指针

:one:就是智能指针，一般模板如下：

```c++
template<class T>	//灵巧指针对象模板
class SmartPtr {
public:
    SmartPtr(T* realPtr = 0); // 建立一个灵巧指针, 指向 dumb pointer 所指的对象。未初始化的指针缺省值为 0(null)
    SmartPtr(const SmartPtr& rhs); // 拷贝一个灵巧指针
    ~SmartPtr(); // 释放灵巧指针
    SmartPtr& operator=(const SmartPtr& rhs);
    T* operator->() const; // dereference 一个灵巧指针以访问所指对象的成员
    T& operator*() const; // dereference 灵巧指针
    
private:
 	T *pointee; // 灵巧指针所指的对象
}; 
```

:two:灵巧指针的构造、赋值和析构。​

灵巧指针**拷贝构造函数**、**赋值操作符函数**和**析构函数**的实现由于（所指对象的）所有权的问题所以有些复杂。如果一个灵巧指针拥有它指向的对象，当它被释放时必须负责删除这个对象。

看一下标准C++类库中` auto_ptr `模板

```c++
template<class T>
class auto_ptr {
public:
    auto_ptr(T *ptr = 0): pointee(ptr) {}
    ~auto_ptr() { delete pointee; }
    ...
private:
	T *pointee;
}; 
...
auto_ptr<TreeNode> ptn1(new TreeNode);
auto_ptr<TreeNode> ptn2 = ptn1; // 调用拷贝构造函数会发生什么情况？
auto_ptr<TreeNode> ptn3;
ptn3 = ptn2; // 调用 operator=;会发生什么情况?
```

如果我们只拷贝内部的` dumb pointer`，会导致两个` auto_ptr `指向一个相同的对象。这是一个灾难，因为当释放` auto_ptr `时每个` auto_ptr `都会删除它们所指的对象。另一种方法是通过调用` new`，建立一个**所指对象的新拷贝**。这确保了不会有许多指向同一个对象的` auto_ptr`，但是建立（以后还得释放）新对象会造成**不可接受的性能损耗**。

:three:如果 `auto_ptr `禁止**拷贝和赋值**，就可以消除这个问题，但是采用“当 auto_ptr 被拷贝和赋值时，对象所有权随之被传递”的方法，是一个**更具灵活性的解决方案**： 

```c++
template<class T>
class auto_ptr {
public:
    ...
    auto_ptr(auto_ptr<T>& rhs); // 拷贝构造函数
    auto_ptr<T>& operator=(auto_ptr<T>& rhs);
    ...
};

template<class T>
auto_ptr<T>::auto_ptr(auto_ptr<T>& rhs)
{
    pointee = rhs.pointee; // 把*pointee 的所有权传递到 *this
    rhs.pointee = 0; // rhs 不再拥有任何东西
}

template<class T>
auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)
{
    if (this == &rhs) // 如果这个对象自我赋值什么也不要做
        return *this; 
    delete pointee; // 删除现在拥有的对象
    pointee = rhs.pointee; // 把*pointee 的所有权从 rhs 传递到 *this
    rhs.pointee = 0;
    return *this;
} 
```

:four:智能指针的**析构函数**（简单版本）通常是这样：

```c++
template<class T>
SmartPtr<T>::~SmartPtr()
{
    if (*this owns *pointee) {
        delete pointee;
    }
} 
```

:five:让我们把注意力转向智能指针的核心部分，`operator*`和`operator->`函数。前者返回所指的对象：

```c++
template<class T>
T& SmartPtr<T>::operator*() const
{
    perform "smart pointer" processing;
    return *pointee;
} 
```

注意**返回类型**是一个**引用**。理由和之前的各个相关条款大致相同。

```c++
template<class T>
T* SmartPtr<T>::operator->() const
{
    perform "smart pointer" processing;
    return pointee;
} 
```

:six:测试灵巧指针是否为`NULL`​

目前为止我们讨论的函数能让我们建立、释放、拷贝、赋值、`dereference` 灵巧指针。 但是有一件我们做不到的事情是：发现灵巧指针为` NULL`。

在灵巧指针类里加入一个 `isNull `成员函数是一件很容易的事，但是没有解决当测试` NULL `时**灵巧指针的行为**与 `dumb pointer `不相似的问题。另一种方法是提供**隐式类型转换操作符**，允许编译上述的测试。一般应用于这种目的的类型转换是 `void* `：

```c++
template<class T>
class SmartPtr {
public:
 ...
 operator void*(); // 如果灵巧指针为 null，返回 0， 否则返回非 0。
 ... 
}; 
SmartPtr<TreeNode> ptn;
...
if (ptn == 0) ... // 现在正确
if (ptn) ... // 也正确
if (!ptn) ... // 正确
```

它有一个缺点：在一些情况下虽然大多数程序员希望它调用失败，但是函数确实能够成功地被调用（参见条款 M5）。特别是它允许灵巧指针与完全不同的类型之间进行比较： 

```c++
SmartPtr<Apple> pa;
SmartPtr<Orange> po;
...
if (pa == po) ... // 这能够被成功编译! 
```

有一种**两全之策**可以提供合理的测试` null `值的语法形式，同时把不同类型的灵巧指针之间进行**比较的可能性**降到最低。这就是在灵巧指针类中重载 `operator!`，当且仅当**灵巧指针**是一个**空指针**时，`operator!`返回` true`： 

```c++
template<class T>
class SmartPtr {
public: 
    ...
    bool operator!() const; // 当且仅当灵巧指针是空值，返回 true。
    ... 
};
```

```c++
SmartPtr<TreeNode> ptn;
...
if (!ptn) { 
	...  // ptn 是空值
}
else {
	... // ptn 不是空值
}

if (ptn == 0) ... // 仍然错误
if (ptn) ... // 也是错误的 

//仅在这种情况下会存在不同类型之间进行比较
SmartPtr<Apple> pa;
SmartPtr<Orange> po;
...
if (!pa == !po) ... // 能够编译
```

:seven:把**灵巧指针**转变成` dumb `指针，在**灵巧指针模板**中增加指向` T` 的` dumb `指针的**隐式类型转换操作符**：

```c++
void normalize(Tuple *pt); 

template<class T> // 同上
class DBPtr {
public:
    ...
    operator T*() { return pointee; }
    ...
};
DBPtr<Tuple> pt; 

...
normalize(pt); // 能够运行
```

并且这个函数也消除了**测试空值**的问题：

```c++
if (pt == 0) ... // 正确, 把 pt 转变成Tuple*
if (pt) ... // 同上
if (!pt) ... // 同上 (reprise) 
```

然而，它也有**类型转换函数**所具有的缺点（几乎总是这样，看**条款 M5**）。它使得用户能够很容易地直接访问` dumb` 指针，绕过了**“类指针（pointer-like）”对象**所提供的**“灵巧” 特性**:

```c++
void processTuple(DBPtr<Tuple>& pt)
{
    Tuple *rawTuplePtr = pt; // 把 DBPtr<Tuple> 转变成Tuple*
    使用 raw TuplePtr 修改 tuple;
} 
```

通常，**灵巧指针**提供的“灵巧”行为特性是设计中的主要组成部分，所以允许用户使用` dumb` 指针会导致**灾难性的后果**。例如，如果 `DBPtr `实现了条款 M29 中**引用计数**的功能，允 许客户端直接对` dumb `指针进行操作很可能破坏**“引用计数”数据结构**，而导致引用计数错误。

甚至即使你提供一个从**灵巧指针**到` dumb `指针的**隐式转换操作符**，灵巧指针也不能真正地做到与 `dumb `指针互换。因为从**灵巧指针**到` dumb `指针的转换是“**用户定义类型转换**”，在==同一时间编译器进行这种转换的次数不能超过一次==。

而且这种**自定义类型转换**还会暴露一个大`BUG`：

```c++
DBPtr<A> pt = new A;
... 
delete pt;
```

这段代码按理来说不能通过编译，因为我们不能`delete`一个对象（`pt`），但是事实上会通过。因为`delete`时，编译器会尽可能保证程序调用成功，会将`pt`智能指针对象转换为`A*`，然会删除这个堆对象。然后呢？当pt析构时，会再次删除这个堆对象——**一个对象被删除了两次**！

所以说，除非必要，不要使用:seven:的这个方法！

:eight:智能指针和**继承类到基类的类型转换**。

这两者分开来都是好小伙，但是合在一起呢？

```c++
class A;
class B : public A;
class C : public C;
void func(const auto_ptr<A>&);
...
auto_ptr<B> b;
auto_ptr<C> c;
func(b);  //error
func(c);  //error
```

套上**智能指针**之后，它们在**编译器**眼中就不是一家人了。解决方法很简单，核心思想：对于可以进行**隐式类型转换**的每个**智能指针**都提供这样一个操作符：

```c++
class SmartPtr<Cassette> {
public:
    operator SmartPtr<MusicProduct>() 
    { 
        return SmartPtr<MusicProduct>(pointee); 
    } 
...
private:
    Cassette *
}; 
```

这个方法有两个缺点，第一：必须**人为特化**智能指针类。第二：可能必须添加许多**类型转换符**。因为你指向的对象可以位于**继承层次中很深的位置**，你必须为直接或间接继承的**每一个基类**提供一个**类型转换符**。（为什么不仅定义直接基类的转换操作符，然后层层转换？别忘了，==编译器同一时间只进行一次自定义类型的转换操作==）

一个更好的办法是使用==成员模板==：

```c++
template<class T> // 模板类，指向 T
class SmartPtr { // 灵巧指针
public:
    SmartPtr(T* realPtr = 0);
    T* operator->() const;
    T& operator*() const;
    
    template<class newType>
    operator SmartPtr<newType>() 
    {
    	return SmartPtr<newType>(pointee);
    }
    ...
}; 
```

> 假设编译器有一个指向 T 对象的灵巧指针， 它要把这个对象转换成指向“T 的基类”的灵巧指针。编译器首先检查 SmartPtr的类定义，看其有没有声明明确的类型转换符，但是它没有声明。编译器然后检查是否存在一个成员函数模板，并可以被实例化成它所期望的类型转换。它发现了一个这样的模板（带有形式类型参数 newType），所以它把 newType 绑定成 T 的基类类型来实例化模板。这时，惟一的问题是实例化的成员函数代码能否被编译： 指针 pointee 是指向 T 类型的，把它转变成指向其基类（public 或 protected）对象的指针必然是合法的，因此类型转换操作符能够被编译，可以成功地把指向 T 的灵巧指针隐式地类型转换为指向“T 的基类”的灵巧指针。

这种方法可以成功地用于**任何合法的指针类型转换**。如果你有 `dumb`指针 `T1*`和另一种 `dumb` 指针` T2*`，当且仅当你能隐式地把` T1*`转换为 `T2*`时，你就能够隐式地把指向 `T1` 的灵巧指针类型转换为指向 `T2` 的灵巧指针类型。 

总结来说：最好的方法是使用**成员模板**生成**类型转换函数**，在会产生**二义性结果**的地方使用 `casts`。这不是一个完美的方法，不过已经很不错了，在一些情况下需去除**二义性**，所付出的代价与**灵巧指针提供的复杂功能**相比还是值得的。 

:nine:**灵巧指针**和 `const`

具体见书。