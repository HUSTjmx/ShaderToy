# 1. 条款25：将构造函数和非成员函数虚拟化

:one:行为与**构造函数**相似，而且因为它能建立不同类型的对象，我们称它为**虚拟构造函数**。**虚拟构造函数**是指能够根据输入给它的**数据的不同**而建立**不同类型的对象**。（有点像工厂函数）

还有一种特殊种类的虚拟构造函数――**虚拟拷贝构造函数**――也有着广泛的用途。**虚拟拷贝构造函数**能返回一个**指针**，指向调用该函数的对象的**新拷贝**。因为这种行为特性，虚拟拷贝构造函数的名字一般都是`copySelf`。

```c++
class TextBlock: public NLComponent {
public:
    virtual TextBlock * clone() const // virtual copy
    { return new TextBlock(*this); } // constructor
    ...
};

class Graphic: public NLComponent {
public:
    virtual Graphic * clone() const // virtual copy
    { return new Graphic(*this); } // constructor
    ...
}; 
```

:star:上述代码的实现利用了较宽松的==虚拟函数返回值类型规则==。被派生类**重定义的虚拟函数**不用必须与基类的虚拟函数具有一样的**返回类型**。如果函数的返回类型是一个**指向基类的指针**（或一个引用），那么派生类的函数可以返回一个**指向派生类的指针**（或引用）。

:two:**非成员函数**也不能成为真正的虚拟函数，但可以根据**参数的不同动态类型**而其行为特性也不同。

```c++
class Graphic: public NLComponent {
public:
    virtual ostream& print(ostream& s) const;
    ...
};

inline ostream& operator<<(ostream& s, const NLComponent& c)
{
    return c.print(s);
} 
```

**具有虚行为的非成员函数**很简单。你编写一个**虚函数**来完成工作，然后再写一个**非虚函数**，它什么也不做**只是调用这个虚函数**。为了避免这个句法花招引起**函数调用开销**， 可以**内联**这个非虚函数。



# 2. 条款26：限制某个类所能产生的对象数量

:one:先考虑只允许建立**零个或一个**的情况。可以将类的**构造函数**声明为`private`，然后使用一个函数来生成：

```c++
class PrintJob; // forward 声明
 // 参见 Effective C++条款 34
class Printer {
public:
    void submitJob(const PrintJob& job);
    void reset();
    void performSelfTest();
    ...
    friend Printer& thePrinter();

private:
    Printer();
    Printer(const Printer& rhs);
    ...
};

Printer& thePrinter()
{
    static Printer p; // 单个打印机对象
    return p;
} 
```

在`thePrinter`的实现上有两个微妙的不引人注目的地方，值得我们看一看：

- 第一，唯一的`Pritner`对象是位于**函数里的静态成员**而不是在**类中的静态成员**。
  - **类中的静态对象**实际上==总是被构造（和释放），即使不使用该对象==。与此相反，只有第一次执行函数时，才会建立**函数中的静态对象**，所以如果没有调用函数，就不会建立对象。:star:
  - 把 `Printer` 声明为**类中的静态成员**还有一个缺点，它的**初始化时间不确定**。

- 第二个细微之处是**内联**与**函数内静态对象**的关系。**内联**意味着**编译器**用**函数体**替代该对函数的每一个调用。**非成员函数**还有其它的含义。它还意味着 ==internal linkage==（内部链接）。 “**带有内部链接的函数**可能在程序内被**复制**（也就是说**程序的目标代码**可能包含一个以上的内部链接函数的代码），这种复制也包括**函数内的静态对象**。如果建立一个包含局部静态对象的非成员函数，你==可能会使程序的静态对象的拷贝超过一个==。

