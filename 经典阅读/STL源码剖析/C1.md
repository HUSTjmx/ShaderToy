# 1. STL概论



> GNU源代码开放精神





# 2. 空间配置器`allocator`

## 1. 空间配置器的标准接口

根据STL的规范，以下是`allocator`的必要接口：

![image-20210916110303009](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916110303009.png)

![image-20210916110311838](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916110311838.png)



### 1.1 设计一个简单的空间配置器，JJ:allocator

```c++
#include <limits>
#include <iostream>

namespace JJ {
   template <class T>
   class MyAlloc {
     public:
       // type definitions
       typedef T        value_type;
       typedef T*       pointer;
       typedef const T* const_pointer;
       typedef T&       reference;
       typedef const T& const_reference;
       typedef std::size_t    size_type;
       typedef std::ptrdiff_t difference_type;

       // rebind allocator to type U
       template <class U>
       struct rebind {
           typedef MyAlloc<U> other;
       };

       // return address of values
       pointer address (reference value) const {
           return &value;
       }
       const_pointer address (const_reference value) const {
           return &value;
       }

       /* constructors and destructor
        * - nothing to do because the allocator has no state
        */
       MyAlloc() throw() {
       }
       
       MyAlloc(const MyAlloc&) throw() {
       }
       
       template <class U>
         MyAlloc (const MyAlloc<U>&) throw() {
       }
       
       ~MyAlloc() throw() {
       }

       // return maximum number of elements that can be allocated
       size_type max_size () const throw() {
           return std::numeric_limits<std::size_t>::max() / sizeof(T);
       }

       // allocate but don't initialize num elements of type T
       pointer allocate (size_type num, const void* = 0) {
           // print message and allocate memory with global new
           std::cerr << "allocate " << num << " element(s)"
                     << " of size " << sizeof(T) << std::endl;
           pointer ret = (pointer)(::operator new(num*sizeof(T)));
           std::cerr << " allocated at: " << (void*)ret << std::endl;
           return ret;
       }

       // initialize elements of allocated storage p with value value
       void construct (pointer p, const T& value) {
           // initialize memory with placement new
           new((void*)p)T(value);
       }

       // destroy elements of initialized storage p
       void destroy (pointer p) {
           // destroy objects by calling their destructor
           p->~T();
       }

       // deallocate storage p of deleted elements
       void deallocate (pointer p, size_type num) {
           // print message and deallocate memory with global delete
           std::cerr << "deallocate " << num << " element(s)"
                     << " of size " << sizeof(T)
                     << " at: " << (void*)p << std::endl;
           ::operator delete((void*)p);
       }
   };

   // return that all specializations of this allocator are interchangeable
   template <class T1, class T2>
   bool operator== (const MyAlloc<T1>&,
                    const MyAlloc<T2>&) throw() {
       return true;
   }
   template <class T1, class T2>
   bool operator!= (const MyAlloc<T1>&,
                    const MyAlloc<T2>&) throw() {
       return false;
   }
}
```

这里是一个大佬写的代码，但实际和书中的差不多。这里就直接贴了。这个算是最基础的分配器吧。



## 2. 具备次配置力的SGI空间配置器

`Sgi stl` 的配置器与众不同，也与**标准规范**不同，其名称是`a1loc`而非`a1locator` ，而且不接受任何参数。换句话说，如果要在程序中采用**sgi配置器**，则不能采用标准写法：

```c++
vector<int, std: :al1ocator<int> > iv;
```

必须这么写：

```c++
vector<int, std: :alloc> iv;
```



### SGI标准的空间配置器，std::allocator

虽然`SGI`也定义有一个符合部分标准、名为`allocator`的配置器，但`SGI`自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把C++的`::Operator New`和`::Operator delete`做一层薄薄的包装而已。下面是`SGI`的`std::allocator`全貌：

```
//具体见书，没什么好说的
```



### SGI特殊的空间配置器，std:alloc

关于c++内存配置，可以去看`C++ more effective `的条款`8`。

**Stl标准规格**告诉我们，配置器定义于`<Memory>`之中，`<Memory>`内含以下两个文件：

```c++
#include <stl_alloc.h>			//负责内存空间的配置与释放
#include <stl_construct.h>  	//负责对象内容的构造与析构
```

![image-20210916113621157](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916113621157.png)



### 构造和析构基本工具: construct()和destroy()

==平凡析构函数==是不进行任何动作的析构函数。有平凡析构函数的对象不要求 `delete `表达式，并可以通过简单地解分配其存储进行释放。所有与 C 语言兼容的数据类型（POD 类型）都是**可平凡析构的**。

```c++
#include<new.h>  //想使用placement new,需要包含此文件

template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __value) {
  new ((void*) __p) _T1(__value);
}


//版本1
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
  __pointer->~_Tp();
}

//以下是第二版本，接受两个迭代器。此函数设法找出元素的数值型别，
//进而利用求取最适当措施
//__VALUE_TYPE返回_first的类型，返回T*
template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, __VALUE_TYPE(__first));
}

//判断元素的数值型别(值类型)是否有平凡析构函数
template <class _ForwardIterator, class _Tp>
inline void 
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
{
  typedef typename __type_traits<_Tp>::has_trivial_destructor
          _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

//如果元素的数值型别(值类型)有非平凡析构函数
template <class _ForwardIterator>
void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
{
  for ( ; __first != __last; ++__first)
    destroy(&*__first);
}

//如果元素的数值型别(值类型)有平凡析构函数…。
template <class _ForwardIterator> 
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}

//old name
template <class _Tp>
inline void destroy(_Tp* __pointer) {
  _Destroy(__pointer);
}

template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {
  _Destroy(__first, __last);
}

```

![image-20210916115250842](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916115250842.png)

上述`construct()`接受一个指针`p`和一个初值` value`，该函数的用途就是将初值设定到指针所指的空间上。C++的`placement new`运算子可用来完成这一任务。

`destroy()`有两个版本，第一版本接受一个指针，准备将**该指针所指之物**析构掉。这很简单，直接调用该对象的析构函数即可。第二版本接受`first `和` last`两个迭代器，准备将范围内的对象析构掉。

我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒（所谓`trivial destructor`)，那么一次次调用这些无关痛痒的析构函数，对效率是一种伤害。因此，这里首先利用`value_type()`获得迭代器所指对象的型别，再利用`_type_traits<T>`判断**该型别的析构函数是否无关痛痒**。若是，则什么也不做就结束。



### 空间的配置与释放，std:alloc

对象构造前的空间配置，和对象析构后的空间释放，由`<stl_alloc.h>`负责，`SGI`对此的设计哲学如下：

- 向system heap要求空间。
- 考虑**多线程（multi-threads）状态**。
- 考虑内存不足时的应变措施。
- 考虑**过多“小型区块”**可能造成的**内存碎片( fragment）问题**。
  

> 为了代码复杂度不要太高，我们忽略多线程问题

SGI正是以`malloc()`和`free ()`完成**内存的配置与释放**。考虑到**小型区块**所可能造成的**内存破碎问题**，SGI设计了==双层级配置器==，**第一级配置器**直接使用`malloc()`和`free()`，**第二级配置器**则视情况采用不同的策略：

- 当配置区块超过`128` bytes 时，视之为“**足够大**”，便调用**第一级配置器**；
- 当配置区块小于`128` bytes 时，视之为“**过小**”，为了降低额外负担，便采用复杂的`memory pool`整理方式，而不再求助于**第一级配置器**。

整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于`__USE_MALLOC`是否被定义。

![image-20210916120922228](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916120922228.png)

其中`__malloc_alloc_template`就是第一级配置器，`__default_alloc_template `就是第二级配置器。再次提醒你注意，`alloc` 并不接受任何**template型别参数**。

无论`alloc`被定义为第一级或第二级配置器，`SGI `还为它再包装一个接口如下，使**配置器的接口**能够符合**STL规格**：

```c++
template<class _Tp, class _Alloc>
class simple_alloc {

public:
    static _Tp* allocate(size_t __n)
      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }
    static _Tp* allocate(void)
      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }
    static void deallocate(_Tp* __p, size_t __n)
      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }
    static void deallocate(_Tp* __p)
      { _Alloc::deallocate(__p, sizeof (_Tp)); }
};
```

其内部`4`个成员函数其实都是**单纯的转调用**，调用传递给配置器（可能是第一级也可能是第二级）的成员函数。

![image-20210916121355610](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916121355610.png)

![image-20210916121432389](C:\Users\xueyaojiang\AppData\Roaming\Typora\typora-user-images\image-20210916121432389.png)



### 第一级配置器__m alloc_alloc_template剖析

```c++
template <int __inst>
class __malloc_alloc_template {

private:

  //以下都是函数指针，所代表的函数将用来处理内存不足的情况
  static void* _S_oom_malloc(size_t);
  static void* _S_oom_realloc(void*, size_t);
#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
  static void (* __malloc_alloc_oom_handler)();
#endif

public:

  static void* allocate(size_t __n)
  {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }

  static void deallocate(void* __p, size_t /* __n */)
  {
    free(__p);
  }

  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)
  {
    void* __result = realloc(__p, __new_sz);
    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);
    return __result;
  }

  //以下仿真C++的set_new_handler( )。换句话说，你可以通过它
  //指定你自己的out-of-memory handler
  static void (* __set_malloc_handler(void (*__f)()))()
  {
    void (* __old)() = __malloc_alloc_oom_handler;
    __malloc_alloc_oom_handler = __f;
    return(__old);
  }

};


// malloc_alloc out-of-memory handling
//初值为0。有待客端设定
#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
template <int __inst>
void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;
#endif


template <int __inst>
void* __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {			//不断尝试释放、配置、再释放、再配置…
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();  //调用处理例程，企图释放内存
        __result = malloc(__n);	   //再次尝试配置内存
        if (__result) return(__result);
    }
}

template <int __inst>
void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {			//不断尝试释放、配置、再释放、再配置…
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();		//调用处理例程，企图释放内存
        __result = realloc(__p, __n);	//再次尝试配置内存
        if (__result) return(__result);
    }
}

//注意，以下直接将参数inst指定为О
typedef __malloc_alloc_template<0> malloc_alloc;
```

**第一级配置器**以malloc ( ) , free ( ) , realloc( )等C函数执行实际的内存配置、释放、重配置操作，并实现出类似C++new-handler”的机制。是的，它不能直接运用C++ new-handler机制，因为它并非使用:: operator new来配置内存。

