[toc]





# Screen-Space Bent Cones: A Practical Approach (For AO)

![image-20210805115938926](C5.assets/image-20210805115938926.png)

我们描述了如何计算`bent normals`，作为`SSAO`的一个廉价副产品。`Bent cones`扩展了`bent normals`以进一步**提高真实性**。这些扩展将**AO的速度和简单性**与**物理上更合理的照明**结合起来。

## 1. 介绍

AO是一种在**物理上不正确但在感知上可信**的**GI近似**。缺乏方向性在视觉上会令人不快，并留下改进的空间。为此，Landis引入了所谓的`bent normals`。虽然`AO`存储的是**平均闭塞度**，但`bent normals`是根据对**最不闭塞的方向的估计**而弯曲的**修正法线**，换句话说，是==平均不闭塞的方向==。

通常情况下，`bent normals`可以很容易地集成到渲染引擎中；唯一需要改变的是**应用法线的弯曲**。通过与相应的AO值相乘来调整弯曲法线的长度，可以在着色计算中**自动整合AO**

在本章中，我们将描述**一种扩展SSAO的技术**。我们的想法是通过依赖屏幕空间的解决方案来保持SSAO的简单性，但增加了`bent normals`的优点。此外，我们还引入了一个新的扩展来进一步提高精确度：`bent cones`。`bent cones`通过存储其**方向的平均值和方差**来捕捉**未排除方向的分布**。



## 2. AO

![image-20210805120530399](C5.assets/image-20210805120530399.png)

Landis使用**基于光线追踪的蒙特卡洛积分**来计算**AO的半球形积分**。`bent normals`的概念也可以追溯到Landis的工作中，在那里它被作为**AO的概括**而提出。`bent normals`是以**平均闭塞度**为尺度的**平均自由方向**，用来**代替法线**进行着色。与`AO`不同的是，它们的定义包括**积分内的方向**`ω`：

![image-20210805120908118](C5.assets/image-20210805120908118.png)

在光照计算中，`bent normals`只是取代了**表面法线和可见度项**：

![image-20210805180058032](C5.assets/image-20210805180058032.png)

在`bent normals`的情况下，**可见度**必须与**方向**相乘，使用`bent normals` $N(x)$​的蒙特卡洛计算，与单独的`AO`相比，计算简单而高效。`SSAO`是基于延迟着色的。我们建议使用`bent cones`，它很容易集成和编程，并能快速产生**平滑的照明**。

通常情况下，`SSAO`是通过计算一个像素`i`的随机点样本`S`的**闭塞情况**来计算的。我们暂时不考虑图像的二维结构，用一维索引`i`来列举所有像素。每个样本都要根据**深度缓冲区**进行测试，以检查是否被离摄像机更近的物体遮挡。如果样本`S`分布在上半球，每个样本$S_i$本身都会被测试**是否有遮挡**。而如果样本`S`是直接选择在`i`的一个**像素邻域**，则检查$S_i$​的**背投点**`back-projected point`是否遮挡了`i`的背投点。

对于一个像素`i`，我们比较它的**相机空间位置**$x_i$​和其他像素的相机空间位置$x_j$​：{**1**}

![image-20210806100952380](C5.assets/image-20210806100952380.png)

其中：$\Delta_{ij}:=x_j-x_i$​。直观地说，这个函数对于**阻塞的像素**来说是`0`，否则就是`1`，这取决于它们的**相对位置**，尤其是它们的**相对深度**。$d(∆)$的一个可能实现是$dx(∆)$，定义为：

![image-20210806102240967](C5.assets/image-20210806102240967.png)

如果$∆.z$​大于$z_{max}$​​​，通过考虑**不应该投射阴影的离群值**，以及通过包括第`i`个像素的法线可以进行改进：

![image-20210806102435232](C5.assets/image-20210806102435232.png)

还可以根据**遮挡者的距离和角度**，用一些**衰减函数**来代替**二元函数**`d`，这将导致**更平滑的AO**。`SSAO`的==基本假设==是，将 "附近 "的遮挡者的**遮挡量相加**，接近于**真实的可见度**。然而，==能见度是一个非线性效应==：在一个方向上，两个遮挡者彼此之间的遮挡不会投下两次阴影。因此，其他方法是通过**深度缓冲区中的射线行进**，为屏幕空间中的一组方向找到**正确的遮挡**。



## 3. 我们的技术

![image-20210806103608658](C5.assets/image-20210806103608658.png)

### Bent Normals

我们的技术与所使用的**SSAO类型**大多是**正交的**。我们不只是计算第`i`个像素的AO（公式`1`），而是另外计算一个新的法线$N_{ss}$。背后的==基本原理==是，在**屏幕空间**计算`AO`时，方向$∆_{ij}$​是已知的，可以用来累积一个定义`bent normals`的**无遮挡方向**。因此，我们只需将样本所定义的**归一化的未遮挡方向**相加，并将得到的向量除以**未被遮挡的方向数**：{**2**}

![image-20210806103204971](C5.assets/image-20210806103204971.png)

由此产生的`bent normals`是$x_i$​处**未遮挡方向的平均值**。

### Bent Cones

`Bent Cones`是由一个`bent normals augmented by an angle`。由于**未遮挡方向的平均值**给出了`bent normals`，**方差**定义了`angle`。然而，方向需要使用==方向统计==，而不是欧几里得空间中的线性统计。为此，我们使用了一种类似于von Mises-Fisher（vMF）分布中方差计算的方法。在那里，方差是由**非归一化**的`bent normals`的长度近似计算出来的。虽然**vMF分布**是针对球体定义的，但我们估计的是半球上的分布。这导致了对**角度的简单估计**，对应于**未遮挡方向的方差**为：

![image-20210806103929689](C5.assets/image-20210806103929689.png)

`bent normals`和`Bent Cones`定义**可见性的球状帽**。下图显示了**可能的无遮挡方向**以及由此产生的`bent normals`和`Bent Cones`。我们将这个上限与计算球形上限内的入射光线的渲染方法结合起来使用，比如**预卷积环境图**。需要注意的是，`clamp`确保了**未遮挡点**的`bent normals`的长度被映射成一个**覆盖整个半球的锥体**。我们只用`Bent Cones`来限制**收集光线的方向**。该`Cone`并不描述**具体的可见度近似值**。我们仍然使用`AO`来估计**整体能见度**。我们可以认为**`cone`描述的是照明颜色，而AO控制的是亮度**。这也使得`cone`不需要非常准确地匹配**实际的能见度配置**。使用一个角度为90度的`cone`意味着只能退回到用`bent normal`进行照明。

![image-20210806104103247](C5.assets/image-20210806104103247.png)

### 渲染

对于使用`Bent Cones`的渲染，使用**预卷积的环境图**，其使用`Bent Cones`进行索引。同样的概念也适用于**辐照量**。众所周知，所涉及的卷积可以得到**非常平滑的结果**，没有明显的噪声，这与游戏的感知要求非常吻合。环境光照的预卷积计算了一个方向性函数 $L_p(n)$​。对于每一个可能的法线`n`：

![image-20210806104847799](C5.assets/image-20210806104847799.png)

为了查询这个**卷积环境图**，`bent normals`被用来代替`n`：

![image-20210806105000454](C5.assets/image-20210806105000454.png)

然而，**预卷积必须假定没有阴影发生**，因为在预卷积的时候，点`X`和它的**可见度**是不知道的。对于`Bent Cones`，我们建议在预卷积中包含一个**代理可见度**，从而形成一个**三变量函数**：

![image-20210806105121013](C5.assets/image-20210806105121013.png)

![image-20210806105234901](C5.assets/image-20210806105234901.png)

该函数存储了角度为$α$的方向`n`上的``Bent Cones``的**出射辐射度**（上图）。如果$w^/$和`n`形成的角度小于$α$，函数$\overline{V}$返回`1`，否则返回`0`。请注意，通过这样做，随着$α$​的增加，预卷积值会变大。为了包括`Bent Cones`，我们查找**适当的卷积环境图**。该项变成：

![image-20210806105453640](C5.assets/image-20210806105453640.png)

方程的最后一部分是对**预卷积的入射光线**进行 "==归一化=="，原因是我们不使用`cone`作为`x`处的**实际可见性的近似值**。相反，我们用它作为一个代理来选择**收集光线的方向**。然后用`AO`来说明**平均能见度**。只有当`AO`和`cone angle`匹配时（$AO(x) = 1 - cos(C(x))$），我们才会得到与使用`cone`作为**可见度近似值**相同的结果。请注意，根据我们对`cone angle`的定义，`spherical cap`通常大于或等于`AO`（$AO(x)≤1-cos(C(x)$）

在实践中，我们将**归一化项**移到**预卷积步骤**。因此，我们将采样限制在`cone`上，这样$\overline{V}(w^/,n,\alpha)$​就会返回`1`，而**归一化**就隐含在其中。因此，我们可以在渲染期间**跳过归一化**（$(1-cos(C(x))^{-1}$​）。在**预卷积过程**中，我们可以通过在所有像素上循环，来精确地进行采样，从而得到一个$O(n^2)$​的复杂度，其中`n`是像素的数量。对于每个输出像素，循环计算所有其他像素的`cone-weighted sum`。如果$\overline{V}(w^/,n,\alpha)$​​返回`0`，则样本被忽略。另外，我们可以使用具有**固定样本集的Monte-Carlo方法**，将复杂性变成$O(nm)$​​，其中`m`是**Monte-Carloc采样的数量**。此

### 几何项

我们使用**启发式方法**将几何项（**入射光线与法线的余弦**）与我们的`Bent Cones`结合起来。**几何项必须是预卷积的一部分**，因为每一个方向的入射光只在此刻已知。 正确地整合几何项将是五维的：二维的平均方向（`bent normals`），一维的锥体角度，二维的表面法线。然而，我们可以通过以下方式近似地计算出正确的几何项 ：

![image-20210806110642585](C5.assets/image-20210806110642585.png)

下图说明了`n`和N(x)之间不同角度的启发式方法。如果$(N(x)-n)≈1$，我们可以使用`bent normals`和入射光线之间的余弦，因此，我们的启发式方法很好地接近了几何项。在另一种情况下，如果$(N(x)-n)<1$​，只使用`bent normals`会导致**可见的假象**。幸运的是，如果法线和`bent normals`发散，我们有一个集中的入射光线，而且`Bent Cones`的角度也很小，因此，$(ω-n)≈(N(x)-n)$。

![image-20210806111114462](C5.assets/image-20210806111114462.png)



## 4. 实现

我们的方法可以与**不同的SSAO技术**结合使用。差异仍然很小，主要取决于采样半径。`Crytek2D SSAO`使用**二维采样模式**在屏幕空间中分布采样。

`Crytek3D `使用**3D采样模式**将样本分布在空间，并投射到屏幕空间。我们在一个半球中生成样本，然后根据`n`使用**正交基**进行转换。另外，我们增加了射线行进，这极大地改善了`AO`和`bent normals`的质量。

HBAO使用随机的三维方向，通过`marched`找到最高的交叉点。我们在**单位盘**上生成样本，应用**随机偏移**，然后根据`n`进行转换。下列清单给出了显示`AO`和`bent normals`如何在像素着色器中计算的伪代码。

```c++
void main() 
{ 
    // get point properties at pixel i 
    vec3 positionX = backproject(depthTexture(pixelCoordinateI), 			inverseViewProjectionMatrix);
    vec3 normalX = normalTexture(pixelCoordinateI); 

    // get ONB to transform samples 
    mat3 orthoNormalBasis = computeONB(normalX); 
    // select samples for pixel out of pattern 
    int patternOffset = getPatternOffset(pixelCoordinateI);

    float ao = 0.0; 
    int validAODirectionCount = 0; 
    vec3 bentNormal = vec3 (0.0); 
    float unoccludedDirections = 0.0;

    for(int index = 0; index < sampleCount; ++index) 
    { 
        vec3 sampleDirection = orthoNormalBasis * getSampleDirection(index , patternOffset);
        bool isOutlier = false; 
        // use float instead of bool and
        // apply a fall -off function to get smooth AO 
        float visibility = 1.0; 

        // this function tests for occlusion in SS 
        // depending on the actual technique 
        // and sample distribution , 
        // the implementation of this function varies 
        checkSSVisibilityWithRayMarchingSmooth( sampleDirection , 
                                               maxOccluderDistance , 
                                               depthTexture , 
                                               inverseViewProjectionMatrix , 
                                               positionX , normalX , 
                                               rayMarchingSteps , 
                                               rayMarchingStartOffset , 
                                               visibility , isOutlier );

        // we have insufficient information in SS 
        // here , we simply ignore samples , 
        // which cannot be handled properly 
        if(!isOutlier) 
        { 
            validAODirectionCount ++; 
            ao += visibility;

            // for bent normals , we assume , 
            // that outlier occluders are NOT real occluders!
            // sum up unoccluded directions 
            // direction may be partially visible 
            // => only counts accordingly
            bentNormal += normalize(sampleDirection) * visibility; 
            unoccludedDirections += visibility;
        }
    }
    ao /= float(validAODirectionCount); 
    bentNormal /= unoccludedDirections;
}
```

***Filtering***

`Bent Cones`通常需要至少**六个样本**以避免**可见的伪影**。很明显，滤波的质量取决于相邻像素的一致性。我们不直接对`bent normals`进行内插，而是计算出法线和`bent normals`之间的**差值**，然后对其进行过滤。然后将这个变化加回到每个像素的**原始高频法线**上。因此，如下图所示，**法线场本身的细节被保留下来**，而`bent`的信息则被传播出去。

![image-20210806112304210](C5.assets/image-20210806112304210.png)

***Preconvolved lighting***

对于**预卷积的环境地图**，我们将$L_p$存储为一个**浮点立方体纹理**。包括可见度的$L_c$的预卷积是**三变量的**，可以使用OpenGL最近的`cube map array`来最有效地存储。这个扩展存储了一个**立方体贴图数组**，可以用一个方向和一个索引来访问。我们将$α$​离散为**八个级别**，并在各级别之间应用**线性滤波**。预卷积的环境图需要一个**高动态范围**，这就是为什么我们选择使用RGB 16位浮点纹理。由于卷积，**低分辨率的立方体地图**提供了足够的质量。

***Practical considerations***

`bent normals`可以用`AO`进行缩放。使用缩放后的`bent normals`进行着色，**AO会自动包含在内**，也避免了进一步的存储需求。对于`Bent Cones`，除了`bent normals`和`AO`之外，不需要额外的存储。对于一些可能的锥体角度，需要一个特殊的预卷积步骤。



# TressFX: Advanced Real-Time Hair Rendering

![image-20210806114017558](C5.assets/image-20210806114017558.png)

