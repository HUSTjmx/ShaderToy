# Environment Mapping with Floyd-Steinberg Halftoning

![Chrome Sphere Placed in Scene of HDRI Map | Environment map, Render image,  Panorama](C2.assets/d7cb52781e7c24d3c674942bfe7f4cdf.jpg)

## 1. 介绍

![image-20210713092035759](C2.assets/image-20210713092035759.png)

![image-20210713092005168](C2.assets/image-20210713092005168.png)

一般想法是使用蒙特卡洛积分：

![image-20210713092121766](C2.assets/image-20210713092121766.png)

正如我们之前在其他地方了解到的，**可见性**$V$是最耗时的。**实时环境映射算法**通常会**忽略这个因素**，从而忽略环境照明的阴影。然而，对于渲染逼真的图像，**这种简化是不可接受的**。因此，在这一章中，我们研究了正确计算包含遮挡的`Environment Mapping `。

毫无疑问，为了性能考虑，我们的**采样数**应该尽可能少。对于一个给定的样本数，==正交误差==取决于两个因素：

- **重要性采样**。密度`p`在多大程度上模仿了积分项？
- **分层**`Stratification`。有限数量样本的**经验分布**在多大程度上遵循由`p`定义的**理论分布**？



## 2. 参数化环境贴图

一个可能的参数化是：用**球面角**$\theta^/,\phi^/$来表达方向$w^/$。其中$\phi^/\in[0,2\pi]$，θ′∈[0，π/2]。然后，**纹理坐标**$(u,v)$从**单位区间**被缩放到这个范围。例如，在**球形照明**的情况下，一个方向被**参数化为**：

![image-20210713093201810](C2.assets/image-20210713093201810.png)

环境贴图明显**不是均匀分布**的，不同的**实体角**∆ω取决于**纹理坐标**`v`：

![image-20210713093417359](C2.assets/image-20210713093417359.png)

**反射辐射度**的积分也可以在**纹理空间**中进行计算：（**分辨率**为$(R_u,R_v)$）

![image-20210713093457366](C2.assets/image-20210713093457366.png)

其中：

![image-20210713093634094](C2.assets/image-20210713093634094.png)

![image-20210713093703797](C2.assets/image-20210713093703797.png)

![image-20210713093802887](C2.assets/image-20210713093802887.png)

当然，考虑环境贴图的所有`texels`实在太耗时，所以我们需要重要性采样。



## 3. 重要性采样

**蒙特卡洛方法**使用**概率密度**来**选择样本点**。根据**重要性抽样**的概念，我们应该找到一个模仿`product form integrand`的密度`p`。为了定义一个合适的密度，我们通常要执行以下**三个主要步骤**：

- 首先，我们决定哪些因子的**乘积形式积分**`product form integrand`将被模仿，并找到一个通常是**矢量值**的积分因子的**标量近似**。在我们的案例中，**环境照明**`E`和**反射系数**`R`是矢量值，因为它们为红、绿、蓝光的波长分配了不同的值。频谱`L`可以·转换为标量，它是红、绿、蓝三色**强度的加权和**。**由此产生的标量近似积分被称为重要性函数**，用`I`表示。请注意，由于环境照度是由纹理定义的，**重要性函数也由二维图像表示**。当我们想强调这一特性时，我们把**重要性函数**称为`importance map`。

  有几种选择来定义**重要性函数**，因为有**不同的选择**来选择那些**被模仿的积分因子**。最简单的方法是==BRDF采样==，它**模仿反射因子的亮度**。另一方面，==光源采样==`Light-source sampling`将**重要性函数**设定为**环境照明的亮度**。最后，==乘积抽样==`product sampling includes`将积分的**一个以上的因子**纳入重要性函数。例如，**重要性函数可以是环境照明和反射因子的乘积的亮度**（双乘积采样），或者它甚至可以包含一个**廉价的可见度因子**，该因子由物体中的一些简单的**代理几何形状**所近似（三乘积采样）。

- 由于**密度**应该被**归一化**，**重要性函数的积分**需要对**整个领域**进行计算。这种计算可以利用这样一个事实：**重要性函数**也被定义为一个**二维数组或纹理**，类似于**环境照明的纹理图**：（请注意，**重要性函数**应该作为**重要性抽样**的一个步骤进行积分。这意味着**重要性函数的计算和积分必须比原始积分要便宜得多**。）

![image-20210713095008328](C2.assets/image-20210713095008328.png)



- 最后，**密度**被定义为**重要性函数**和**归一化常数**的比率：

  ![image-20210713095508845](C2.assets/image-20210713095508845.png)

  ![image-20210713115635305](C2.assets/image-20210713115635305.png)

在构建了`importance map`并计算了**总和**`S`之后，可以用以下简单的方法以**概率密度**`p`抽取样本。我们产生`M`个**统计上独立**的随机数`r1, ... . , rM`，它们**均匀分布在单位区间**内。然后对于每个随机数，扫描`importance map`的二维数组，并将**重要性值**加在一起。这个运行总和与$r_iS$进行比较。当**运行总和**变大时，停止扫描，并将当前`texel`视为样本。可以很容易地看出，这个过程将选择一个`texel`，其**概率与它的值成正比**。

![image-20210713100218483](C2.assets/image-20210713100218483.png)

不幸的是，应用**统计学上独立的随机样本**在许多情况下提供了**糟糕的结果**。为了证明这个问题，我们用**光源采样**来寻找环境地图上的方向性样本（上图）。结果是令人失望的，因为以**与亮度成比例的概率**进行独立的随机`texel`选择，并**不能保证样本组会有很好的分层**。我们在地图的重要部分仍然有很大的空白区域（**欠采样**），而样本组则集中在一个不重要的小区域（**过采样**）。下一节提出的方法有效简单，与简单的随机方法相比，几乎没有开销。



## 4. 解决方案

本章提出的方法的**目标**是：产生模仿`importance map`的==良好分层样本==。它很有效，实施起来也很简单，甚至比随机抽样还要快。所提出的方法是基于这样的认识：**重要性抽样相当于数字半色调**`digital halftoning`。

**半色调**是一种用于在**黑白显示器**上渲染**灰度图像**的技术（见图3.3）。其**原理**是：在较亮的区域放更多的白点，在较暗的区域放更少的白点。一个像素周围区域的**白点的空间密度**预计将与该特定像素的**灰度等级**成**正比**。如果我们把**原始图像的灰度级**看作是一个**重要性函数**，把得到的**图像的白色像素**看作是**样本位置**，那么我们可以看到半色调相当于一个确定性的重要性采样算法。**重要性采样和半色调的等价性源于它们都是频率调制器**。频率调制器的输入是`upscal image`或`importance map`，输出是由输入指定频率的**离散样本集合**。

![image-20210713100443811](C2.assets/image-20210713100443811.png)

这一等价关系适用于**任意的半色调算法**，包括在量化前向原始图像添加**随机噪声**或**周期性图案**的随机和有序半色调方法，或者**误差扩散半色调方法**，其中`Floyd-Steinberg`算法是最有效。误差扩散半色调比随机或有序半色调提供的结果更好，因为它**不是简单地进行独立的局部决策，而是收集和分配信息给邻近的像素**。

因为它考虑到了**邻域的灰度**，所以**采样位置是分层的**，与随机或抖动的方法相比，产生的图像更平滑，减少了噪音。由于这些良好的特性，我们开发了基于`Floyd-Steinberg`方法。

### Floyd-Steinberg Sampler

采样算法采用`importance map`，并计算出所有`texel`的总和`S`。然后，**采样**就是在`map`上执行`Floyd-Steinberg halftoning`，将**阈值**设置为$S/(2M)$，其中`M`是**预期样本的数量**。在下图中，**阈值**和**误差**分别用红线和白条表示。**半色调算法**将**误差值**初始化为`0`，并逐行扫描`map`，在行的末端改变**扫描顺序**。在每个`texel`中，误差值与阈值的比较可能有两种结果。**如果误差不大于阈值，那么这里就不生成样本**（该`texel`变成黑色），误差**保持不变**。**如果误差大于阈值，那么这个texel就是一个样本**。**误差值**减少$S/M$，也就是说，我们计算图3.4中**黑色部分**所代表的**误差的负补数**。

![image-20210713101259095](C2.assets/image-20210713101259095.png)M

在这两种情况下，在进入下一个`texel`之前，该`texel`的**剩余误差**被分配给其**未访问的邻居**。该方法以类似的方式继续进行，直到所有的`texel`都被访问过。

下列清单显示了这个算法的实现，它被优化为**几何着色器**。每次着色器被调用时，它会处理大小为`R.x × R.y`的`importance map`，其值是通过`getImportance`函数查询的。它发出`32`个方向样本，**样本选择的概率**存储在`alpha`通道中。函数`getSampleDir`返回与`importance map`的一个`texel`相关的方向。我们避免维护一个**实际的重要性值数组**，只存储**被带到下一行的重要性**。变量`cPixel`包含要**转移到下一个像素的重要性**，`cDiagonal`必须添加到下一个像素下面，而`cRow`是一个数组，打包成`float4`向量，包含**要添加到下一行像素的重要性**。每一行都以四个像素为单位进行处理，之后可以将收集到的四个变量`acc`的值打包到`cRow`数组中。`cRow`的大小是`RX4`，也就是`importance map`的宽度除以`4`。每次读取`importance map`时，`importance map`被加载到变量`I`中，再加上从邻居那里结转过来的重要性，得到变量`Ip`中修改后的重要性。

```c++
[maxvertexcount (32)] 
void gsSampler( inout PointStream<float4> samples)
{ 
    uint M = 32; 
    float S = 0; 
    
    [loop]
    for(uint v = 0; v < R.y; v++) 
        [loop]
        for(uint u = 0; u < R.x; u++) 
            S += getImportance(uint2(u, v));
    
    float threshold = S / 2 / M; 
    float4 cRow[RX4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; 
    float cPixel = 0, cDiagonal = 0, acc[4]; 
    [loop]
    for(uint j = 0; j < R.y; j++) 
    { 
        uint kper4 = 0; 
        [loop]
        for(uint k = 0; k < R.x; k += 4) 
        { 
            for(uint xi = 0; xi < 4; xi++) 
            { 
                float I = getImportance(uint2(k + xi, j)); 
                float Ip = I + cRow[kper4][xi] + cPixel; 
                if(Ip > threshold) { 
                    float3 dir = getSampleDir(uint2(k + xi, j)); 
                    //存储方向，以及I/S
                    samples.Append(float4(dir, I / S)); 
                    Ip -= threshold * 2;
                } 
                //y轴上的下一个，即（x, y+1)，记得加上(x-1, y)的对角线补误差
                acc[xi] = Ip * 0.375 + cDiagonal; 
                //x轴上的下一个，即（x+1，y)
                cPixel = Ip * 0.375; 
                //对角线，(x+1, y+1)
                cDiagonal = Ip * 0.25;
            } 
            cRow[kper4++] = float4(acc[0], acc[1], acc[2], acc[3]);
        } 
        
        //扫描线算法，先0->n ,然后n->0。
        j++; 
        kper4--; 
        [loop]
        for(int k = R.x - 5; k >= 0; k -= 4)
        { 
            for(int xi = 3; xi >= 0; xi--) 
            { 
                float I = getImportance(uint2(k + xi, j)); 
                float Ip = I + cRow[kper4][xi] + cPixel; 
                if(Ip > threshold ) 
                { 
                    float3 dir = getSampleDir(uint2(k + xi, j)); 
                    samples.Append(float4(dir, I / S)); 
                    Ip -= threshold * 2;
                } 
                acc[xi] = Ip * 0.375 + cDiagonal;
                cPixel = Ip * 0.375;
                cDiagonal = Ip * 0.25;
            } 
            cRow[kper4--] = float4(acc[0], acc[1], acc[2], acc[3]);
        } 
    }
}
```

![image-20210713105255438](C2.assets/image-20210713105255438.png)



### 光源采样的应用

在**光源采样**中，**重要性函数**是基于**环境照度**的，我们还考虑到不同的`texel`对应不同的**立体角**：

![image-20210713105748200](C2.assets/image-20210713105748200.png)

![image-20210713105810858](C2.assets/image-20210713105810858.png)

忽略**余弦加权BRDF**和**可见度**会降低**重要性采样**。但由于**重要性函数**只取决于**光照方向**，与被渲染的点`x`无关，所以对所有被渲染的点只需执行**一次采样**。



### 乘积采样的应用

乘积采样将积分的一个以上的因子纳入重要性函数。请注意，==包含所有因素是不可行的==，因为**重要性的计算必须比积分的计算更便宜**。在**环境映射**中，昂贵的部分是**能见度测试**，所以我们要么忽略重要性中的遮挡，要么用一些更便宜的近似值来代替它。**重要性函数**被定义为：

![image-20210713110548181](C2.assets/image-20210713110548181.png)

其中，$V^,$是**可见项的近似**。**双重乘积抽样** `Double product sampling`设定V˜=1，假设在生成时**环境总是可见的**。另外，我们可以通过计算与**代理几何体**的交点来近似可见性，例如，物体内部的球体。在这种情况下，我们谈论的是**三乘积采样**。我们必须强调的是，近似可见度因子和代理几何体只用于定义`importance map`和生成**重要方向**。不幸的是，要找到一个在物体内部的**简单代理几何体**并不容易。例如，在下图中，将一个球体放入角色的头部是很直接的，但为车轮定义一个代理几何体是很困难的。

![image-20210713110944279](C2.assets/image-20210713110944279.png)

与光源采样不同，现在的**重要性函数**还取决于渲染点`x`，并间接地取决预`x`处的**法向量**。这意味着我们**不能**对所有渲染点的环境图进行**一次全局处理**，而是要对每一个渲染点**重复进行**包括**Floyd-Steinberg半色调**在内的采样过程。因此，在光源取样中，`Floyd-Steinberg`取样器没有开销，但如果**光线追踪**比**重要性图的生成和处理**更昂贵，那么**乘积采样就会产生开销**。



## 思考

看这节的时候，脑子总是忍不住去想BRDF预计算的`split sum`，然后就又去看了`learn opengl`的`IBL`那一节。毕竟两者都是`IBL`，都是对**辐射度方程**下功夫。

就我个人的思考，我们之前比较熟悉的**预计算BRDF**，和这里的算法，在重要性采样上当然是一样的。区别是流程不同：

- 预计算BRDF：选择需要拟合的因子，也就是GGX-NDF项 $\rightarrow$ 根据**低差异序列**产生良好的采样点  $\rightarrow$ 传入对应的重要性采样函数 $\rightarrow$ 返回采样点，计算权重 $\rightarrow$ 累加求和，除以采样数，存入贴图 $\rightarrow$ 实际运算读取。

  重要性采样的数据 ： 入射方向（实际求得是反射方向，转了个弯）。

- 这里的算法，没有预计算：选择需要拟合的因子，例如光源 $\rightarrow$ 遍历重要性map，根据本章算法，决定这个光源值是否为采样点，如果是，存取它的方向和$I/S$ $\rightarrow$ 实际计算。

写的是一坨屎，哎

我们要求解$L(x)=\int f(x)dx=\int A\cdot B \cdot Cdx$，选取$A$做拟合因子，则对应概率密度函数为$pdf=A(x)/\int A(y)dy$。然后我们可以使用**低差异序列**或本文的`Floyd-Steinberg Sampler`产生`M`个**分层良好的采样点**，对于每个采样点，就是计算的值$f(x)/pdf$。最后累积求和，在除以`M`。





# Hierarchical Item Buffers for Granular Occlusion Culling

![Game scene management (4) occlusion culling - Programmer Sought](C2.assets/66f828590b3177a7ef34c5536a76d334.JPEG)

