# Virtual Texture Mapping 101

![image-20210812134933574](C2.assets/image-20210812134933574.png)

## 1. 介绍

==虚拟纹理映射==（`VTM`）是一种将**纹理所需的显存量**减少到**只取决于屏幕分辨率**的技术：对于一个给定的视角，我们只在显存中**保留纹理的可见部分**，在适当的**MIP映射级别**（见下图）。

在本章中，我们将研究如何实现**一个功能齐全的VTM系统**。

![image-20210812135427674](C2.assets/image-20210812135427674.png)



## 2. 虚拟纹理映射

早期的纹理管理方案是为**单一的大纹理**设计的，而最近的**VTM系统**更加灵活，模仿了**操作系统的虚拟内存管理**：纹理被分为小块`tiles`，或`pages`。这些都是**自动缓存的**，并根据**当前渲染视角的需要**加载到`GPU`上。然而，有必要将**对缺失数据的访问**重定向到一个**备用纹理**。这可以防止在渲染中出现 "空洞`holes`"，或者阻塞并等待加载请求的完成。我们的实现受到了Sean Barrett [Barret 08] 的GDC演讲的启发。

如下图所示，我们在每一帧开始时确定哪些`tiles`是**可见的**。我们确定那些没有被缓存的`tiles`，并**从磁盘上请求它们**。在`tiles`被上传到GPU上的`tile cache`后，我们更新一个`indirection texture`或`page table`。最终，我们渲染场景，对**指示纹理**进行初始查找，以确定在`tile cache`中的取样位置。

![image-20210812140006404](C2.assets/image-20210812140006404.png)

**指示纹理**`indirection texture`是**完整虚拟纹理的缩小版**，其中每个`texel`都指向`tile cache`中的一个`tile`。在我们的例子中，`tile cache`只是GPU上的**一个大纹理**，包含相同分辨率的、小的`square tiles`。这意味着**来自不同MIP图层的`tiles`**覆盖了虚拟纹理的**不同大小的区域**，但大大**简化了`tile cache`的管理**。

### Page Fault Generation

对于每一帧，我们确定**可见的tiles**，在其中识别**尚未加载到GPU上的tiles**，并从磁盘上请求它们。**未来的硬件**可能会通过**本地页面故障`page faults`**来简化这一过程，但我们仍然需要确定**可见的tiles**，替换数据并**重新定向内存访问**。

一个简单的方法是用一个**特殊的着色器**来渲染整个场景，该着色器将**虚拟纹理坐标**转换为`tiles ID`。通过渲染场景的实际几何形状，我们可以很容易地处理`occlusion`。然后，**帧缓冲区**被读回来，与其他管理任务一起**在CPU上处理**。由于`tiles`通常覆盖几个像素，因此可以用**较低的分辨率**渲染`tiles ID`，以减少带宽和处理成本。另外，为了预先获取 "很快 "就能看到的`tiles`，可以**稍微增加视场**。相应的**着色器代码**可以在第`5.2`节找到。

### Page Handler

`page handler`从磁盘加载请求的`tiles`，将它们上传到`GPU`上，并更新`indirection texture`。根据**磁盘延迟**和**摄像机的移动**，加载`tiles`可能成为一个瓶颈。为了说明这一点，我们在一个由**单一虚拟纹理**覆盖的大地形上飞行，并在下图中绘制了每帧的时间。考虑到一个**合理的大贴图缓存**，很少有`tiles`被重新查询，平均每帧的I/O和渲染需要不到`10ms`。然而，在第`512`帧，我们把摄像机转了`180`度，然后**继续向后**。这个掉头动作需要超过100个`tiles`，需要`350ms`的时间来加载。

为了保证渲染的顺利进行，我们只需限制每帧更新的`tiles`数量 。对于不在同一帧内的请求，我们**调整指示纹理**，并将**纹理访问**重定向到`tile cache`中最细的`parent tile`。最粗的级别总是存在的，这就把**负载峰值**分散到了几个帧上。如果**更新限制**大于请求`tiles`的**平均数量**，我们保证最终能赶上请求。在我们的例子中，我们在`95%`的帧中请求少于5块`tiles`，并将**上传限制**设置为非常保守的20块`tiles`。

![image-20210812141948959](C2.assets/image-20210812141948959.png)

当然，缺失的`tils`会**降低视觉质量**。因此，我们上传**要求的`tiles`及其所有的祖先**，从粗到细进行**优先排序**。这增加了**缓存更新的总数**，但如下图所示，**图像质量**以一种更平衡的方式得到恢复。

![image-20210812142505818](C2.assets/image-20210812142505818.png)

### 渲染

在对表面进行**纹理处理**时，我们使用**虚拟纹理空间**中的片段的**uv坐标**对`indirection texture`进行快速的**无过滤查询**。这就提供了目标`tiles`在缓存中的位置，以及**它的MIP图层**在`indirection texture`的金字塔中的实际分辨率。由于我们的**tiles上传限制**，后者可能与从**片段的MIP贴图层**计算出来的分辨率不同。我们将`tiles`内部的偏移量添加到`tiles`位置，并从`tile cache`中采样。这个偏移量只是**uv坐标的小数部分**，由实际的分辨率来缩放。

![image-20210812142834532](C2.assets/image-20210812142834532.png)

注意，将**实际分辨率**存储为$log2(actualResolution)$​允许我们使用**8位纹理**。完整的着色器代码包括**正确的纹理梯度的计算**（见第`3.3`节）



## 3. 实现细节

### Page Fault Generation

***MIP map level***

为了计算`tiles`着色器中的`tiles ID`，我们需要**虚拟纹理坐标**和**当前的MIP地图级别**。前者直接是**用内插uvs**，但在`DX 9`和`10`硬件上，我们必须使用**梯度指令**手动计算后者：$ddx=(\frac{\delta u}{\delta x},\frac{\delta v}{\delta x})$​和$ddy=(\frac{\delta u}{\delta y},\frac{\delta v}{\delta y})$​​ 是`x`方向和`y`方向的**uv梯度**。利用它们的**最大长度**，我们计算出**MIP MAP级别**为：

![image-20210812143308680](C2.assets/image-20210812143308680.png)

```c++
float ComputeMipMapLevel(float2 UV_pixels, float scale) 
{
    float2 x_deriv = ddx(UV_pixels); 
    float2 y_deriv = ddy(UV_pixels);
    float d = max(length(x_deriv), length(y_deriv));
    return max(log2(d) - log2(scale), 0);
}
```



```c++
float2 UV_pixels = In.UV * VTMResolution;
float mipLevel = ComputeMipMapLevel(UV_pixels, subSampleFactor); 
mipLevel = floor(min(mipLevel, MaxMipMapLevel));

float4 tileID; 
tileID.rg = floor(UV_pixels / (TileRes * exp2(mipLevel))); 
tileID.b = mipLevel; 
tileID.a = TextureID;
return tileID;
```



### Page Handler

***Compressed tiles***

为了有效的渲染，最好是有一个**DXTC压缩`tile cache`**。它在GPU上需要**更少的内存**，并**减少上传和渲染的带宽**。然而，由于**DXTC的压缩率是固定的**，而且相当低，我们使用`JPEG`存储`tiles`，并在上传前将其**转码为DXTC**。这也使我们能够有选择地降低质量。

***Disk I/O***

在我们的教程实现中，为了简单起见，我们将`tiles`存储为**单独的JPEG文件**。然而，读取许多小文件需要缓慢的搜索，并浪费带宽。因此，将`tiles`打包成一个文件是非常重要的，特别是对于像DVD这样**有大扇区的慢速设备**。可以通过只存`2`个MIP图层和计算`2`个其他的MIP图层来**减少存储需求**：如果要求一个中间层，我们就从更细的层中加载**相应的四页**。

***Cache saturation***

未使用的`tiles`被使用**LRU策略**的新请求的`tiles`所覆盖。然而，**当前的工作集**可能仍然不适合在缓存中。在这种情况下，我们删除那些**对视觉质量影响较小的`tiles`**。我们用低分辨率的`tiles`来替换分辨率最高的`tiles`。这与我们的**渐进式更新策略**相得益彰，并迅速释放了**瓷砖缓存**。

***Tile upload***

将`tiles`上传到GPU的速度应该是很快的。使用`DX 9`，我们创建了一个**可管理的纹理**，并让驱动程序处理**上传至GPU的过程**。

***Indirection texture update***

在`tiles`被上传之后，我们通过从头开始重新创建，来更新`indirection texture`。我们首先在其**MIP贴图金字塔的顶部**初始化一个最低分辨率的`tiles`条目，因此每个片段都有一个**有效的回退**。对于每一个更细的层次，我们复制**父纹理的条目**，但用该层次的`tiles`条目来替换副本，如果它们存在于缓存中的话。我们继续这个过程，直到**完整的嵌套纹理金字塔**被填满（见下图）。

如果`tiles`通常是在单一分辨率下看到的，我们可以只上传**最细的级别**到GPU。这就减少了所需的上传带宽，简化了查找工作，并提高了性能。当每个物体都使用一个独特的纹理时，这就足够了，特别是对于地形渲染。

![image-20210812145500900](C2.assets/image-20210812145500900.png)



### 渲染

虽然用**虚拟纹理**进行渲染是直截了当的，但正确的过滤，特别是在`tiles`边缘的过滤，却不那么明显。纹理空间中相邻的`tiles`在`tile cache`中很可能不是相邻的。如果要使用硬件过滤单元，过滤就特别有挑战性，因为这些过滤单元依赖于**MIP图和正确的梯度**。下面几段描述了如何使用**各向异性的硬件滤波**，如下图所示，各向异性最大为$4:1$。

![image-20210812145820085](C2.assets/image-20210812145820085.png)

***Texture gradients***

当纹理空间中两个相邻的`tiles`在`tile cache`中**不相邻**时，如下图所示，用于最终纹理查找的uv坐标在相邻的片段之间会有**很大的差异**。这就导致了**大的纹理梯度**，图形硬件将使用一个**非常宽的过滤器**进行采样，产生模糊的接缝。为了解决这个问题，我们从原始的虚拟纹理坐标中手动计算梯度，根据`tiles`的`MIP map level`进行缩放，并将其传递给纹理采样器。

![image-20210812145913383](C2.assets/image-20210812145913383.png)

***Tile borders***

即使有了**正确的纹理梯度**，我们仍然要过滤到**邻近的页面**，这些页面很可能包含了完全不同的虚拟纹理部分。为了避免由此产生的**颜色渗漏**，我们需要**添加边框**。我们使用外边界，用一个**四像素的边框**包围我们的$128^2$块瓷砖，使之成为是$136^2$​。这使得分辨率保持在4的倍数，允许我们使用**DXTC**压缩它们，并在硬件中执行$4:1$**各向异性过滤**。

***DXTC border blocks***

如上图所示，给`tiles`添加边界可能会导致**`tiles`边缘**出现**不同的DXTC块**。由于不同的块将被不同地压缩，在虚拟纹理空间中代表相同点的`texels`在两块`tiles`中的值将不一样。这导致了**`tiles`边缘**的颜色渗漏。通过使用一个四像素的外边框，这些与**压缩有关的假象**就会消失。

```c++
//Virtual Texture Lookup 4.

float3 tileEntry = IndTex.Sample(PointSampler, In.UV); 
float actualResolution = exp2(tileEntry.z); 

float2 offset = frac(In.UV * actualResolution) * TileRes;

float scale = actualResolution * TileRes; 
float2 ddx_correct = ddx(In.UV) * scale; 
float2 ddy_correct = ddy(In.UV) * scale;

return TileCache.SampleGrad(TextureSampler, tileEntry.xy + offset, ddx_correct, ddy_correct);
```

