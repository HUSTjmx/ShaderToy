> 形参总是左值，即使其类型是右值引用。

# 1. 条款23：理解std::move和std::forward

:one:这两者都是仅仅**执行强制类型转换**的函数模板。`std::move`无条件的将实参转换成右值（不是移动！），而`std::forward`则仅是在某个特定满足时才执行同一个强制转换。

右值是可以实施移动的，所以在一个对象上实施了`std::move`，就是告诉编译器该对象具备可移动的条件。

:two:如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量，因为针对**常量对象**执行的**移动操作**将一声不响地变换成**复制操作**。或者说，`std::move`不保证**其返回值具备可移动能力​**（前面说的是条件），唯一保证返回右值。

:three:仅当传入的实参被绑定到右值时，`std::forward`才针对该实参实施向**右值类型**的**强制类型转换**。​



# 2. 条款24：区分万能引用和右值引用

:one:`T&&`有两种不同的含义。其中一种含义，理所当然，是**右值引用**：它们仅仅会绑定到右值，而其**主要存在理由**，在于识别出**可移动对象**。

另一种含义，则表示其既可以是**右值引用**，也可以是**左值引用**。既可以绑定`const`对象，也可以是非`const`对象（同volatile对象）。它们几乎可以绑定到万事万物，称之为==万能引用==。万能引用会在两种场景下现身：

+ 第一种是函数模板的形参：

  ```c++
  template<typename T>
  void f(T&& param);		//param是个万能引用
  ```

+ 第二种是`auto`声明：

  ```c++
  auto&& var2 = var1 //var2是个万能引用
  ```

这两个场景的**共同之处**在于：都涉及**类型推导**。那么，如果我们看到了`&&`，却没有涉及类型推导，那么就是个右值引用。

:two:但==类型推导==只是个必要条件，而不是充分条件。​引用声明的形式也必须正确无误，并且该形式被限定得很死，必须正好是`T&&`，像下面就不行：

```c++
template<typename T>
void f(std::vector<T>&& param);		//param是个右值引用
```

而在**函数模板**内，情况会复杂一些，但本质都是要满足上诉条件：

```c++
template<typename T>
class A{
	void func(T&& x); //右值引用，因为到这里的时候，T的类型已经确定了，不需要类型推导
	
	template<typename... BBs>
	void add(BBs&&... a);  //万能引用
};
```

:three:以上似乎都是函数模板的情况，那是因为`auto&&`类型的变量都是**万能引用**。一个NB的写法，用来对任意参数的函数进行计时：

```c++
auto timeFuncInvocation = 
	[](auto&& func, auto&&... params){
		//计时器启动
		std::forward<decltype(func)>(func)(
			std::forward<decltype(params)>(params)..
		);
		//计时器停止，并记录流失的时间
	};
```

