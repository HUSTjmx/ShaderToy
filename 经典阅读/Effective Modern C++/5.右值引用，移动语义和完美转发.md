> 形参总是左值，即使其类型是右值引用。

# 1. 条款23：理解std::move和std::forward

:one:这两者都是仅仅**执行强制类型转换**的函数模板。`std::move`无条件的将实参转换成右值（不是移动！），而`std::forward`则仅是在某个特定满足时才执行同一个强制转换。

右值是可以实施移动的，所以在一个对象上实施了`std::move`，就是告诉编译器该对象具备可移动的条件。

:two:如果想要取得对某个对象执行移动操作的能力，就不要 将其声明为常量，因为针对**常量对象**执行的**移动操作**将一声不响地变换成**复制操作**。或者说，`std::move`不保证**其返回值具备可移动能力​**（前面说的是条件），唯一保证返回右值。

:three:仅当传入的实参被绑定到右值时，`std::forward`才针对该实参实施向**右值类型**的**强制类型转换**。​



# 2. 条款24：区分万能引用和右值引用

:one:`T&&`有两种不同的含义。其中一种含义，理所当然，是**右值引用**：它们仅仅会绑定到右值，而其**主要存在理由**，在于识别出**可移动对象**。

另一种含义，则表示其既可以是**右值引用**，也可以是**左值引用**。既可以绑定`const`对象，也可以是非`const`对象（同volatile对象）。它们几乎可以绑定到万事万物，称之为==万能引用==。万能引用会在两种场景下现身：

+ 第一种是函数模板的形参：

  ```c++
  template<typename T>
  void f(T&& param);		//param是个万能引用
  ```

+ 第二种是`auto`声明：

  ```c++
  auto&& var2 = var1 //var2是个万能引用
  ```

这两个场景的**共同之处**在于：都涉及**类型推导**。那么，如果我们看到了`&&`，却没有涉及类型推导，那么就是个右值引用。

:two:但==类型推导==只是个必要条件，而不是充分条件。​引用声明的形式也必须正确无误，并且该形式被限定得很死，必须正好是`T&&`，像下面就不行：

```c++
template<typename T>
void f(std::vector<T>&& param);		//param是个右值引用
```

而在**函数模板**内，情况会复杂一些，但本质都是要满足上诉条件：

```c++
template<typename T>
class A{
	void func(T&& x); //右值引用，因为到这里的时候，T的类型已经确定了，不需要类型推导
	
	template<typename... BBs>
	void add(BBs&&... a);  //万能引用
};
```

:three:以上似乎都是函数模板的情况，那是因为`auto&&`类型的变量都是**万能引用**。一个NB的写法，用来对任意参数的函数进行计时：

```c++
auto timeFuncInvocation = 
	[](auto&& func, auto&&... params){
		//计时器启动
		std::forward<decltype(func)>(func)(
			std::forward<decltype(params)>(params)..
		);
		//计时器停止，并记录流失的时间
	};
```



# 3. 条款25：针对右值引用使用std::move，针对万能引用使用std::forward

:one:不要倒过来使用，特别是是对于针对万能引用使用`std::move`会引发很多问题：

- 代码膨胀，需要写重载函数
- 运行期效率降低
- 设计的扩展性太差，一个n个参数的函数，可能需要$2^n$个重载函数。

:two:作为按值返回的函数的右值引用和万能引用，也要使用本条款。

```c++
Matrix operator+(Matrix&& lhs, const Matrix& rhs){
	lhs += rhs;
	return std::move(lhs);
}
```

:three:若局部对象可能适用于==返回值优化==（ROV），则请勿针对其实施`std::move`或`std::forward`​

对于ROV，**编译器**若想在一个**按值返回的函数**里省略对**局部对象的复制**（或者移动），则需要满足两个前提条件：

- 局部对象类型和**函数返回值类型**一致；

- 返回的就是**局部对象本身**。

  ```c++
  A getA(){
  	A a;
  	...
  	return a;
  	//不要 return std::move(a);
  }
  ```

  这种时候，如果使用`std::move`，反而会破坏其省略优化，造成额外的消耗。

  哪怕不发生**复制省略**，只要满足前提条件，则`std::move`会隐式被实施于返回的局部对象中。因此，对于这种情况，无论如何，我们都不需要进行显式的`std::move`。



# 4. 条款26：避免依万能引用进行重载

:one:把**万能引用**作为重载候选类型，几乎总会让该重载版本在始料未及的情况下被调用到。

:two:**完美转发构造函数**的问题尤其严重，因为对于**非常量的左值类型**而言，它们一般都会形成相对于**复制构造函数**的更佳匹配，并且他们还会劫持**派生类**中对**基类的复制和移动构造函数**的调用。​



# 5. 条款27：解决条款26（重载万能引用）:star:

:one:抛弃完美转发的方法：使用不同的函数名字、传递`const T&`类型的形参（98写法，也是我熟悉的写法）、传值。

:two:==标签分派==、**模板元编程**的标准构件。具体见书。

:three:`std::enable_if`的使用

> 完美转发效率高、因为它出于和形参声明的类型严格保持一致的目的，会避免创建临时对象。
>
> 但完美转发的报错信息及其不好辨认，转发层数一多，更是让人头大。

:four:`std::is_constructiable`。

