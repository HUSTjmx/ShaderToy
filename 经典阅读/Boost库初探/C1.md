# 1. Library : Conversion

## 1.1 Conversion 库如何改进你的程序？ 

它提供了防止**危险转换**及可复用的**类型转换工具**，其**主要特点**是：

- 可理解、可维护，以及**一致的多态类型转换** 
- **静态向下转型**使用比 `static_cast` 更安全的结构 
- 进行范围判断的数字转换确保**正确的值逻辑**以及**更少的调试时间** 
- **正确且可重用的文字转换**导致更少的编码时间 

**Conversion库**由`4`个转换函数组成，分别提供了**更好的类型安全性**（`polymorphic_cast`）, **更高效的类型安全防护**（`polymorphic_downcast`），**范围检查的数字转换**（`numeric_cast`），以及**文字转换**（`lexical_cast`）。这些函数具有一个重要特点——**类型安全性**，明确无误地表达程序员的意图。

## 1.2 polymorphic_cast 

***boost/cast.hpp***

:one:`C++`中的**多态转型**是用 `dynamic_cast` 来实现的，其有一个缺点是：根据使用的**类型的不同**，会有不同的行为。如果操作的是**引用**，则转型失败**抛出异常**（我想**引用不能为空**应该刻在我们的心里）；操作的是**指针**，则返回**空指针**。这在过去被认为是优点，但如果我们想**统一表示**，所有转型失败都**抛异常**呢？`Boost `提供了 `polymorphic_cast`。它在**转型失败时**总是抛出一个` std::bad_cast` 异常。

> "偶尔可能会不小心**忘了测试指针是否为空**。如果这困扰了你，你可以写一转型函数在转型失败时抛出异常。"

:two:`polymorphic_cast` 的用法类似于` dynamic_cast`，除了在转型失败时总是抛出一个 `std::bad_cast `异常。`polymorphic_cast `的**另一个特点**是它是**一个函数**，必要时**可以被重载**。这个函数**泛化**了要转换的类型，并接受一个要进行转型的参数。 

```c++
template <class Target, class Source>   
polymorphic_cast(Source* p); 
```

要注意的是，`polymorphic_cast` 没有**针对引用类型的版本**。原因是那是` dynamic_cast `已经实现了的，没有必须让` polymorphic_cast` 重复` C++`语言中已有的功能。

:three:有两种典型的使用情况：：从基类向派生类的**向下转型**， 或者**交叉转型**，即从一个基类到另一个基类。例如：这里有两个基类，`base1 `和 `base2`，以及一个从两个基类公有派生而来的类 `derived` 。 

```c++
int main() 
{  
    base1* p1 = new derived; 
    p1->print(); 
    
    try {    
        derived* pD = boost::polymorphic_cast<derived*>(p1);    
        pD->only_here();   
        pD->only_base2();    
        base2* pB = boost::polymorphic_cast<base2*>(p1);    
        pB->only_base2();  
    }  
    catch(std::bad_cast& e) 
    {    
        std::cout << e.what() << '\n';  
    }  
    delete p1; 
}

```

在对**指针类型**使用`dynamic_cast `时，测试**指针的有效性**是一种既乏味又反复的事情，这使得测试很容易被紧张的程序员所忽略掉。差别在于无论何时对指针使用 `dynamic_cast` ，我们都要记住测试**返回的指针是否为空**。

> 技术上， `dynamic_cast `是转型操作符，而 `polymorphic_cast `是函数模板。

:four:如果说**失败的指针转型**不应被视为错误，你就应该使用 `dynamic_cast` 而不是` polymorphic_cast`。 例如，一种常见的情形是使用 `dynamic_cast `来进行**类型确定测试**。使用**异常处理**来进行**类型的转换测试**是**低效的**，代码也很难看。这种情形下` dynamic_cast `就很有用了。

必须记住，其它人将要维护我们写的代码。这意味着我们必须确保代码以及它的意图是**清晰并且易懂的**。这一点可 以通过注释部分地解决，但对于任何人，更容易的方法是不需加以说明的代码。当**指针转型失败**被认为是异常时， `polymorphic_cast `比` dynamic_cast `更能清晰地表明代码的意图，它也导致**更短的代码**。如果转型失败不应被认为是错误，则应该使用 `dynamic_cast` ，这使得` dynamic_cast `的使用更为清楚。

何时使用`polymorphic_cast `和` dynamic_cast`：

- 当一个**多态转型的失败**是预期的时候，使用 `dynamic_cast<T*>`。它清楚地表明转型失败不是一种错误。
- 当一个**多态转型**必须成功以确保逻辑的正确性时，使用`polymorphic_cast<T*>`。它清楚地表明**转型失败是一种错误**。 
- 对**引用类型**执行**多态转型**时，使用`dynamic_cast`。

## 1.3 polymorphic_downcast 

***boost/cast.hpp***

:one:有时 `dynamic_cast` 被认为**太过低效**。执行` dynamic_cast` 需要额外的运行时间。为了避免这些代价，常常会诱使你使用 `static_cast`，它没有这些性能代价。`static_cast `用于**向下转型**可能是**危险的**，并会导致错误，但它的确比 `dynamic_cast` 要快。

`dynamic_cast`会测试**向下转型的结果**，并在失败时返回**空指针**或**抛出异常**，而 `static_cast` 则仅仅执行需要的**指针运算**，并将保证转型有效的责任留给了程序员。`polymorphic_downcast `用` dynamic_cast` 进行了转型测试，但仅是在**调试模式**下； 然后它在**发布模式**下就使用` static_cast` 去执行转型。如果`polymorphic_downcast` 是在**调试模式**下失败的，它对 `dynamic_cast` 产生的**空指针**执行断言并退出。。如果**向下转型**真的是必须的，并且被证实是**性能的瓶颈**，`polymorphic_downcast `就是你需要的。

> 使用 static_cast 进行向下转型的风险：转型总是"成功"的，但**指针可能是无效的**。

:two:`polymorphic_downcast `用于那些你应该用而又不想用 `dynamic_cast `的情形，原因是你确认**将要发生的转型**肯定会成功，而且你需要**提升它带来的性能**。

> 注意：一定要确保使用的 `polymorphic_downcast `所有可能的类型及转换组合**都经过测试**。

```c++
void newer(base* p) {
    // Logic that suggests that p points to derived1 omitted
    derived1* pd = boost::polymorphic_downcast<derived1*>(p);
    // ^-- The above cast will cause an assertion in debug builds
    pd->foo();
}
```



## 1.4 numeric_cast

***boost/cast.hpp***

:one:**整数类型间的转换**经常会产生**意外的结果**。例如， `long`可以拥有比 `short `更大范围的值，那么当从` long `赋值到 `short` 并且` long` 的数值超出了 `short `的范围时会发生什么？答案是**结果是由实现定义的**（比"**你不可能明确知道**"好听一点的说法)。

**相同大小整数间**的**有符号数到无符号数的转换**是好的，只要有**符号数的数值**是**正的**，但如果有符号数的数值是**负的**呢？它将被转换为一个**大的无符号数**，如果这不是你的真实意图，那么就是一个问题了。

` numeric_cast `通过测试**范围是否合理**来确保**转换的有效性**，当**范围超出**时它会**抛出异常**。

:two:`numeric_cast `是一个看起来象**C++的转型操作符**的==函数模板==，它泛化了**目标类型及源类型**。源类型可以从函数的参数**隐式推导**得到。

```c++
char c = boost::numeric_cast<char>(12);
float f = boost::numeric_cast<float>(3.001);
```

一个**最常见的数字转换问题**是将来自一个**更宽范围的值**赋给**范围较窄的类型**。有可能**数值过大或过小**而不能被**目标类型**所表示。我们先从**有符号类型**开始。C++中有**四个内建的有符号类型**：`signed char`、`short int (short)`、`int`、`long int (long)`。

> 想查看你的系统上的类型大小，可以使用 `sizeof(T) `或` std::numeric_limits::max() `和 `std::numeric_limits::min()`.
>
> 当然，==有符号类型与无符号类型的范围是不同的，即使它们有相同的大小。==

上面是按**大小递增**的，除了 `int` 和` long` 通常具有**相同的值范围**。当把一个**有符号整数类型**赋给另一个时，==C++标准==说：*若目标类型为有符号类型，在数值可以被目标类型表示时，值不改变；否则，值为实现定义*

```c++
#include <iostream>
#include "boost/cast.hpp"
#include "boost/limits.hpp"
int main() {
    std::cout << "larger_to_smaller example\n";
    
    // 没有使用numeric_cast的转换
    long l = std::numeric_limits<short>::max();
    short s = l;
    std::cout << "s is: " << s << '\n';
    s = ++l;
    std::cout << "s is: " << s << "\n\n";
    
    // 使用numeric_cast的转换
    try {
        l = std::numeric_limits<short>::max();
        s = boost::numeric_cast<short>(l);
        std::cout << "s is: " << s << '\n';
        s = boost::numeric_cast<short>(++l);
        std::cout << "s is: " << s << '\n';
    }
    catch(boost::bad_numeric_cast& e) {
        std::cout << e.what() << '\n';
    }
}
```

输出是：

```cmake
larger_to_smaller example
s is: 32767
s is: -32768
s is: 32767
bad numeric cast: loss of range in numeric_cast
```

因为**赋值的结果**属于**实现定义的行为**，这取决于你使用的平台。使用我的编译器，它变成了一个**大的负值**，即它被**回绕**了。用了 `numeric_cast`，**第一个转型成功了**，因为数值在范围之内。而**第二个转型却会失败**，结果是抛出一个 `bad_numeric_cast `异常。

> 注意，虽然我们在这里只讨论了**有符号类型**，但**同样的原理**可应用于**无符号类型**。

:three:**无符号整数类型**有一个非常有趣的特性，**任何数值都有可以合法地赋给它们**！对于**无符号类型**而言，无所谓**正或负的溢出**。数值被简单地**对目标类型最大值加一取模**（这种行为通常被称为**数值回绕**`value wrapping`）。什么意思？看如下代码：

```c++
#include <iostream>
#include "boost/limits.hpp"
int main() {
    unsigned char c;
    long l = std::numeric_limits<unsigned char>::max() + 14;
    c = l;
    
    std::cout << "c is: " << (int)c << '\n';
    
    long reduced = l % (std::numeric_limits<unsigned char>::max() + 1);
    std::cout << "reduced is: " << reduced << '\n';
}

//.........output
c is: 13
reduced is: 13
```

如果你真的想要**数值回绕**，就不要使用`numeric_cast`。

:four:**混用有符号和无符号类型**可能很有趣，特别是执行**算术操作**时，普通的赋值也会产生微妙的问题。**最常见的问题**是**将一个负值赋给无符号类型**。结果几乎可以肯定不是你**原来的意图**。另一种情形是从**无符号类型**到同样大 小的**有符号类型**的赋值——人们总是会很容易忘记**无符号类型**可以持有比同样大小的有符号类型**更大的值**。特别是在表达式或函数调用中更容易忘记。阅读如下代码：

```c++
#include <iostream>
#include "boost/limits.hpp"
#include "boost/cast.hpp"
int main() {
    unsigned int ui = std::numeric_limits<unsigned int>::max();
    int i;
    try {
        std::cout << "Assignment from unsigned int to signed int\n";
        i = boost::numeric_cast<int>(ui);
    }
    catch(boost::bad_numeric_cast& e) {
        std::cout << e.what() << "\n\n";
    }
    
    try {
        std::cout << "Assignment from signed int to unsigned int\n";
        i = -12;
        ui = boost::numeric_cast<unsigned int>(i);
    }
    catch(boost::bad_numeric_cast& e) {
        std::cout << e.what() << "\n\n";
    }
}

//...........output
Assignment from unsigned int to signed int
bad numeric cast: loss of range in numeric_cast
Assignment from signed int to unsigned int
bad numeric cast: loss of range in numeric_cast
```

输出清晰地表明了**预期的错误**。==基本的规则==很简单：无论何时在**不同的类型间**执行**类型转换**，都应该使用 `numeric_cast `来**保证转换的安全**。

:five:`numeric_cast `不能帮助我们在**浮点数间的转换**中避免**精度的损失**。原因是`float`，` double` 和` long double `间的转换不像**整数类型间的隐式转换**那样敏感。

```c++
double d = 0.123456789123456;
float f = 0.123456;
try {
    f = boost::numeric_cast<float>(d);
}
catch(boost::bad_numeric_cast& e) {
    std::cout << e.what();
}
```

运行这段代码**不会有异常抛出**。在许多实现中，从`double `到 `float` 的转换都会**导致精度的损失**。当一个**浮点数类型**被转换为一个**整数类型**，它会被截断；小数部分会被扔掉。` numeric_cast `对**截断后的数值**与**目标类型**进行**相同的检查**，就像在两个**整数类型间的检查**一样。

:six:以下情况时使用 numeric_cast: 

-  在**无符号**与**有符号类型**间进行赋值或比较时 
- 在不同大小的整数类型间进行赋值或比较时 
- 从一个**函数返回类型**向一个**数值变量**赋值，为了**预防该函数未来的变化**。



## 1.5 lexical_cast

***boost/lexical_cast.hpp***

所有应用都会使用==字面转换==。我们把**字符串**转为**数值**，反之亦然。许多**用户定义的类型**可以转换为字符串或者由字符串转换而来。你常常是在需要这些转换时才编写代码，而更好的方法是提供一个**可重用的实现**。这就是 `lexical_cast` 的用途所在。

它可以与任何用`operator<< `进行输出的源，以及任何用 `operator<<`进行输入的目标一起工作。

:one:比起调用一堆的**转换子程序**，或者是编写**自己的转换代码**， `lexical_cast `可以更好地为任何**满足它的要求的类型**服务。它的要求就是

- **源类型**必须是**可流输出的** (`OutputStreamable`)——存在一个为该类型定义的 `operator<<`
- 而**目标类型**必须是**可流输入的** (`InputStreamable`)——要求有一个`operator>>`
- 两种类型都必须是**可复制构造的**
- **目标类型**还要是**可缺省构造的**和**可赋值的**。

```c++
#include <iostream>
#include <string>
#include "boost/lexical_cast.hpp"
int main() {
    // string to int
    std::string s = "42";
    int i = boost::lexical_cast<int>(s);
    
    // float to string
    float f = 3.14151;
    s = boost::lexical_cast<std::string>(f);
    
    // literal to double
    double d = boost::lexical_cast<double>("2.52");
    
    // 失败的转换
    s="Not an int";
    try {
        i = boost::lexical_cast<int>(s);
    }
    catch(boost::bad_lexical_cast& e) {
        // 以上lexical_cast将会失败，我们将进入这里
    }
}
```

> 你可能注意到了没有办法控制**转换的格式**；如果需要这种级别的控制，要用`std::stringstream` 

:two:作为使用`lexical_cast `进行**泛型编程**的简单例子，来看一下如何用它创建一个 `to_string `函数。这个函数接受**任何类型的参数**（当然它要符合要求）并返回一个表示该值的 `string `。

```c++
#include <iostream>
#include <string>
#include "boost/lexical_cast.hpp"
template <typename T> 
std::string to_string(const T& arg) {
    try {
        return boost::lexical_cast<std::string>(arg);
    }
    catch(boost::bad_lexical_cast& e) {
        return "";
    }
}

int main() {
    std::string s = to_string(412);
    s = to_string(2.357);
}
```

:three:使类可以用于 `lexical_cast`，一个简单的例子如下：

```c++
class lexical_castable {
public:
    lexical_castable() {};
    lexical_castable(const std::string s) : s_(s) {};
    
    friend std::ostream operator<<
        (std::ostream& o, const lexical_castable& le);
    
    friend std::istream operator>>
        (std::istream& i, lexical_castable& le);
    
private:
    virtual void print_(std::ostream& o) const {
        o << s_ <<"\n";
    }
    virtual void read_(std::istream& i) const {
        i >> s_;
    }
    std::string s_;
};

std::ostream operator<<(std::ostream& o, const lexical_castable& le) {
    le.print_(o);
    return o;
}

std::istream operator>>(std::istream& i, lexical_castable& le) {
    le.read_(i);
    return i;
}

int main(int argc, char* argv[]) {
    lexical_castable le;
    std::cin >> le;
    
    try {
        int i = boost::lexical_cast<int>(le);
    }
    catch(boost::bad_lexical_cast&) {
        std::cout << "You were supposed to enter a number!\n";
    }
}
```



## 1.6 总结

在这一章里，你学习了`Boost.Conversion `库，从 `polymorphic_cast `开始。` polymorphic_cast` 的基本原理是**代码的清晰性和安全性**，它使我们在代码中更灵活地表达我们的意图，与它的竞争者` dynamic_cast `相比它更为安全，因为对**结果指针的测试**很容易忘记。 

接着，你看到了安全的优化，使用 `polymorphic_downcast`, 它在调试模式下增加了类似于` dynamic_cast `的安全性，但却是使用 `static_cast `来进行转换。这样比单独使用` static_cast` 更安全。

` numeric_cast `帮助你避免数值转换中的某些困难。代码的清晰性也得到提高，从而避免了**未定义的行为**以 及实现定义的行为。

 最后一个是 `lexical_cast`—— 没有重复的转换函数。这就是为什么它被提议纳入下一个版本的C++标准库的原因。 它是一个非常小巧的、用于转换不同的可流数据类型的工具。 



# 2. Library : Utility

**有些工具还不够组成它们自己的库**，因此它们与其它实体被集合到一起。这就形成了`Boost.Utility`，收集了一些没有更合适地方存放的、有用的工具。本章介绍`Boost.Utility`中**最基本的以及最广泛使用的工具**。



## 2.1 BOOST_STATIC_ASSERT

***boost/static_assert.hpp***

:one:在**运行期执行断言**可能是你经常用到的，也是非常合理的。它是测试**前置条件**、**后置条件**以及**不变式**的好方法。 **执行运行期断言**有很多不同的方法，但是在**编译期**你**如何进行断言**呢？当然，**唯一的方法**就是**让编译器产生一个错误**，这是很平常的事情，但如何从**错误信息**中获得**有意义的信息**。而且，即使你在一个编译器上找到了办法，也**很难**把它**移植到其它编译器**上。

`BOOST_STATIC_ASSERT`作为它的第一个使用范例，我们来看看如何在**类作用域**中使用它。考虑一个**泛化的类**，它要求**实例化时所用的类型**是一个**整数类型**。现在，我们先提前一点使用另一个Boost库来进行测试，它就是`Boost.Type_traits`，我们使用一个称为` is_integral `的断言，它对**它的参数**执行一个**编译期求值**，正如你从它的名字可以猜到的一样，求值的结果是**表明该类型是否一个整数类型**。

```c++
#include <iostream>
#include "boost/type_traits.hpp"
#include "boost/static_assert.hpp"
template<typename T> 
class only_compatible_with_integral_types {
    BOOST_STATIC_ASSERT(boost::is_integral<T>::value);
};
```

有了这个断言，在实例化类 `only_compatible_with_integral_types `时如果试图使用一个**非整型的类型**，就会导致**一个编译期的失败**。

```c++
only_compatible_with_integral_types<double> test2;
//...
Error: use of undefined type
 'boost::STATIC_ASSERTION_FAILURE<false>'
```

:two:`BOOST_STATIC_ASSERT `也可以用在**函数作用域**中。例如，考虑一个**泛化的函数**，它带有一个**非类型模板参数**，并且该参数只接受`1`至`10`的值。与其在运行期执行断言，我们不如**在编译器使用静态断言**。

```c++
template <int i> 
void accepts_values_between_1_and_10() {
 	BOOST_STATIC_ASSERT(i >= 1 && i <= 10);
}
```

**断言中的表达式必须是一个纯粹的编译期表达式**，也就是说，**表达式中的参数和操作符**都必须被编译器**所认识**。

我们可以在**任何函数**中很方便地测试条件。例如，**一个函数**需要一个**与平台相关的前提条件**，就常常需要一个断言：

```c++
void expects_ints_to_be_4_bytes() {
    BOOST_STATIC_ASSERT(sizeof(int) == 4);
}
```

:three:以下情形下使用 `BOOST_STATIC_ASSERT `： 

-  当条件**可以在编译期进行求值** 

-  对类型的要求可以在编译期表示 

- 你需要对**两个或以上的整型常量间的关系**进行断言

  

## 2.2 checked_delete

***boost/checked_delete.hpp***

**通过指针来删除一个对象**时，**执行的结果**取决于执行删除时**被删除的类型是否可知**。对一个**指向不完整类型的指针**执行`delete` 几乎**不可能有编译器警告**，这会导致**各种各样的麻烦**，由于析构函数可以没有被执行。换句话说，即**进行清除的代码没有被执行**。 `checked_delete `在对象析构时执行一个**静态断言**，测试**类是否可知**，以确保**析构函数被执行**。

:one:它用于删除**动态分配的对象**，对于**动态分配的数组**，同样有一个称为`checked_array_delete `的**模板函数**。这两个函数都要求在**销毁对象时**，这些**被删除的类型必须是可知的**。

```c++
#include "boost/checked_delete.hpp"
class some_class;
some_class* create() {
 	return (some_class*)0;
}
int main() {
    some_class* p = create();
    boost::checked_delete(p2);
}
```

如果你试图编译这段代码，对函数`checked_delete `的实例化将失败，因为` some_class` 是一个**不完整的类型**。但我们的代码中哪里存在**不完整的类型**呢？接下来的章节我们来讨论它。

:two:如果你试图删除一个指针，而该指针指向的是一个带有**非平凡析构函数**的不完整类型，结果将是未定义的行为。

> 不完整的类型：是指**已声明但未定义的类型**。 
>
> **非平凡析构函数**是：类的一个或多个直接基类，或者一个或多个非静态数据成员，**具有用户定义的析构函数**。

`checked_delete `基本上就是**一个判断类是否完整的断言**，它的实现如下：

```c++
template< typename T > 
inline void checked_delete(T * x) {
    typedef char type_must_be_complete[sizeof(T)];
    delete x;
}
```

这里的想法是创建一个` char` 的数组，数组的**元素数量**为` T` 的大小。如果 `checked_delete` 被一个不完整的类型` T `所实例化，**编译将会失败**，因为` sizeof(T) `会返回` 0`，而**创建一个0个元素的数组是非法的**。你也可以用 `BOOST_STATIC_ASSERT `来执行这个断言。

```c++
BOOST_STATIC_ASSERT(sizeof(T));
```

:three:删除一个**动态分配的对象**时，必须调用**它的析构函数**。如果这个类型是不完整的，即只有声明没有定义，那么析构函数可能会没被调用。这是一种潜在的危险状态，所以应该避免它。对于类模板及函数模板，风险会更大，因为无法预先知道会 使用什么类型。使用 `checked_delete` 和` checked_array_delete`， 可以解决这个删除不完整类型的问题。它**没有运行期的额外开销**，只是直接调用`delete`， 因此说 `checked_delete` 带来的**安全性实际上是免费的**。 



