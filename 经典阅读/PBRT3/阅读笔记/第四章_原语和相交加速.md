# Primitives and Intersection Acceleration

要直接呈现的`shape`由`GeometricPrimitive类`表示。这个类将`shape`与其外观属性的描述组合在一起。为了使pbrt的几何和渲染部分能够清晰地分开，这些外观属性被封装在`Material类`中，这将在第9章中描述。

`TransformedPrimitive类`处理了`Shapes`在场景中的两个更普遍的用途：带有==动画变换矩阵==的`shapes`和==对象实例化==。

本章还介绍了`Aggregate类`，它代表了一个可以容纳许多基元的容器。==pbrt==使用这个类作为加速结构的**基础数据结构**，这有助于减少测试射线与场景中所有对象的交集的复杂性。本章描述了两个加速器的实现，一个是==BVHAccel==，基于在场景中物体周围建立一个**层次边界框**，另一个是==KdTreeAccel==，基于**自适应递归空间细分**。虽然已经提出了许多其他的加速结构，但今天几乎所有的射线示踪器都使用这两种结构之一。本章末尾的进一步阅读部分对其他可能性有广泛的参考。



## 1. 基元接口和几何基元

抽象的`Primitive`类是几何处理和渲染子系统之间的桥梁。

```c++
class Primitive {
public: 
       virtual ~Primitive();
       virtual Bounds3f WorldBound() const = 0;
       virtual bool Intersect(const Ray &r, SurfaceInteraction *) const = 0;
       virtual bool IntersectP(const Ray &r) const = 0;
       virtual const AreaLight *GetAreaLight() const = 0;
       virtual const Material *GetMaterial() const = 0;
       virtual void ComputeScatteringFunctions(SurfaceInteraction *isect,
           MemoryArena &arena, TransportMode mode,
           bool allowMultipleLobes) const = 0;
};
```

第一个方法获得世界坐标下的包围盒，最重要的用途之一是将基元置于加速数据结构之下。

接下来的两个方法提供了**射线相交测试**。这两个基类的一个区别是`Shape::Intersect()`在`Float *输出变量`中返回沿着光线到交点的参数距离，而Primitive::Intersect()负责在找到交点时用这个值更新`ray::tMax`。

在找到交点时，基元的`Intersect()`方法也负责初始化附加的`SurfaceInteraction成员变量`，包括指向**射线击中的基元**的指针。

```c++
<<SurfaceInteraction Public Data>>+=  
const Primitive *primitive = nullptr;
```

当这个基元是发光材质时，`AreaLight()`指向一个区域灯，描述此基元的发光贡献，否则为空。

当`GetMaterial()`返回空时，**忽略与基元的射线交点**；基元的功能只是为**参与的介质**勾勒出一个空间。这个方法也被用来通过比较它们的材质指针，来检查两条射线是否相交于同一个对象。

第三个与材料相关的方法，`ComputeScatteringFunctions()`，初始化在表面交点上**材料的光散射特性的表示**。BSDF对象描述了交点处的**局部光散射特性**。其中`TransportMode`参数指明交点处的光追路径起源于相机，还是光源。

该点的**BSDF**和**BSSRDF指针**存储在传递给`ComputeScatteringFunctions()`的`SurfaceInteraction`中：

```c++
<<SurfaceInteraction Public Data>>+=  
BSDF *bsdf = nullptr;
BSSRDF *bssrdf = nullptr;
```

### 几何基元

==GeometricPrimitive类==表示场景中的单个`shape`（如球体）。在用户提供的场景描述中，为每个`shape`分配一个`GeometricPrimitive`。

```c++
class GeometricPrimitive : public Primitive {
public:
       virtual Bounds3f WorldBound() const;
       virtual bool Intersect(const Ray &r, SurfaceInteraction *isect) const;
       virtual bool IntersectP(const Ray &r) const;
       GeometricPrimitive(const std::shared_ptr<Shape> &shape,
               const std::shared_ptr<Material> &material,
               const std::shared_ptr<AreaLight> &areaLight,
               const MediumInterface &mediumInterface)
           : shape(shape), material(material), areaLight(areaLight),
             mediumInterface(mediumInterface) {
       }
       const AreaLight *GetAreaLight() const;
       const Material *GetMaterial() const;
       void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &arena,
           TransportMode mode, bool allowMultipleLobes) const;

private:
       std::shared_ptr<Shape> shape;
       std::shared_ptr<Material> material;
       std::shared_ptr<AreaLight> areaLight;
       MediumInterface mediumInterface;
};
```

多出来的是：==MediumInterface属性==对基元内部和外部参与媒体的信息进行编码。

==Primitive接口==的大部分与几何处理有关的方法都只是转发到相应的**Shape方法**。例如，`GeometricPrimitive::Intersect()`调用其封装的`Shape::Intersect()`方法来做实际的交点测试，并初始化一个`SurfaceInteraction`来描述交点。它还使用返回的**参数化命中距离**来更新`Ray::tMax`成员。在 `Ray::tMax `中存储到最接近交点的距离的好处是，这可以轻松地避免对沿射线的任何基元执行交点测试，这些基元比任何已找到的交点更远。

```c++
bool GeometricPrimitive::Intersect(const Ray &r,   SurfaceInteraction *isect) const {
        Float tHit;
        if (!shape->Intersect(r, &tHit, isect))
            return false;
        r.tMax = tHit;
        isect->primitive = this;
        //Initialize SurfaceInteraction::mediumInterface after Shape intersection
        if (mediumInterface.IsMediumTransition())
            isect->mediumInterface = mediumInterface;
        else
            isect->mediumInterface = MediumInterface(r.medium);
        return true;
}
```

### TransformedPrimitive：对象实例化和动画基元

`TransformedPrimitive` 拥有一个基元，还包括一个 `AnimatedTransform`，它被注入到**底层基元**与其**在场景中的表示**之间。这种额外的变换实现了两个有用的功能：==对象实例化==和==具有动画变换的基元==。

回想一下，第3章的`shape`本身就有**对象到世界的变换**应用于它们。如果一个`shape`被一个`TransformedPrimitive`所持有，那么`shape`的世界空间概念并不是实际的场景世界空间——只有在`TransformedPrimitive`的变换也被应用之后，`shape`才真正在世界空间中。对于这里的应用来说，`shape`完全不知道被应用的额外变换是有意义的。对于动画`shape`来说，在这里将所有动画变换的处理隔离到一个类中，比要求所有`shape`都支持` AnimatedTransform `要简单得多。同样，对于实例基元，让`shape`知道所有实例变换的作用有限：我们不希望 TriangleMesh 为每个实例变换制作一份顶点位置的副本，并将它们全部变换到世界空间，因为这将否定对象实例化所节省的内存。

```c++
class TransformedPrimitive : public Primitive {
public:
       TransformedPrimitive(std::shared_ptr<Primitive> &primitive,
               const AnimatedTransform &PrimitiveToWorld)
           : primitive(primitive), PrimitiveToWorld(PrimitiveToWorld) { }
       bool Intersect(const Ray &r, SurfaceInteraction *in) const;
       bool IntersectP(const Ray &r) const;
       const AreaLight *GetAreaLight() const { return nullptr; }
       const Material *GetMaterial() const { return nullptr; }
       void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &arena,
           TransportMode mode, bool allowMultipleLobes) const {
           Severe("TransformedPrimitive::ComputeScatteringFunctions() shouldn't be called");
       }
       Bounds3f WorldBound() const { 
           return PrimitiveToWorld.MotionBounds(primitive->WorldBound());
       }

private:
       std::shared_ptr<Primitive> primitive;
       const AnimatedTransform PrimitiveToWorld;
};
```

`TransformedPrimitive`的关键任务是将它所实现的**Primitive接口**和**它持有指针的Primitive**进行桥接，核算它所持有的附加变换的效果。`TransformedPrimitive`的`PrimitiveToWorld`变换定义了从这个**特定几何体实例的坐标系**到**世界空间**的变换。如果基元成员有自己的变换，那应该解释为从对象空间到`TransformedPrimitive`的坐标系的变换。完整的向世界空间的转换需要这两种转换一起进行。

因此，`TransformedPrimitive::Intersect()`方法将给定的射线转换为`primitives坐标系`，并将转换后的射线传递到其`Intersect()例程`。如果发现命中，转换后的射线的`tMax值`需要复制到**原始射线**`r`中。

```c++
bool TransformedPrimitive::Intersect(const Ray &r, 
           SurfaceInteraction *isect) const {
        //Compute ray after transformation by PrimitiveToWorld>> 
        Transform InterpolatedPrimToWorld;
        PrimitiveToWorld.Interpolate(r.time, &InterpolatedPrimToWorld);
        Ray ray = Inverse(InterpolatedPrimToWorld)(r);

        if (!primitive->Intersect(ray, isect))
            return false;
        r.tMax = ray.tMax;
        //Transform instance’s intersection data to world space>> 
        if (!InterpolatedPrimToWorld.IsIdentity())
            *isect = InterpolatedPrimToWorld(*isect);
        return true;
}
```

`TransformedPrimitive`的`GetAreaLight()`、`GetMaterial()`和`ComputeScatteringFunctions()`方法不应该被调用。射线实际击中的基元的相应方法应该被调用。



## 2. Aggregates

==加速结构==是任何光线追踪器的==核心组件==之一。如果没有算法来减少不必要的**射线交点测试**的数量，那么追踪一条射线通过场景所需的时间将与场景中基元的数量成**线性关系**，因为射线需要依次对每个基元进行测试，以找到最接近的交点。然而，在大多数场景中，这样做是极其浪费的，因为射线根本不会经过绝大多数基元。**加速结构的目标是允许快速、同时拒绝基元组，并对搜索过程进行排序，以便很可能首先找到附近的交点，从而有可能忽略较远的交点**。

由`ray–object intersections`在射线跟踪器中占了大部分的执行时间，因此对射线交汇加速的算法进行了大量的研究。

大体上，这个问题主要有两种方法：==空间细分==和==对象细分==。

- ==空间细分算法==将三维空间分解为区域，并记录基元与哪些区域重叠。在某些算法中，还可根据重叠的基元数量对区域进行**自适应细分**。当需要找到射线交集时，将计算射线经过的这些区域的序列，并仅测试重叠区域中的基元是否有交集。
- ==对象细分==是基于将场景中的对象逐步分解成更小的组成对象集。例如，一个房间的模型可能被分解为四面墙、一个天花板和一把椅子。如果一条射线不与房间的边界体积相交，那么它的所有基元都可以被剔除。否则，射线将针对它们中的每一个进行测试。例如，如果它击中了椅子的边界体积，那么它可能会针对椅子的每条腿、座位和背部进行测试。否则，椅子就会被剔除。
- 本章中的==KdTreeAccel==是基于空间细分的方法，==BVHAccel==是基于对象细分的方法。、

==Aggregate类==提供了一个将多个`Primitive对象`分组的接口。因为 `Aggregate `本身实现了 `Primitive `接口，所以在 pbrt 的其他地方不需要为**交集加速**提供特殊支持。积分器可以像场景中只有一个`Primitive`一样编写，检查交集，而不需要关心如何真正找到它们。此外，通过这种方式实现加速，只需向 pbrt 添加一个新的` Aggregate 基元`，就可以很容易地试验新的加速技术。

```c++
class Aggregate : public Primitive {
public:
       const AreaLight *GetAreaLight() const;
       const Material *GetMaterial() const;
       void ComputeScatteringFunctions(SurfaceInteraction *isect,
           MemoryArena &arena, TransportMode mode, bool allowMultipleLobes) const;

};
```

与`TransformedPrimitives`一样，Aggregate的`intersection`方法将`SurfaceInteraction::primitive`指针设置为射线实际击中的基元，而不是本身持有的基元。因为pbrt使用这个指针来获取被击中的基元的信息，所以Aggregates的GetAreaLight()、GetMaterial()和ComputeScatteringFunctions()方法永远不应该被调用



## 3. Bounding Volume Hierarchies