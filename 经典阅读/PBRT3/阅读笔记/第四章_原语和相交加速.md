# Primitives and Intersection Acceleration

要直接呈现的`shape`由`GeometricPrimitive类`表示。这个类将`shape`与其外观属性的描述组合在一起。为了使pbrt的几何和渲染部分能够清晰地分开，这些外观属性被封装在`Material类`中，这将在第9章中描述。

`TransformedPrimitive类`处理了`Shapes`在场景中的两个更普遍的用途：带有==动画变换矩阵==的`shapes`和==对象实例化==。

本章还介绍了`Aggregate类`，它代表了一个可以容纳许多基元的容器。==pbrt==使用这个类作为加速结构的**基础数据结构**，这有助于减少测试射线与场景中所有对象的交集的复杂性。本章描述了两个加速器的实现，一个是==BVHAccel==，基于在场景中物体周围建立一个**层次边界框**，另一个是==KdTreeAccel==，基于**自适应递归空间细分**。虽然已经提出了许多其他的加速结构，但今天几乎所有的射线示踪器都使用这两种结构之一。本章末尾的进一步阅读部分对其他可能性有广泛的参考。



## 1. 基元接口和几何基元

抽象的`Primitive`类是几何处理和渲染子系统之间的桥梁。

```c++
class Primitive {
public: 
       virtual ~Primitive();
       virtual Bounds3f WorldBound() const = 0;
       virtual bool Intersect(const Ray &r, SurfaceInteraction *) const = 0;
       virtual bool IntersectP(const Ray &r) const = 0;
       virtual const AreaLight *GetAreaLight() const = 0;
       virtual const Material *GetMaterial() const = 0;
       virtual void ComputeScatteringFunctions(SurfaceInteraction *isect,
           MemoryArena &arena, TransportMode mode,
           bool allowMultipleLobes) const = 0;
};
```

第一个方法获得世界坐标下的包围盒，最重要的用途之一是将基元置于加速数据结构之下。

接下来的两个方法提供了**射线相交测试**。这两个基类的一个区别是`Shape::Intersect()`在`Float *输出变量`中返回沿着光线到交点的参数距离，而Primitive::Intersect()负责在找到交点时用这个值更新`ray::tMax`。

在找到交点时，基元的`Intersect()`方法也负责初始化附加的`SurfaceInteraction成员变量`，包括指向**射线击中的基元**的指针。

```c++
<<SurfaceInteraction Public Data>>+=  
const Primitive *primitive = nullptr;
```

当这个基元是发光材质时，`AreaLight()`指向一个区域灯，描述此基元的发光贡献，否则为空。

当`GetMaterial()`返回空时，**忽略与基元的射线交点**；基元的功能只是为**参与的介质**勾勒出一个空间。这个方法也被用来通过比较它们的材质指针，来检查两条射线是否相交于同一个对象。

第三个与材料相关的方法，`ComputeScatteringFunctions()`，初始化在表面交点上**材料的光散射特性的表示**。BSDF对象描述了交点处的**局部光散射特性**。其中`TransportMode`参数指明交点处的光追路径起源于相机，还是光源。

该点的**BSDF**和**BSSRDF指针**存储在传递给`ComputeScatteringFunctions()`的`SurfaceInteraction`中：

```c++
<<SurfaceInteraction Public Data>>+=  
BSDF *bsdf = nullptr;
BSSRDF *bssrdf = nullptr;
```

### 几何基元

==GeometricPrimitive类==表示场景中的单个`shape`（如球体）。在用户提供的场景描述中，为每个`shape`分配一个`GeometricPrimitive`。

```c++
class GeometricPrimitive : public Primitive {
public:
       virtual Bounds3f WorldBound() const;
       virtual bool Intersect(const Ray &r, SurfaceInteraction *isect) const;
       virtual bool IntersectP(const Ray &r) const;
       GeometricPrimitive(const std::shared_ptr<Shape> &shape,
               const std::shared_ptr<Material> &material,
               const std::shared_ptr<AreaLight> &areaLight,
               const MediumInterface &mediumInterface)
           : shape(shape), material(material), areaLight(areaLight),
             mediumInterface(mediumInterface) {
       }
       const AreaLight *GetAreaLight() const;
       const Material *GetMaterial() const;
       void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &arena,
           TransportMode mode, bool allowMultipleLobes) const;

private:
       std::shared_ptr<Shape> shape;
       std::shared_ptr<Material> material;
       std::shared_ptr<AreaLight> areaLight;
       MediumInterface mediumInterface;
};
```

多出来的是：==MediumInterface属性==对基元内部和外部参与媒体的信息进行编码。

==Primitive接口==的大部分与几何处理有关的方法都只是转发到相应的**Shape方法**。例如，`GeometricPrimitive::Intersect()`调用其封装的`Shape::Intersect()`方法来做实际的交点测试，并初始化一个`SurfaceInteraction`来描述交点。它还使用返回的**参数化命中距离**来更新`Ray::tMax`成员。在 `Ray::tMax `中存储到最接近交点的距离的好处是，这可以轻松地避免对沿射线的任何基元执行交点测试，这些基元比任何已找到的交点更远。

```c++
bool GeometricPrimitive::Intersect(const Ray &r,   SurfaceInteraction *isect) const {
        Float tHit;
        if (!shape->Intersect(r, &tHit, isect))
            return false;
        r.tMax = tHit;
        isect->primitive = this;
        //Initialize SurfaceInteraction::mediumInterface after Shape intersection
        if (mediumInterface.IsMediumTransition())
            isect->mediumInterface = mediumInterface;
        else
            isect->mediumInterface = MediumInterface(r.medium);
        return true;
}
```

### TransformedPrimitive：对象实例化和动画基元

`TransformedPrimitive` 拥有一个基元，还包括一个 `AnimatedTransform`，它被注入到**底层基元**与其**在场景中的表示**之间。这种额外的变换实现了两个有用的功能：==对象实例化==和==具有动画变换的基元==。

回想一下，第3章的`shape`本身就有**对象到世界的变换**应用于它们。如果一个`shape`被一个`TransformedPrimitive`所持有，那么`shape`的世界空间概念并不是实际的场景世界空间——只有在`TransformedPrimitive`的变换也被应用之后，`shape`才真正在世界空间中。对于这里的应用来说，`shape`完全不知道被应用的额外变换是有意义的。对于动画`shape`来说，在这里将所有动画变换的处理隔离到一个类中，比要求所有`shape`都支持` AnimatedTransform `要简单得多。同样，对于实例基元，让`shape`知道所有实例变换的作用有限：我们不希望 TriangleMesh 为每个实例变换制作一份顶点位置的副本，并将它们全部变换到世界空间，因为这将否定对象实例化所节省的内存。

```c++
class TransformedPrimitive : public Primitive {
public:
       TransformedPrimitive(std::shared_ptr<Primitive> &primitive,
               const AnimatedTransform &PrimitiveToWorld)
           : primitive(primitive), PrimitiveToWorld(PrimitiveToWorld) { }
       bool Intersect(const Ray &r, SurfaceInteraction *in) const;
       bool IntersectP(const Ray &r) const;
       const AreaLight *GetAreaLight() const { return nullptr; }
       const Material *GetMaterial() const { return nullptr; }
       void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &arena,
           TransportMode mode, bool allowMultipleLobes) const {
           Severe("TransformedPrimitive::ComputeScatteringFunctions() shouldn't be called");
       }
       Bounds3f WorldBound() const { 
           return PrimitiveToWorld.MotionBounds(primitive->WorldBound());
       }

private:
       std::shared_ptr<Primitive> primitive;
       const AnimatedTransform PrimitiveToWorld;
};
```

`TransformedPrimitive`的关键任务是将它所实现的**Primitive接口**和**它持有指针的Primitive**进行桥接，核算它所持有的附加变换的效果。`TransformedPrimitive`的`PrimitiveToWorld`变换定义了从这个**特定几何体实例的坐标系**到**世界空间**的变换。如果基元成员有自己的变换，那应该解释为从对象空间到`TransformedPrimitive`的坐标系的变换。完整的向世界空间的转换需要这两种转换一起进行。

因此，`TransformedPrimitive::Intersect()`方法将给定的射线转换为`primitives坐标系`，并将转换后的射线传递到其`Intersect()例程`。如果发现命中，转换后的射线的`tMax值`需要复制到**原始射线**`r`中。

```c++
bool TransformedPrimitive::Intersect(const Ray &r, 
           SurfaceInteraction *isect) const {
        //Compute ray after transformation by PrimitiveToWorld>> 
        Transform InterpolatedPrimToWorld;
        PrimitiveToWorld.Interpolate(r.time, &InterpolatedPrimToWorld);
        Ray ray = Inverse(InterpolatedPrimToWorld)(r);

        if (!primitive->Intersect(ray, isect))
            return false;
        r.tMax = ray.tMax;
        //Transform instance’s intersection data to world space>> 
        if (!InterpolatedPrimToWorld.IsIdentity())
            *isect = InterpolatedPrimToWorld(*isect);
        return true;
}
```

`TransformedPrimitive`的`GetAreaLight()`、`GetMaterial()`和`ComputeScatteringFunctions()`方法不应该被调用。射线实际击中的基元的相应方法应该被调用。



## 2. Aggregates

==加速结构==是任何光线追踪器的==核心组件==之一。如果没有算法来减少不必要的**射线交点测试**的数量，那么追踪一条射线通过场景所需的时间将与场景中基元的数量成**线性关系**，因为射线需要依次对每个基元进行测试，以找到最接近的交点。然而，在大多数场景中，这样做是极其浪费的，因为射线根本不会经过绝大多数基元。**加速结构的目标是允许快速、同时拒绝基元组，并对搜索过程进行排序，以便很可能首先找到附近的交点，从而有可能忽略较远的交点**。

由`ray–object intersections`在射线跟踪器中占了大部分的执行时间，因此对射线交汇加速的算法进行了大量的研究。

大体上，这个问题主要有两种方法：==空间细分==和==对象细分==。

- ==空间细分算法==将三维空间分解为区域，并记录基元与哪些区域重叠。在某些算法中，还可根据重叠的基元数量对区域进行**自适应细分**。当需要找到射线交集时，将计算射线经过的这些区域的序列，并仅测试重叠区域中的基元是否有交集。
- ==对象细分==是基于将场景中的对象逐步分解成更小的组成对象集。例如，一个房间的模型可能被分解为四面墙、一个天花板和一把椅子。如果一条射线不与房间的边界体积相交，那么它的所有基元都可以被剔除。否则，射线将针对它们中的每一个进行测试。例如，如果它击中了椅子的边界体积，那么它可能会针对椅子的每条腿、座位和背部进行测试。否则，椅子就会被剔除。
- 本章中的==KdTreeAccel==是基于空间细分的方法，==BVHAccel==是基于对象细分的方法。、

==Aggregate类==提供了一个将多个`Primitive对象`分组的接口。因为 `Aggregate `本身实现了 `Primitive `接口，所以在 pbrt 的其他地方不需要为**交集加速**提供特殊支持。积分器可以像场景中只有一个`Primitive`一样编写，检查交集，而不需要关心如何真正找到它们。此外，通过这种方式实现加速，只需向 pbrt 添加一个新的` Aggregate 基元`，就可以很容易地试验新的加速技术。

```c++
class Aggregate : public Primitive {
public:
       const AreaLight *GetAreaLight() const;
       const Material *GetMaterial() const;
       void ComputeScatteringFunctions(SurfaceInteraction *isect,
           MemoryArena &arena, TransportMode mode, bool allowMultipleLobes) const;

};
```

与`TransformedPrimitives`一样，Aggregate的`intersection`方法将`SurfaceInteraction::primitive`指针设置为射线实际击中的基元，而不是本身持有的基元。因为pbrt使用这个指针来获取被击中的基元的信息，所以Aggregates的GetAreaLight()、GetMaterial()和ComputeScatteringFunctions()方法永远不应该被调用



## 3. Bounding Volume Hierarchies

==边界体积层次结构==(BVHs)是一种基于**基元细分**的射线交汇加速方法，其中基元被分割成**不相干集**的层次结构。图 4.2 显示了一个简单场景的**BVHs**。基元存储在叶子中，每个节点都存储了其下方节点中基元的边界框。

<img src="第四章_基元和相交加速.assets/image-20210409115430655.png" alt="image-20210409115430655" style="zoom:50%;" />

基元细分的一个特点是：每个基元在层次结构中只出现一次（空间细分则相反）。`BVHs`比`kd-tree`更有效，`kd-tree`通常比`BVHs`提供更快的射线相交测试，但需要更长的时间来构建；另一方面，与`kd树`相比，`BVHs`通常在数值上更稳健，更不容易因**舍入误差**而错过相交。

BVH加速器定义在`accelerator`中，除了要存储的基元和**基元的最大数量**外，其构造函数还取一个**枚举值**，用于描述在分割基元以构建树时，要使用的**四种算法**中的哪一种。默认值 ==SAH== 表示应使用第 4.3.2 节中讨论的基于 "表面积启发式 "的算法。另一种方法==HLBVH==（在4.3.3节中讨论）可以更有效地构建树（也更容易并行化），但它构建的树没有SAH那么有效。其余两种方法使用更少的计算来构建树，但创建的树质量相当低。

```c++
<<BVHAccel Public Types>>= 
enum class SplitMethod { SAH, HLBVH, Middle, EqualCounts };

<<BVHAccel Method Definitions>>= 
BVHAccel::BVHAccel(const std::vector<std::shared_ptr<Primitive>> &p,
         int maxPrimsInNode, SplitMethod splitMethod)
     : maxPrimsInNode(std::min(255, maxPrimsInNode)), primitives(p),
       splitMethod(splitMethod) {
    if (primitives.size() == 0)
        return;
    <<Build BVH from primitives>> 
       <<Initialize primitiveInfo array for primitives>> 
          std::vector<BVHPrimitiveInfo> primitiveInfo(primitives.size());
          for (size_t i = 0; i < primitives.size(); ++i)
              primitiveInfo[i] = { i, primitives[i]->WorldBound() };

       <<Build BVH tree for primitives using primitiveInfo>> 
          MemoryArena arena(1024 * 1024);
          int totalNodes = 0;
          std::vector<std::shared_ptr<Primitive>> orderedPrims;
          BVHBuildNode *root;
          if (splitMethod == SplitMethod::HLBVH)
              root = HLBVHBuild(arena, primitiveInfo, &totalNodes, orderedPrims);
          else
              root = recursiveBuild(arena, primitiveInfo, 0, primitives.size(),
                                    &totalNodes, orderedPrims);
          primitives.swap(orderedPrims);
          

       <<Compute representation of depth-first traversal of BVH tree>> 
          nodes = AllocAligned<LinearBVHNode>(totalNodes);
          int offset = 0;
          flattenBVHTree(root, &offset);
}
<<BVHAccel Private Data>>= 
const int maxPrimsInNode;
const SplitMethod splitMethod;
std::vector<std::shared_ptr<Primitive>> primitives;
```

### BVH构建

首先，是BVH基元信息结构体：

```c++
struct BVHPrimitiveInfo {
    BVHPrimitiveInfo(size_t primitiveNumber, const Bounds3f &bounds)
        : primitiveNumber(primitiveNumber), bounds(bounds),
          centroid(.5f * bounds.pMin + .5f * bounds.pMax) { }
    size_t primitiveNumber;
    Bounds3f bounds;
    Point3f centroid;
};
```

现在可以开始构建层次结构。如果选择了**HLBVH构造算法**，就会调用`HLBVHBuild()`来构建树。对这些函数的初始调用会传递所有要存储在树中的基元。它们返回一个指向树根的指针，该指针用`BVHBuildNode`结构表示。树节点应该用提供的`MemoryArena`进行分配，创建的总数应该存储在`*totalNodes`中。

树构建过程的一个重要副作用是，通过 `orderedPrims` 参数返回一个新的**基元指针数组**；该数组存储基元，以便**叶节点中的基元**占据数组中的连续范围。建树后，它将与**原始基元数组**交换。

```c++
<<Build BVH tree for primitives using primitiveInfo>>= 
MemoryArena arena(1024 * 1024);
int totalNodes = 0;
std::vector<std::shared_ptr<Primitive>> orderedPrims;
BVHBuildNode *root;
if (splitMethod == SplitMethod::HLBVH)
    root = HLBVHBuild(arena, primitiveInfo, &totalNodes, orderedPrims);
else
    root = recursiveBuild(arena, primitiveInfo, 0, primitives.size(),
                          &totalNodes, orderedPrims);
primitives.swap(orderedPrims);
```

每一个`BVHBuildNode`都表示BVH的一个节点。除了左右子树和`Bound`，**内部节点**还记录了坐标轴，沿着该坐标轴，基元被划分为分布给它们的两个子节点，此信息用于改进**遍历算法**的性能。`firstPrimOffset, nPrimitives;`被叶子节点拿来记录它所存储的基元：

```c++
struct BVHBuildNode {
    <<BVHBuildNode Public Methods>> 
    Bounds3f bounds;
    BVHBuildNode *children[2];
    int splitAxis, firstPrimOffset, nPrimitives; //orderPrim数组中的偏移量，和此节点重叠的基元数
};
```

初始化叶子节点：

```c++
void InitLeaf(int first, int n, const Bounds3f &b) {
    firstPrimOffset = first;
    nPrimitives = n;
    bounds = b;
    children[0] = children[1] = nullptr;
}
```

初始化内部节点：

```c++
void InitInterior(int axis, BVHBuildNode *c0, BVHBuildNode *c1) {
    children[0] = c0;
    children[1] = c1;
    bounds = Union(c0->bounds, c1->bounds);
    splitAxis = axis;
    nPrimitives = 0;
}
```

`recursiveBuild()`是一种类似分治的递归算法，核心是怎么划分成两部分。`totalNodes` 跟踪已创建的 BVH 节点的总数；使用这个数字，以便稍后可以准确地分配更紧凑的 `LinearBVHNodes` 的正确数量。最后，`OrderPrims 数组`用于存储基元引用，因为基元被存储在树的叶子节点中。这个数组最初是空的；当创建叶子节点时，递归构建会将与其重叠的基元添加到数组的末尾，使得叶子节点只需将一个**偏移量**存储到这个数组中，并将一个基元计数代表与其重叠的基元集。回顾一下，当树构建完成后，`BVHAccel::primitives` 会被这里创建的有序基元数组所取代

```c++
BVHBuildNode *BVHAccel::recursiveBuild(MemoryArena &arena,
        std::vector<BVHPrimitiveInfo> &primitiveInfo, int start,
        int end, int *totalNodes,
        std::vector<std::shared_ptr<Primitive>> &orderedPrims) {
    BVHBuildNode *node = arena.Alloc<BVHBuildNode>();
    (*totalNodes)++;
    //Compute bounds of all primitives in BVH node
       Bounds3f bounds;
       for (int i = start; i < end; ++i)
           bounds = Union(bounds, primitiveInfo[i].bounds);

    int nPrimitives = end - start;
    if (nPrimitives == 1) {
        <<Create leaf BVHBuildNode>> 
           int firstPrimOffset = orderedPrims.size();
           for (int i = start; i < end; ++i) {
               int primNum = primitiveInfo[i].primitiveNumber;
               orderedPrims.push_back(primitives[primNum]);
           }
           node->InitLeaf(firstPrimOffset, nPrimitives, bounds);
           return node;

    } else {
        <<Compute bound of primitive centroids, choose split dimension dim>> 
           Bounds3f centroidBounds;
           for (int i = start; i < end; ++i)
               centroidBounds = Union(centroidBounds, primitiveInfo[i].centroid);
           int dim = centroidBounds.MaximumExtent();

        <<Partition primitives into two sets and build children>> 
           int mid = (start + end) / 2;
           if (centroidBounds.pMax[dim] == centroidBounds.pMin[dim]) {
               <<Create leaf BVHBuildNode>> 
               int firstPrimOffset = orderedPrims.size();
               for (int i = start; i < end; ++i) {
                   int primNum = primitiveInfo[i].primitiveNumber;
                   orderedPrims.push_back(primitives[primNum]);
               }
               node->InitLeaf(firstPrimOffset, nPrimitives, bounds);
               return node;
           } else {
               <<Partition primitives based on splitMethod>> 
               node->InitInterior(dim,
                                  recursiveBuild(arena, primitiveInfo, start, mid,
                                                 totalNodes, orderedPrims),
                                  recursiveBuild(arena, primitiveInfo, mid, end,
                                                 totalNodes, orderedPrims));
           }
    }
    return node;
}
```

在这里，我们选择三个坐标轴中的一个用于对基元进行**分区**。我们选择与**最大范围**相关联的轴。(另一种方法是尝试所有三个轴，并选择一个给出最好的结果，但在实践中，这种方法工作得很好。)这种方法在许多场景中都有很好的分割效果;图4.3说明了该策略。

![image-20210409124314015](第四章_原语和相交加速.assets/image-20210409124314015.png)

这里分区的一般目标是选择一个基元分区，该分区的两个**结果基元集**的**边界框**不会有太多的重叠——如果有大量的重叠，那么在遍历树时，将更大可能需要遍历两个子树。具体怎么分区，这里就不展开` <<Partition primitives based on splitMethod>> `，后面进行描述。

一个简单的 `splitMethod` 是 ==Middle==，它首先沿**分割轴**计算**基元质点**的中点。该方法在片段  `<<Partition primitives through node’s midpoint>>`中实现。根据基元的质点是在中点之上还是之下，基元被分为两组。`std::partition() `C++ 标准库函数很容易完成这种分割，它接收一个数组中的元素范围和一个比较函数，并对数组中的元素进行排序，使所有对给定谓词函数返回真值的元素出现在该范围内。` std::partition() `返回一个指向**对谓词有假值**的第一个元素的指针，它被转换为一个偏移量进入 `primitiveInfo` 数组，这样我们就可以将其传递给递归调用。图4.4说明了这种方法，包括这种方法好用和不好用的情况。

```c++
Float pmid = (centroidBounds.pMin[dim] + centroidBounds.pMax[dim]) / 2;
BVHPrimitiveInfo *midPtr =
    std::partition(&primitiveInfo[start], &primitiveInfo[end-1]+1,
        [dim, pmid](const BVHPrimitiveInfo &pi) {
            return pi.centroid[dim] < pmid;
        });
mid = midPtr - &primitiveInfo[0];
if (mid != start && mid != end)
    break;
```

如果基元都有很大的重叠边界框，则此拆分方法可能无法将基元分成两组。在这种情况下，执行过程会落入 `SplitMethod::EqualCounts` 方法中再次尝试。这个方法很简单，五五开——在指定轴下，较小质点坐标的基元一组，而较大的一组。这个方案也可以通过标准库调用 `std::nth_element()`轻松实现。它需要一个开始、中间和结束的指针，以及一个比较函数。它对数组进行排序，使中间指针处的元素是在数组完全排序的情况下会出现的元素，并且使中间元素之前的所有元素都比中间元素小，而中间元素之后的所有元素都比它大。

```c++
<<Partition primitives into equally sized subsets>>= 
mid = (start + end) / 2;
std::nth_element(&primitiveInfo[start], &primitiveInfo[mid], 
                 &primitiveInfo[end-1]+1,
                 [dim](const BVHPrimitiveInfo &a, const BVHPrimitiveInfo &b) { 
                     return a.centroid[dim] < b.centroid[dim];
         });
```

### 表面积启发式

==SAH模型==估计了执行**射线交汇测试**的计算费用，包括遍历**树的节点**所花费的时间，以及对基元进行**特定分区**花费的时间。构建加速结构的算法就可以遵循总成本最小化的目标。通常情况下，使用==贪婪算法==，使被单独构建的层次结构的**每个单节点的成本**最小化。

SAH成本模型背后的想法很直接：在构建**自适应加速结构**的任何一点上，我们可以只为当前区域和几何体创建一个叶子节点。在这种情况下，任何经过这个区域的射线都将对所有重叠的基元进行测试，并将产生以下成本：
$$
\sum_{i=1}^{N}t_{isect}(i),
$$
另一种选择是分割该地区。在这种情况下，射线会产生成本：（P是通过子节点区域的概率，且可以假设所有基元的`t`都一样）
$$
c(A,B)=t_{trav}+p_A\sum_{i=1}^{N_A}t_{isect}(a_i)+p_B\sum_{i=1}^{N_B}t_{isect}(b_i),
$$
在通过B的同时，也通过A的概率，和他们的表面积之比相关：
$$
p(A|B)=\frac{s_A}{s_B}
$$
这样，考虑下图，对于一块区域A，射线通过它的同时，还通过两个子区域`B`和`C`的概率可以轻松计算：

<img src="第四章_原语和相交加速.assets/image-20210409131547222.png" alt="image-20210409131547222" style="zoom:67%;" />

通过考虑多个候选分区，找到沿**所选轴**的基元分区，该分区可提供最小的 **SAH 成本估计**。然而，一旦它细化到一小部分基元，实现就会切换到**分区为同等大小的子集**。此时应用 SAH 的增量计算成本是不值得的。

```c++
<<Partition primitives using approximate SAH>>= 
if (nPrimitives <= 4) {
    <<Partition primitives into equally sized subsets>> //已知，上面有的`equal`方法
} else {
    <<Allocate BucketInfo for SAH partition buckets>> 
    <<Initialize BucketInfo for SAH partition buckets>> 
    <<Compute costs for splitting after each bucket>> 
    <<Find bucket to split at that minimizes SAH metric>> 
    <<Either create leaf or split primitives at selected SAH bucket>> 
}
```

这里的实现将沿轴将范围划分为少量相同范围的桶。然后它只考虑桶边界上的分区。这种方法比考虑所有的分区更有效，而通常仍然产生几乎同样有效的分区。

```c++
<<Allocate BucketInfo for SAH partition buckets>>= 
constexpr int nBuckets = 12;
struct BucketInfo {
    int count = 0;
    Bounds3f bounds;
};
BucketInfo buckets[nBuckets];
```

对于范围内的每个原语，我们确定其质心所在的桶，并更新桶的边界以包含原语的边界。

```c++
<<Initialize BucketInfo for SAH partition buckets>>= 
for (int i = start; i < end; ++i) {
    int b = nBuckets * 
        centroidBounds.Offset(primitiveInfo[i].centroid)[dim];
    if (b == nBuckets) b = nBuckets - 1;
    buckets[b].count++;
    buckets[b].bounds = Union(buckets[b].bounds, primitiveInfo[i].bounds);
}
```

对于每个桶，我们现在已经有了基元数和各自边界框。我们希望使用 SAH 来估计在每个桶边界进行拆分的成本。下面的片段循环了所有的 bucket，并初始化 cost[i] 数组，以存储在第 i 个 bucket 之后进行拆分的估计 SAH 成本。它没有考虑最后一个 bucket 之后的拆分，因为根据定义，最后一个 bucket 不会拆分基元）。

我们任意将**相交估计代价**设为`1`，然后将**遍历估计代价**设为`1/8`。（它们中的一个总是可以设置为1，因为估计遍历和相交代价的相对大小，而不是绝对大小决定了它们的效果）。

```c#
<<Compute costs for splitting after each bucket>>= 
Float cost[nBuckets - 1];
for (int i = 0; i < nBuckets - 1; ++i) {
    Bounds3f b0, b1;
    int count0 = 0, count1 = 0;
    for (int j = 0; j <= i; ++j) {
        b0 = Union(b0, buckets[j].bounds);
        count0 += buckets[j].count;
    }
    for (int j = i+1; j < nBuckets; ++j) {
        b1 = Union(b1, buckets[j].bounds);
        count1 += buckets[j].count;
    }
    cost[i] = .125f + (count0 * b0.SurfaceArea() +
                       count1 * b1.SurfaceArea()) / bounds.SurfaceArea() * 1.f;
}
```

然后，就是寻找最低`cost`：

```c++
<<Find bucket to split at that minimizes SAH metric>>= 
Float minCost = cost[0];
int minCostSplitBucket = 0;
for (int i = 1; i < nBuckets - 1; ++i) {
    if (cost[i] < minCost) {
        minCost = cost[i];
        minCostSplitBucket = i;
    }
}
```

最后，是进行抉择：递归分区，还是创建叶子节点。创建叶子节点的开销默认是相交数，所以，只有当当前最小分区开销小于叶子节点开销，且分区的基元数大于阈值，才创建分区：

```c++
<<Either create leaf or split primitives at selected SAH bucket>>= 
Float leafCost = nPrimitives;
if (nPrimitives > maxPrimsInNode || minCost < leafCost) {
    BVHPrimitiveInfo *pmid = std::partition(&primitiveInfo[start],
        &primitiveInfo[end-1]+1, 
        [=](const BVHPrimitiveInfo &pi) {
            int b = nBuckets * centroidBounds.Offset(pi.centroid)[dim];
            if (b == nBuckets) b = nBuckets - 1;
            return b <= minCostSplitBucket;
        });
    mid = pmid - &primitiveInfo[0];
} else {
    <<Create leaf BVHBuildNode>> 
}
```

### Linear Bounding Volume Hierarchies

虽然使用==表面面积启发式方法==构建**包围体层次结构**得到了非常好的结果，但这种方法确实有两个缺点:首先，许多`pass`在场景基元上被用来计算树的所有层次的**SAH成本**。其次，自顶向下的BVH构造很难很好地并行化。

==线性包围体层次结构==（LBVHs）被开发来解决这些问题。在**LBVHs**中，树是通过少量的轻量`pass`来构建的；树的构造时间与基元的数量成**线性关系**。此外，该算法快速地将原语划分成可以独立处理的簇。这种处理可以很容易地并行化，并且非常适合GPU实现。

LBVHs背后的==关键思想是把BVH的构造变成一个排序问题==。由于没有单一的排序函数来对多维数据进行排序，LBVHs是基于`Morton`编码的，Morton编码将n维度上的邻近点映射到沿着一维线上的邻近点上，那里有一个明显的排序函数。在原语排序之后，空间附近的原语簇位于已排序数组的连续段中。

`Morton`编码基于一个简单的变换：给定一个n维坐标，它们的**莫顿编码**表示是通过以`2`为基底的==坐标位交错==来找到的，例如对于$(x,y)$，其编码值如下：
$$
...y_3x_3y_2x_2y_1x_1y_0x_0.
$$
参见下图，可以知道莫顿排序类似于`Z`，而且在空间上相近的点，在序列中也挨着：

![image-20210409141344995](第四章_原语和相交加速.assets/image-20210409141344995.png)

一种解释这些基于位的属性的方法是使用morton编码的值，给定一组已排序的Morton索引，我们可以通过对数组中的每个端点执行二分搜索来找到图(c)所示区域对应的点的范围。

<img src="第四章_原语和相交加速.assets/image-20210409141953020.png" alt="image-20210409141953020" style="zoom:50%;" />

我们将构建一个分层线性边界体积层次结构(==HLBVH==)。使用这种方法，基于morton曲线的聚类首先用于为层次结构的较低层次构建树(在下文中称为`treelets`)，然后使用**表面积启发式**创建树的最高层次。`HLBVHBuild()`方法实现了这种方法，并返回结果树的根节点。

```c++
<<BVHAccel Method Definitions>>+=  
BVHBuildNode *BVHAccel::HLBVHBuild(MemoryArena &arena, 
        const std::vector<BVHPrimitiveInfo> &primitiveInfo,
        int *totalNodes,
        std::vector<std::shared_ptr<Primitive>> &orderedPrims) const {
    <<Compute bounding box of all primitive centroids>> 
    <<Compute Morton indices of primitives>> 
    <<Radix sort primitive Morton indices>> 
    <<Create LBVH treelets at bottom of BVH>> 
    <<Create and return SAH BVH from LBVH treelets>> 
}
```

因为Morton编码操作在整数坐标上，我们首先需要限定所有基元的质心，以便我们可以量化关于总体边界的质心位置。

```c++
<<Compute bounding box of all primitive centroids>>= 
Bounds3f bounds;
for (const BVHPrimitiveInfo &pi : primitiveInfo)
    bounds = Union(bounds, pi.centroid);
```

并行莫顿编码：

```c++
<<Compute Morton indices of primitives>>= 
std::vector<MortonPrimitive> mortonPrims(primitiveInfo.size());
ParallelFor(
    [&](int i) {
        <<Initialize mortonPrims[i] for ith primitive>> 
           constexpr int mortonBits = 10;
           constexpr int mortonScale = 1 << mortonBits;
           mortonPrims[i].primitiveIndex = primitiveInfo[i].primitiveNumber;
           Vector3f centroidOffset = bounds.Offset(primitiveInfo[i].centroid);
           mortonPrims[i].mortonCode = EncodeMorton3(centroidOffset * mortonScale);

    }, primitiveInfo.size(), 512);
```

```c++
<<BVHAccel Local Declarations>>+=  
    struct MortonPrimitive {
        int primitiveIndex;
        uint32_t mortonCode;
    };
```

我们为`x,y,z`各分配了10位，总共30位，因为质点在包围盒中的`offset`的范围是`[0,1]`，所以需要乘以$2^{10}$以匹配`10位`，来得到整型坐标。为了计算3D Morton编码，首先我们将定义一个辅助函数：`LeftShift3()`接受一个32位值，并返回将第`i`位移到第`3i`位的结果，在其他位保留0。图4.9说明了该操作：

![image-20210409143104838](第四章_原语和相交加速.assets/image-20210409143104838.png)

```c++
<<BVHAccel Utility Functions>>= 
    inline uint32_t LeftShift3(uint32_t x) {
        if (x == (1 << 10)) --x;
        x = (x | (x << 16)) & 0b00000011000000000000000011111111;
        x = (x | (x <<  8)) & 0b00000011000000001111000000001111;
        x = (x | (x <<  4)) & 0b00000011000011000011000011000011;
        x = (x | (x <<  2)) & 0b00001001001001001001001001001001;
        return x;
    }
```

然后，编码函数就很简单了：

```c++
<<BVHAccel Utility Functions>>+=  
    inline uint32_t EncodeMorton3(const Vector3f &v) {
        return (LeftShift3(v.z) << 2) | (LeftShift3(v.y) << 1) |
                LeftShift3(v.x);
    }
```

一旦计算了Morton索引，我们将使用基数排序，根据Morton索引值对`mortonPrims`排序。我们发现，对于BVH的构造，我们的基数排序实现明显比使用系统标准库中的`std::sort()`要快。

```c++
<<Radix sort primitive Morton indices>>= 
	RadixSort(&mortonPrims);
```

`bitsPerPass`设置了每次处理的位数；值为6时，我们有5次机会对30位进行排序。

```c++
<<BVHAccel Utility Functions>>+= 
    static void RadixSort(std::vector<MortonPrimitive> *v) {
        std::vector<MortonPrimitive> tempVector(v->size());
        constexpr int bitsPerPass = 6;
        constexpr int nBits = 30;
        constexpr int nPasses = nBits / bitsPerPass;
        for (int pass = 0; pass < nPasses; ++pass) {
            <<Perform one pass of radix sort, sorting bitsPerPass bits>> 
        }
        <<Copy final result from tempVector, if needed>> 
    }
```

具体如何做，见[书](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html)

给定已排序的原语数组，我们将找到具有附近质心的原语簇，然后在每个簇中的原语上创建**LBVH**。这个步骤很适合并行化，因为通常有许多集群，每个集群都可以独立处理。

```c++
<<Create LBVH treelets at bottom of BVH>>= 
	<<Find intervals of primitives for each treelet>> 
	<<Create LBVHs for treelets in parallel>> 
```

每个基元簇由` LBVHTreelet `表示。它对集群中第一个基元的 mortonPrims 数组中的**索引**以及后续基元的**数量**进行编码。

```c++
<<BVHAccel Local Declarations>>+=  
    struct LBVHTreelet {
       int startIndex, nPrimitives;
       BVHBuildNode *buildNodes;
    };
```

```c++
<<Find intervals of primitives for each treelet>>= 
    std::vector<LBVHTreelet> treeletsToBuild;
    for (int start = 0, end = 1; end <= (int)mortonPrims.size(); ++end) {
        uint32_t mask = 0b00111111111111000000000000000000;
        if (end == (int)mortonPrims.size() ||
            ((mortonPrims[start].mortonCode & mask) !=
             (mortonPrims[end].mortonCode & mask))) {
            <<Add entry to treeletsToBuild for this treelet>> 
               int nPrimitives = end - start;
               int maxBVHNodes = 2 * nPrimitives - 1;
               BVHBuildNode *nodes = arena.Alloc<BVHBuildNode>(maxBVHNodes, false);
               treeletsToBuild.push_back({start, nPrimitives, nodes});

            start = end;
        }
    }
```

以上，相当于划分区域，我们取高`12`位为1，则当低位无论如何变化，我们的判断都不会为真，所以说，这里我们将这个区域划分成了$2^{12}=4096$个空间`cells`，每个维度是$2^4=16$个`cells`。

构建LBVH的工作线程有两个地方必须相互协调。首先，需要计算所有LBVHs中的节点总数，并通过传递给`HLBVHBuild()`的`totalNodes`指针返回。其次，当为`LBVHs`创建叶子节点时，需要orderedPrims数组的一个连续段来记录叶子节点中基元的索引。 Our implementation uses atomic variables for both—`atomicTotal` to track the number of nodes and `orderedPrimsOffset` for the index of the next available entry in `orderedPrims`.

```c++
<<Create LBVHs for treelets in parallel>>= 
    std::atomic<int> atomicTotal(0), orderedPrimsOffset(0);
    orderedPrims.resize(primitives.size());
    ParallelFor(
        [&](int i) {
            <<Generate ith LBVH treelet>> 
               int nodesCreated = 0;
               const int firstBitIndex = 29 - 12;
               LBVHTreelet &tr = treeletsToBuild[i];
               tr.buildNodes = 
                   emitLBVH(tr.buildNodes, primitiveInfo, &mortonPrims[tr.startIndex],
                            tr.nPrimitives, &nodesCreated, orderedPrims,
                            &orderedPrimsOffset, firstBitIndex);
               atomicTotal += nodesCreated;

        }, treeletsToBuild.size());
    *totalNodes = atomicTotal;
```

`emitLBVH()`算法实现了树状图的构建，该算法在空间的某个区域内取以质心为中心的原语，然后用分裂面将其依次分割，将当前空间区域沿其中一条轴线的中心分割成两半。

还剩下一点内容，Todo。



## 4. Kd-Tree Accelerator

<img src="第四章_原语和相交加速.assets/image-20210410114859072.png" alt="image-20210410114859072" style="zoom:67%;" />

==二进制空间划分树==（==BSP==）自适应地用平面对空间进行**细分**。**BSP树**以**包围整个场景的边界框**开始。如果包围盒中的基元数大于某个阈值，则包围盒被一个平面分成两半。然后，原语与它们重叠的那一半相关联，而重叠两个区域的原语与两个都相关联。(这与`BVHs`不同，在`BVHs`中，每个原语拆分后只被分配给两个子组中的一个)

分裂过程递归进行，直到结果树中的每个**叶区域**包含足够少的原语，或者直到达到**最大深度**。由于**分裂平面**可以放置在整体边界内的任意位置，3D空间的不同部分可以被细化到不同程度，`BSP树`可以轻松处理几何形状的不均匀分布。

**BSP树**的两种变体是==kd树==和==八叉树==。kd树只是限制**分割平面**垂直于其中一个坐标轴；这使得树的遍历和构造更有效率，但代价是空间分割的灵活性。**八叉树**使用三个垂直于坐标轴的平面，每一步都将盒子分割成八个区域。在本节中，我们将在**KdTreeAccel类**中实现一个用于射线相交加速的`kd-tree`。这个类的源代码可以在文件 `accelerators/kdtreeaccel.h` 和` accelerators/kdtreeaccel.cpp `中找到。

```c++
class KdTreeAccel : public Aggregate {
public:
    <<KdTreeAccel Public Methods>> 
       KdTreeAccel(const std::vector<std::shared_ptr<Primitive>> &p,
               int isectCost = 80, int traversalCost = 1, Float emptyBonus = 0.5,
               int maxPrims = 1, int maxDepth = -1);
       Bounds3f WorldBound() const { return bounds; }
       ~KdTreeAccel();
       bool Intersect(const Ray &ray, SurfaceInteraction *isect) const;
       bool IntersectP(const Ray &ray) const;

private:
    <<KdTreeAccel Private Methods>> 
       void buildTree(int nodeNum, const Bounds3f &bounds,    
           const std::vector<Bounds3f> &primBounds, int *primNums, int nprims, int depth,
           const std::unique_ptr<BoundEdge[]> edges[3], int *prims0, int *prims1, int badRefines = 0);

    <<KdTreeAccel Private Data>> 
       const int isectCost, traversalCost, maxPrims;
       const Float emptyBonus;
       std::vector<std::shared_ptr<Primitive>> primitives;
       std::vector<int> primitiveIndices;
       KdAccelNode *nodes;
       int nAllocedNodes, nextFreeNode;
       Bounds3f bounds;

};
```

### 树表示

**内部节点**必须提供对三条信息的访问：

+ 划分的轴：`x,y或z`
+ 划分的位置：在指定轴上的划分位置
+ 子节点

**叶子节点**只需要存储它所重叠的基元。值得花点心思确保所有**内部节点**和许多**叶子节点**只使用`8个字节`的内存（4字节的Float），因为这样做可以确保`8`个节点可以放入`64`字节的缓存行。最小化节点表示的大小可以大幅提高缓存性能。我们最初的实现使用了`16`字节的**节点表示**，当我们将大小减少到`8`字节时，我们获得了近`20%`的速度提升。使用`kdAccelNode`来表示节点：

```c++
struct KdAccelNode {
    <<KdAccelNode Methods>> 
       void InitLeaf(int *primNums, int np, std::vector<int> *primitiveIndices);
       void InitInterior(int axis, int ac, Float s) {
           split = s;
           flags = axis;
           aboveChild |= (ac << 2);
       }
       Float SplitPos() const { return split; }
       int nPrimitives() const { return nPrims >> 2; }
       int SplitAxis() const { return flags & 3; }
       bool IsLeaf() const { return (flags & 3) == 3; }
       int AboveChild() const { return aboveChild >> 2; }

    union {
        Float split;                  // Interior
        int onePrimitive;             // Leaf
        int primitiveIndicesOffset;   // Leaf
    };
    union {
        int flags;         // Both
        int nPrims;        // Leaf
        int aboveChild;    // Interior
    };
};
```

`flags`变量的低两位用来区分**内部节点**（按照哪个轴切分：`0,1,2`），以及叶子节点（`3`）。具体如何占据8个字节呢：`flags`的低两位用来区分，`nPrims`的高30位用来记录此区域重叠了多少基元；如果仅覆盖了一个基元，则一个**整型索引**标识了`kdTreeAccel::primitives`数组的一个基元，如果覆盖了多个基元，然后他们的索引存储在`kdTreeAccel::primitiveIndices`的片段中，叶子的第一个索引的偏移量存储在`KdAccelNode::primitiveIndicesOffset`中，其余的索引直接在后面。

叶节点很容易初始化，但我们必须小心处理细节，因为`flags`和`nprim`共享相同的存储空间——不要在初始化另一个时破坏其中一个的数据。而且，在存储之前，基元的数目必须左移两位，以便`KdAccelNode::flags`的低两位都可以设置为`1`，以表明这是一个叶节点。

```c++
<<KdTreeAccel Method Definitions>>+=  
    void KdAccelNode::InitLeaf(int *primNums, int np,
            std::vector<int> *primitiveIndices) {
        flags = 3;
        nPrims |= (np << 2);
        <<Store primitive ids for leaf node>> 
    }
```

对于具有`0`或`1`个重叠原语的**叶节点**，由于`KdAccelNode:: onePrimitive`字段，不需要额外的内存分配。对于多个原语重叠的情况，存储分配在`kdTreeAccel::primitiveIndices`数组中。

```c++
<<Store primitive ids for leaf node>>= 
    if (np == 0)
        onePrimitive = 0;
    else if (np == 1)
        onePrimitive = primNums[0];
    else {
        primitiveIndicesOffset = primitiveIndices->size();
        for (int i = 0; i < np; ++i)
            primitiveIndices->push_back(primNums[i]);
    }
```

让内部节点减少到`8`个字节也是相当简单的。一个`Float`（大小为32位）存储了**节点**沿着**所选的分割轴**分割空间的位置，正如前面所解释的，`KdAccelNode::flags`的最低`2`位用来记录节点是沿着哪个轴分割的。剩下的就是在我们遍历树的时候，存储足够的信息来找到节点的两个子节点。

我们没有存储两个指针或偏移量，而是以一种让我们只存储**一个子指针**的方式来布局节点：所有的节点都被分配在一个单一的连续内存块中，负责**分割面**以下空间的内部节点的子节点总是存储在紧挨着其父节点的数组位置（这种布局也提高了**缓存性能**，通过在内存中保持至少一个子节点靠近其父节点）。另一个子节点，代表分割面以上的空间，最终会在数组中的某个地方结束；一个单一的整数偏移，`KdAccelNode::aboveChild`，存储它在节点数组中的位置。

```c++
<<KdAccelNode Methods>>= 
void InitInterior(int axis, int ac, Float s) {
    split = s;
    flags = axis;
    aboveChild |= (ac << 2);
}
```

### 树构建

`kd-tree`是用**递归自顶向下算法**构建的。在每一步，我们都有一个轴线对齐的**空间区域**和一组与该区域重叠的基元。该区域要么被分割成两个子区域并转换为**内部节点**，要么创建带有**重叠原语**的叶节点，结束递归。

正如在`KdAccelNodes`的讨论中提到的，所有树节点都存储在一个连续数组中。`KdTreeAccel::nextFreeNode`记录这个数组中可用的下一个节点，`KdTreeAccel::nAllocedNodes`记录已经分配的节点总数。通过将它们都设置为`0`并在启动时不分配任何节点，这里的实现确保在初始化树的第一个节点时，立即完成分配。

如果没有给**构造函数**一个最大的树深度，也有必要确定一个最大的树深度。对于各种场景，$8+1.3log(N)$这个值可以给出一个==合理的最大深度==。

```c++
<<Build kd-tree for accelerator>>= 
    nextFreeNode = nAllocedNodes = 0;
    if (maxDepth <= 0)
        maxDepth = std::round(8 + 1.3f * Log2Int(primitives.size()));
    <<Compute bounds for kd-tree construction>> 
    <<Allocate working memory for kd-tree construction>> 
    <<Initialize primNums for kd-tree construction>> 
    <<Start recursive construction of kd-tree>> 
```

由于==构造例程==将反复使用**基元的边界框**，因此在树的构造开始之前，它们会被存储在一个`vector`中，这样就不需要反复调用可能很慢的 `Primitive::WorldBound() `方法。

```c++
<<Compute bounds for kd-tree construction>>= 
    std::vector<Bounds3f> primBounds;
    for (const std::shared_ptr<Primitive> &prim : primitives) {
        Bounds3f b = prim->WorldBound();
        bounds = Union(bounds, b);
        primBounds.push_back(b);
    }
```

**树构建例程**的参数之一是一个==基元索引数组==，表示哪些基元与当前节点重叠。因为所有基元都与根节点重叠（当递归开始时），所以我们从一个初始化值为 0 到 `primitives.size()-1 `的数组开始。

```c++
<<Initialize primNums for kd-tree construction>>= 
    std::unique_ptr<int[]> primNums(new int[primitives.size()]);
    for (size_t i = 0; i < primitives.size(); ++i)
        primNums[i] = i;
```

`KdTreeAccel::buildTree()`是为每个**树节点**调用的。它负责决定该节点是内部节点还是叶子，并适当地更新数据结构。最后三个参数 `edges`、`prints0` 和 `prims1 `是指向<<[Allocate working memory for kd-tree construction](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Kd-Tree_Accelerator.html#fragment-Allocateworkingmemoryforkd-treeconstruction-0)>>片段中分配的数据的指针，这将在之后定义和记录。

```c++
<<Start recursive construction of kd-tree>>= 
    buildTree(0, bounds, primBounds, primNums.get(), primitives.size(), 
              maxDepth, edges, prims0.get(), prims1.get());
```

`KdTreeAccel::buildTree()`的主要参数是它创建的节点**nodeNum数组**中的**偏移量**；给出节点所覆盖空间区域的边界框，`nodebound`；而与之重叠的基元的索引，`primNums`。其余的参数将在后面进行描述。

```c++
<<KdTreeAccel Method Definitions>>+=  
    void KdTreeAccel::buildTree(int nodeNum, const Bounds3f &nodeBounds,
            const std::vector<Bounds3f> &allPrimBounds, int *primNums,
            int nPrimitives, int depth,
            const std::unique_ptr<BoundEdge[]> edges[3], 
            int *prims0, int *prims1, int badRefines) {
        <<Get next free node from nodes array>> 
        <<Initialize leaf node if termination criteria met>> 
        <<Initialize interior node and continue recursion>> 
    }
```

如果所有已分配的节点都已用完，则重新分配节点内存，并复制旧的值。第一次调用`KdTreeAccel::buildTree()`时，`KdTreeAccel::nAllocedNodes`为0，并且分配了一个初始的树节点块：

```c++
<<Get next free node from nodes array>>= 
    if (nextFreeNode == nAllocedNodes) {
        int nNewAllocNodes = std::max(2 * nAllocedNodes, 512);
        KdAccelNode *n = AllocAligned<KdAccelNode>(nNewAllocNodes);
        if (nAllocedNodes > 0) {
            memcpy(n, nodes, nAllocedNodes * sizeof(KdAccelNode));
            FreeAligned(nodes);
        }
        nodes = n;
        nAllocedNodes = nNewAllocNodes;
    }
    ++nextFreeNode;
```

如果该区域中的**原语数量**足够少，或者已经达到**最大深度**，则创建一个**叶节点**（停止递归）。

```c++
<<Initialize leaf node if termination criteria met>>= 
    if (nPrimitives <= maxPrims || depth == 0) {
        nodes[nodeNum].InitLeaf(primNums, nPrimitives, &primitiveIndices);
        return;
    }
```

如果这是一个**内部节点**，则有必要选择一个==分裂平面==，根据该平面对原语进行分类，然后进行递归。

```c++
<<Initialize interior node and continue recursion>>= 
<<Choose split axis position for interior node>> 
<<Create leaf if no good splits were found>> 
<<Classify primitives with respect to split>> 
<<Recursively initialize children nodes>> 
```

我们的实现使用4.3.2节中介绍的==SAH分割==。SAH适用于`kd-tree`和`BVHs`；这里，计算节点中一系列**候选分裂平面**的估计代价，并选择代价最低的分裂。在这里的实现中，**相交代价**$t_{isect}$和**遍历代价**$t_{trav}$可以由用户设置，它们的默认值分别为`80`和`1`。这两个值的比率决定了树形算法的行为。与用于BVH构造的值相比，这些值之间的比例更大，这反映了访问`kd-tree节点`比访问`BVH节点`花费更少的事实。

对用于`BVH树`的`SAH`的一个修改是，对于`kd树`来说，值得优先选择**其中一个子节点没有基元重叠的分割**，因为通过这些区域的射线可以立即前进到下一个kd树节点，而不需要任何交集测试。因此，未分割和分割区域的修正成本分别为：

![image-20210410130526045](第四章_原语和相交加速.assets/image-20210410130526045.png)

其中`b`是一个 "bonus "值，为`0`，除非两个区域中的一个完全为空，在这种情况下，它的值在0和1之间。

给定了计算**成本模型概率**的方法，唯一要解决的问题是如何生成**候选分割位置**，以及如何有效计算每个候选位置的成本。可以证明，这种模型的**最小成本**将在**与基元的一个边界框的一个面重合的分割处**实现。我们将考虑三个坐标轴中一个或多个区域内的所有边界框面。

<img src="第四章_原语和相交加速.assets/image-20210410131023554.png" alt="image-20210410131023554" style="zoom:67%;" />

为了计算这些成本，我们将扫过**边界框**在每个轴上的投影，并跟踪哪个成本最低。每个边界框在每个轴上都有两条边，每条边由一个==BoundEdge结构==的实例来表示。该结构记录了边缘沿轴线的位置，它是代表边界框的开始还是结束（沿轴线从低到高），以及它与哪个基元相关联。

```c++
<<KdTreeAccel Local Declarations>>+=  
    enum class EdgeType { Start, End };

<<KdTreeAccel Local Declarations>>+= 
    struct BoundEdge {
        Float t;
        int primNum;
        EdgeType type;
    };
    BoundEdge(Float t, int primNum, bool starting)
        : t(t), primNum(primNum) {
        type = starting ? EdgeType::Start : EdgeType::End; 
    }
```

最多需要`2 * primitives.size() `个**BoundEdges**来计算任何树节点的成本，因此所有三个轴的边缘的内存被分配一次，然后为每个创建的节点重新使用。

```c++
<<Allocate working memory for kd-tree construction>>= 
std::unique_ptr<BoundEdge[]> edges[3];
for (int i = 0; i < 3; ++i)
    edges[i].reset(new BoundEdge[2 * primitives.size()]);
```

在确定**创建叶子的估计成本**之后，`KdTreeAccel::buildTree()`选择一个轴来尝试分割，并计算每个候选分割的成本函数。`bestAxis`和`bestOffset`记录到目前为止成本最低的**轴**和**边框**索引，`bestCost`。`invTotalSA`初始化为**节点表面积的倒数**；它的值将用于计算光线通过每个候选子节点的概率。

```c++
<<Choose split axis position for interior node>>= 
    int bestAxis = -1, bestOffset = -1;
    Float bestCost = Infinity;
    Float oldCost = isectCost * Float(nPrimitives);
    Float totalSA = nodeBounds.SurfaceArea();
    Float invTotalSA = 1 / totalSA;
    Vector3f d = nodeBounds.pMax - nodeBounds.pMin;
    <<Choose which axis to split along>> 
    int retries = 0;
    retrySplit:
    <<Initialize edges for axis>> 
    <<Compute cost of all splits for axis to find best>> 
```

该方法首先尝试沿轴线寻找**空间范围最大的分割**；如果成功了，这个选择有助于给区域空间倾向于**方形的形状**。从直觉上看，这是一种明智的方法。后来，如果它不能沿着这个轴找到一个好的分裂，它就会回去依次尝试其他的：

```c++
<<Choose which axis to split along>>= 
    int axis = nodeBounds.MaximumExtent();
```

首先，使用重叠原语的边界框初始化`axis`的`edges数组`。然后，该数组沿着轴从低到高排序，以便它可以从第一个到最后扫过框的边缘。

```c++
<<Initialize edges for axis>>= 
for (int i = 0; i < nPrimitives; ++i) {
    int pn = primNums[i];
    const Bounds3f &bounds = allPrimBounds[pn];
    edges[axis][2 * i] =     BoundEdge(bounds.pMin[axis], pn, true);
    edges[axis][2 * i + 1] = BoundEdge(bounds.pMax[axis], pn, false);
}
<<Sort edges for axis>>
```

```c++
<<Sort edges for axis>>= 
std::sort(&edges[axis][0], &edges[axis][2*nPrimitives],
    [](const BoundEdge &e0, const BoundEdge &e1) -> bool {
        if (e0.t == e1.t)
            return (int)e0.type < (int)e1.type;
        else return e0.t < e1.t; 
    });
```

给定边的排序数组，我们希望快速计算每条边的分割成本函数。使用**每个子节点的表面积**可以很容易地计算出射线通过每个子节点的**概率**，而分割后每一侧的基元数由变量 `nBelow` 和 `nAbove` 跟踪。在第一条边上，根据定义，所有基元都必须在该边之上，所以`nAbove`初始化为`nPrimitives`，`nBelow`设置为`0`。当循环考虑在一个边界框的范围末端进行分割时，nAbove需要被递减，因为该框之前必须在分割平面之上，如果在该点进行分割，则不再在其之上。同理，在计算拆分成本后，如果拆分候选者处于一个边界框的范围的起始处，那么以后所有的拆分都将处于该框的下方。循环体开始和结束时的测试会更新这两种情况的基元数。

```c++
<<Compute cost of all splits for axis to find best>>= 
    int nBelow = 0, nAbove = nPrimitives;
    for (int i = 0; i < 2 * nPrimitives; ++i) {
        if (edges[axis][i].type == EdgeType::End) --nAbove;
        Float edgeT = edges[axis][i].t;
        if (edgeT > nodeBounds.pMin[axis] &&
            edgeT < nodeBounds.pMax[axis]) {
            <<Compute cost for split at ith edge>> 
        }
        if (edges[axis][i].type == EdgeType::Start) ++nBelow;
    }
```

`belowSA`和`aboveSA`持有两个候选子边界的表面区域；只要把六个面的面积加起来，它们就很容易计算出来。

```c#
<<Compute child surface areas for split at edgeT>>= 
    int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
    Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                         (edgeT - nodeBounds.pMin[axis]) * 
                         (d[otherAxis0] + d[otherAxis1]));
    Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                         (nodeBounds.pMax[axis] - edgeT) * 
                         (d[otherAxis0] + d[otherAxis1]));
```

```c++
<<Compute cost for split at ith edge>>= 
    <<Compute child surface areas for split at edgeT>> 
    Float pBelow = belowSA * invTotalSA; 
    Float pAbove = aboveSA * invTotalSA;
    Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
    Float cost = traversalCost + 
                 isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
    <<Update best split if this is lowest cost so far>> 
```

```c++
<<Update best split if this is lowest cost so far>>= 
    if (cost < bestCost)  {
        bestCost = cost;
        bestAxis = axis;
        bestOffset = i;
    }
```

在前面的测试中可能没有发现==可能的分割==（下图说明了可能发生的情况）。在这种情况下，没有一个候选位置可以沿着当前轴分割节点。在这一点上，尝试分裂的其他两个轴轮流。如果它们都不能找到分割（当重试次数等于2时），那么就没有有效的方法来细化节点，因为两个子节点仍然有相同数量的重叠原语。当这种情况发生时，我们所能做的就是放弃，制造一个==叶节点==。

![image-20210410132945989](第四章_原语和相交加速.assets/image-20210410132945989.png)

还有一种可能是，**最好的分割成本**仍然高于**根本不分割节点的成本**。如果情况更糟，并且没有太多的原语，则立即创建一个叶节点。否则，`badRefines`会跟踪到树的当前节点之上已经进行了多少次糟糕拆分。允许进行一些稍差的改进是值得的，因为在考虑的原语子集更小的情况下，以后的分割可能会找到更好的。

```c++
<<Create leaf if no good splits were found>>= 
    if (bestAxis == -1 && retries < 2) {
        ++retries;
        axis = (axis + 1) % 3;
        goto retrySplit;
    }
    if (bestCost > oldCost) ++badRefines;
    if ((bestCost > 4 * oldCost && nPrimitives < 16) || 
        bestAxis == -1 || badRefines == 3) {
        nodes[nodeNum].InitLeaf(primNums, nPrimitives, &primitiveIndices);
        return; 
    }
```

选择了分割位置后，==边界框边缘==可以用于将原语分类为在分割的上方、下方或`both`，就像在前面的代码中跟踪nBelow和nAbove一样。

```c++
<<Classify primitives with respect to split>>= 
    int n0 = 0, n1 = 0;
    for (int i = 0; i < bestOffset; ++i)
        if (edges[bestAxis][i].type == EdgeType::Start)
            prims0[n0++] = edges[bestAxis][i].primNum;
    for (int i = bestOffset + 1; i < 2 * nPrimitives; ++i)
        if (edges[bestAxis][i].type == EdgeType::End)
            prims1[n1++] = edges[bestAxis][i].primNum;
```

回顾一下，在kd-tree节点数组中，这个节点的 "**below** "子节点的**节点号**是当前节点号加一。在递归从**树的那一边**返回后，"**above** "的子节点会使用`nextFreeNode`偏移量。这里唯一重要的细节是，`prims0内存`直接传递给两个子代重用，而prints1指针则先向前推进。这是有必要的，因为`KdTreeAccel::buildTree()`的当前调用取决于：其`prims1`的值是否保存在`below`对`KdTreeAccel::buildTree()`的第一次递归调用上，因为它必须作为参数传递给第二次调用。然而，除了在**第一次递归调用中**立即使用外，并没有相应的需求来保存边值，或保存`prims0`。

```c++
<<Recursively initialize children nodes>>= 
    Float tSplit = edges[bestAxis][bestOffset].t;
    Bounds3f bounds0 = nodeBounds, bounds1 = nodeBounds;
    bounds0.pMax[bestAxis] = bounds1.pMin[bestAxis] = tSplit;
    buildTree(nodeNum + 1, bounds0, allPrimBounds, prims0, n0,
              depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);
    int aboveChild = nextFreeNode;
    nodes[nodeNum].InitInterior(bestAxis, aboveChild, tSplit);
    buildTree(aboveChild, bounds1, allPrimBounds, prims1, n1, 
              depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);
```

```c++
<<Allocate working memory for kd-tree construction>>+= 
std::unique_ptr<int[]> prims0(new int[primitives.size()]);
std::unique_ptr<int[]> prims1(new int[(maxDepth+1) * primitives.size()]);
```

### 遍历

<img src="第四章_原语和相交加速.assets/image-20210410134610046.png" alt="image-20210410134610046" style="zoom:67%;" />

上图显示了==射线遍历树的基本过程==。将射线与树的整体边界相交，得到初始`tMin`和`tMax`值，在图中用点标记。和本章的`BVHAccel`一样，如果射线错过了整个原语边界，这个方法可以立即返回`false`。否则，它会从根开始向下进入树中。在每个内部节点，它确定光线首先进入的两个子节点中的哪一个，并按顺序处理这两个子节点。当射线离开树或者找当最近的交点时，遍历结束。

```c++
<<KdTreeAccel Method Definitions>>+= 
    bool KdTreeAccel::Intersect(const Ray &ray,
            SurfaceInteraction *isect) const {
        <<Compute initial parametric range of ray inside kd-tree extent>> 
        <<Prepare to traverse kd-tree for ray>> 
        <<Traverse kd-tree nodes in order for ray>> 
    }
```

该算法首先求出射线与树的整体参数重叠范围$[t_{min},t_{max}]$，如果没有重叠则立即退出。

```c++
<<Compute initial parametric range of ray inside kd-tree extent>>= 
Float tMin, tMax;
if (!bounds.IntersectP(ray, &tMin, &tMax)) 
    return false;
```

利用**KdToDo结构数组**记录射线中**尚未处理的节点**；它是有序的，因此数组中的**最后一个活动项**是应该考虑的下一个节点。数组中需要的最大条目数就是kd-tree的最大深度；在实践中，下面使用的数组大小应该足够了。

```c++
<<Prepare to traverse kd-tree for ray>>= 
    Vector3f invDir(1 / ray.d.x, 1 / ray.d.y, 1 / ray.d.z);
    constexpr int maxTodo = 64;
    KdToDo todo[maxTodo];
    int todoPos = 0;
<<KdTreeAccel Declarations>>+= 
    struct KdToDo {
        const KdAccelNode *node;
        Float tMin, tMax;
    };
```

遍历继续通过节点，每次通过循环处理单个叶子或内部节点。`tMin`和`tMax`值将始终保持射线与当前节点重叠的参数范围。

```c++
<<Traverse kd-tree nodes in order for ray>>= 
    bool hit = false;
    const KdAccelNode *node = &nodes[0];
    while (node != nullptr) {
        <<Bail out if we found a hit closer than the current node>> 
        if (!node->IsLeaf()) {
            <<Process kd-tree interior node>> 
        } else {
            <<Check for intersections inside leaf node>> 
            <<Grab next node to process from todo list>> 
        }
    }
    return hit;
```

交集之前可能已经在一个原语中发现，该原语重叠了多个节点。如果交集在第一次检测到的时候在当前节点之外，则需要一直遍历树，直到到达`tMin`超出交集的节点。只有这样，才确定不存在与其他原始元素的更紧密的交集。

```c#
<<Bail out if we found a hit closer than the current node>>= 
    if (ray.tMax < tMin) break;
```

对于内部节点，首先要做的是将射线与节点的**分裂平面**相交；给定交点，我们可以确定是否需要处理一个或两个子节点，以及光线通过它们的顺序。

```c++
<<Process kd-tree interior node>>= 
    <<Compute parametric distance along ray to split plane>> 
    <<Get node children pointers for ray>> 
    <<Advance to next child node, possibly enqueue other child>> 
```

**分割平面的参数距离**的计算方法，与**射线包围盒测试中**计算射线和轴向对齐平面的交点的方法相同。我们使用预先计算的`invDir值`在每次循环中节省一个除法。

```c++
<<Compute parametric distance along ray to split plane>>= 
    int axis = node->SplitAxis();
    Float tPlane = (node->SplitPos() - ray.o[axis]) * invDir[axis];
```

现在有必要确定**射线遇到子节点的顺序**，使树沿着射线**从前到后的顺序遍历**。下图显示了这种计算的几何形状。射线的原点相对于分割平面的位置足以区分两种情况。当射线的原点位于分割平面上的罕见情况，在这种情况下需要谨慎处理，因为需要用它的方向来区分两种情况。

![image-20210410135944241](第四章_原语和相交加速.assets/image-20210410135944241.png)

```c++
<<Get node children pointers for ray>>= 
    const KdAccelNode *firstChild, *secondChild;
    int belowFirst = (ray.o[axis] <  node->SplitPos()) ||
                     (ray.o[axis] == node->SplitPos() && ray.d[axis] <= 0);
    if (belowFirst) {
        firstChild = node + 1;
        secondChild = &nodes[node->AboveChild()];
    } else {
        firstChild = &nodes[node->AboveChild()];
        secondChild = node + 1;
    }
```

可能没有必要同时处理这个节点的两个子节点。下图显示了射线只通过其中一个子节点的一些配置。射线不会错过两个子节点，否则当前的内部节点就不会被访问。

<img src="第四章_原语和相交加速.assets/image-20210410140343302.png" alt="image-20210410140343302" style="zoom:67%;" />

下面代码中的==第一个if测试==对应于上图(a)：只有近节点需要处理，如果可以证明射线不重合远节点，因为它面向远节点，或者不重合它，因为$t_{split}>t_{max}$ 。上图(b)显示了在==第二个if测试==中测试的类似情况：如果射线不重合，近节点可能不需要处理。否则，else子句会处理两个子节点都需要处理的情况；近处的节点将被下一步处理，而远处的节点则进入todo列表。

```c++
<<Advance to next child node, possibly enqueue other child>>= 
    if (tPlane > tMax || tPlane <= 0)
        node = firstChild;
    else if (tPlane < tMin)
        node = secondChild;
    else {
        <<Enqueue secondChild in todo list>> 
        node = firstChild;
        tMax = tPlane;
    }
<<Enqueue secondChild in todo list>>= 
    todo[todoPos].node = secondChild;
    todo[todoPos].tMin = tPlane;
    todo[todoPos].tMax = tMax;
    ++todoPos;
```

如果当前节点是叶节点，则对叶节点中的原语执行交叉测试。

```c++
<<Check for intersections inside leaf node>>= 
    int nPrimitives = node->nPrimitives();
    if (nPrimitives == 1) {
        const std::shared_ptr<Primitive> &p = primitives[node->onePrimitive];
        <<Check one primitive inside leaf node>> 
    } else {
        for (int i = 0; i < nPrimitives; ++i) {
            int index = primitiveIndices[node->primitiveIndicesOffset + i];
            const std::shared_ptr<Primitive> &p = primitives[index];
            <<Check one primitive inside leaf node>> 
        }
    }
```

```c#
<<Check one primitive inside leaf node>>= 
if (p->Intersect(ray, isect)) 
    hit = true;
```

在叶节点上执行交叉测试之后，将从todo数组加载下一个要处理的节点。如果没有更多的节点，那么射线已经穿过了树而没有击中任何东西。

```c++
<<Grab next node to process from todo list>>= 
if (todoPos > 0) {
    --todoPos;
    node = todo[todoPos].node;
    tMin = todo[todoPos].tMin;
    tMax = todo[todoPos].tMax;
}
else
    break;
```

