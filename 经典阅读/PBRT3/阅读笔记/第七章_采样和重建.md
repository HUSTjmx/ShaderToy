# 采样和重建

![image-20210414143119976](第七章_采样和重建.assets/image-20210414143119976.png)

尽管像==pbrt==这样的渲染器的最终输出是一个**彩色像素的2D网格**，但入射亮度实际上是在`film`平面上定义的**连续函数**。**从该连续函数计算离散像素值的方式**可以显著地影响由渲染器生成的最终图像的质量；如果不仔细执行此过程，就会出现**伪影**。相反地，如果执行得很好，那么相对少量的额外计算就可以大大提高渲染图像的质量。

本章首先介绍==抽样理论==，即从**定义在连续域上的函数**中取**离散样本值**，然后利用这些样本重建**与原函数相似的新函数**的理论。本章定义的[`Sampler`](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Sampling_Interface.html#Sampler)s根据采样理论的原理，结合==低偏差点集==（一种特殊的均匀分布的采样点）的思想，通过多种方式生成**n维样本向量**。本章描述了**五种采样器**的实现，它们覆盖了解决采样问题的各种方法。

[toc]

## 1 .采样理论

数字图像表示为一组像素值，通常在一个**矩形网格**上排列。当数字图像显示在物理设备上时，这些值被用来确定显示器上的像素所发射的光谱功率。在思考数字图像时，**重要的是要区分图像像素和显示像素**，前者代表**特定采样位置的函数值**，后者则是**发出具有一定分布的光的物理对象**。(例如，在液晶显示器中，当以斜角观看显示器时，颜色和亮度可能会发生很大的变化)。显示器使用**图像像素值**在显示表面上构造一个新的**图像函数**。这个函数是在显示器上的所有点定义的。这种将**样本值集合**转换回**连续函数**的过程称为==重构==。

为了计算**数字图像**中的**离散像素值**，有必要对**原始连续定义的图像函数**进行==采样==。在`pbrt`中，就像大多数**其他的光线追踪渲染器**一样，获取**图像函数信息**的唯一方法是通过**追踪光线**进行采样。例如，没有一般的方法可以计算`film plane`上两点之间图像函数**变化的界限**。虽然只需在像素位置精确地取样就可以生成图像，但通过**在不同的位置取更多的样本**，并将这些关于**图像函数的附加信息**纳入到最终的像素值中，就可以得到更好的结果。事实上，为了获得最佳的质量结果，**像素值的计算**应使显示设备上的**重建图像**尽可能地接近虚拟相机`film plane`上的**场景原始图像**。请注意，这与期望**显示器的像素**在其位置上采取**图像函数的实际值**是一个微妙的不同目标。==处理这种差异是本章实现的算法的主要目标==。

> Note that this is a subtly different goal from expecting the display’s pixels to take on the image function’s actual value at their positions. Handling this difference is the main goal of the algorithms implemented in this chapter.

由于**取样**和**重建**过程涉及到**近似**，它引入了被称为`aliasing`的错误，它可以以多种方式表现出来，包括动画中的**锯齿状边缘**或**闪烁**。这些错误的出现是因为**采样过程**无法捕捉到**连续定义的图像函数的所有信息**。

作为这些理论的一个例子，考虑一个**一维函数**$f(x)$（我们可以互换地称之为**信号**），我们可以在**函数域**中的任意位置$x^/$求值$f(x^/)$。每个这样的位置$x^/$称为**采样位置**，其值为**采样值**$f(x^/)$。如下图，对曲线`f`采样，然后对采样点使用线性插值，重建得到$f^/$。

<img src="第七章_采样和重建.assets/image-20210414145123486.png" alt="image-20210414145123486" style="zoom:80%;" />

==傅里叶分析==可以用来评估**重构函数**和**原始函数**之间的==匹配质量==。本节将介绍**傅里叶分析的主要思想**，以完成采样和重构过程的某些部分，但将省略许多属性的证明，并跳过与**pbrt中使用的采样算法**不直接相关的细节。

### 频域和傅里叶变换

==傅里叶变换==是**傅里叶分析**的基础之一，它在**频域**中表示一个函数。(我们会说，函数通常在**空间域**中表示）。考虑下图中所示的两个函数。图7.(a)的函数变化相对缓慢，而图(b)的函数变化快得多。**变化较慢的函数**含有较多低频成分：

<img src="第七章_采样和重建.assets/image-20210414145624497.png" alt="image-20210414145624497" style="zoom:67%;" />

<img src="第七章_采样和重建.assets/image-20210414145813395.png" alt="image-20210414145813395" style="zoom:67%;" />

**大多数函数**可以分解为==移位正弦波==的**加权和**。这个显著的事实是由`Joseph Fourier`首先描述的，而**傅里叶变换**将函数转换成这种表示方式。通过函数的这种**频率空间表示形式**，可以深入了解函数的一些特征：**正弦函数中的频率分布与原函数中的频率分布相对应**。利用这种形式，可以利用**傅里叶分析**来洞察采样和重建过程中**引入的误差**，以及如何减少这种误差对感知的影响。

一维函数$f(x)$的**傅里叶变换**是

![image-20210414145845813](第七章_采样和重建.assets/image-20210414145845813.png)

回顾：$e^{ix}=cosx+isinx,i=\sqrt{-1}$。这里我们只考虑==偶函数==，这种情况下的傅里叶变换`f`没有**虚数项**。新函数`F`是频率`w`的函数。我们用这样的方式表示**傅里叶变换算子**：$F\{f(x)\}=F(w)$。F是==线性算子==。

上面的方程被称为==傅里叶分析方程==，或者只是**傅里叶变换**。我们也可以用==傅里叶合成方程==，或者傅里叶反变换，从频域变换回空间域：

![image-20210414150216579](第七章_采样和重建.assets/image-20210414150216579.png)

表7.1显示了一些重要的函数及其频率空间表示。很多这样的函数都是基于==狄拉克分布==——一个特殊的函数$\int\delta(x)dx=1，\forall x \neq0,\delta(x)=0$。这些性质的一个重要结果是：

![image-20210414150426215](第七章_采样和重建.assets/image-20210414150426215.png)

==delta分布==不能表示为一个标准的数学函数，而通常被认为是以原点为中心、宽度接近`0`的**单位面积方框函数的极限**。

<img src="第七章_采样和重建.assets/image-20210414150503804.png" alt="image-20210414150503804" style="zoom: 50%;" />

### 理想采样与重构

利用频域分析，我们可以正式地研究**采样的性质**。回想一下，**采样过程**要求我们选择一组等间距的采样位置，并计算这些位置上的函数值。形式上，这对应于用函数乘以一个“==shah==”，或“脉冲序列”函数。其定义是：

![image-20210415125126661](第七章_采样和重建.assets/image-20210415125126661.png)

`T`定义了采样频率，这个乘法在等距点上产生一个**无穷序列的函数值**：

![image-20210415125226177](第七章_采样和重建.assets/image-20210415125226177.png)

![image-20210415125235315](第七章_采样和重建.assets/image-20210415125235315.png)

这些样本值可以通过选择**重构滤波器函数**==r(x)==，并计算卷积，来定义重构函数f (x)

![image-20210415125532485](第七章_采样和重建.assets/image-20210415125532485.png)

其中==卷积运算==⊗的定义是：

![image-20210415125552677](第七章_采样和重建.assets/image-20210415125552677.png)

![image-20210415130456956](第七章_采样和重建.assets/image-20210415130456956.png)

傅里叶分析中使用的一个重要思想是：两个函数F{F(x)，g(x)}的**乘积的傅里叶变换**可以被证明是它们各自傅里叶变换F(ω)和g(ω)的**卷积**:

![image-20210415130902680](第七章_采样和重建.assets/image-20210415130902680.png)

同样，空间域的卷积等价于频域的乘法：

![image-20210415130927346](第七章_采样和重建.assets/image-20210415130927346.png)

利用这些思想，在空间域中的**原始采样步骤**，即shah函数和原始函数f(x)的乘积，可以等价地用F(ω)与另一个**shah函数在频率空间中的卷积**来描述。

==周期为T的函数的傅里叶变换是另一个周期为1/T的函数==。记住周期之间的倒数关系是很重要的：**这意味着如果样本在空间域中距离较远，它们在频率域中就会距离较近**

因此，**采样信号的频域**表示由F(ω)和这个**新的shah函数**的卷积给出。用==delta函数==卷积只是得到**一个函数的副本**，所以**用shah函数卷积**会得到一个==无限的原函数副本序列==，其间距等于**shah的周期**（下图）。这就是一系列样本的频域空间表示方法

![image-20210415131544635](第七章_采样和重建.assets/image-20210415131544635.png)

现在我们已经有了函数频谱的**无限副本集**，那么我们如何重建原始函数呢？从图7.6来看，答案是显而易见的：只要舍弃所有的**频谱副本**，除了以原点为中心的副本，就可以得到原始的==F(ω)==。为了丢弃除了中心的频谱副本之外的所有副本，我们乘以一个适当宽度的`box`函数（图7.7）。

![image-20210416121912716](第七章_采样和重建.assets/image-20210416121912716.png)

box函数定义如下：

![image-20210416121942815](第七章_采样和重建.assets/image-20210416121942815.png)

这个乘法步骤对应于空间域**与重构滤波器的卷积**。这是理想的采样和重建过程。总结:

![image-20210416122254056](第七章_采样和重建.assets/image-20210416122254056.png)

在**空间域**中应用等效过程，同样可以精确恢复f(x)。因为`box`函数的傅里叶反变换是==sinc函数==，所以**理想的空间重构**是：

![image-20210416122511126](第七章_采样和重建.assets/image-20210416122511126.png)

![image-20210416122525097](第七章_采样和重建.assets/image-20210416122525097.png)

不幸的是，由于**sinc函数**具有无限范围，因此必须使用所有采样值f(i)来计算空间域中f(˜ x)的任何特定值。对于实际的实现来说，==空间范围有限的滤波器==是比较理想的，即使它们不能完美地重建原始函数。

在图形学中，一个常用的替代方法是使用==box函数==进行重构，有效地对**x周围某个区域内**的所有采样值进行**平均**，这是个非常糟糕的选择，考虑**box滤波器**在频域中的行为可以看出：这种技术试图通过乘以一个==sinc==来隔离函数频谱的中心副本，这不仅对**选择函数频谱中心副本**不好，而且还包括了它的其他副本（无限）的**高频贡献**。

### 锯齿

除了**sinc函数**区域无限大的问题外，理想采样和重建方法最严重的一个实际问题是：==信号带限的假设==。对于不受频带限制的信号，或者没有以**足够高的采样率**对其频率内容进行采样的信号，**前面描述的过程将重建一个与原始信号不同的函数**。

:star:**成功重构的关键**是能够准确地**恢复原始频谱F(ω)**，将采样频谱与一个适当宽度的箱函数相乘。请注意，在图 7.6 中，信号的频谱副本被空隙隔开，所以完美的重建是可能的。然而，如果原始函数是以较低的采样率进行采样，**那么考虑一下会发生什么**。回想一下，**周期为T的Shah函数T的傅里叶变换是一个周期为1/T的新Shah函数。这意味着，如果在空间域中，样本之间的间距增大，那么在频域中，样本间距就会减小，从而将频谱F(ω)的副本推得更近。如果副本靠得太近，它们就会开始重叠。**

![image-20210416124452685](第七章_采样和重建.assets/image-20210416124452685.png)

当这个新的频谱与**box函数**相乘时，其结果是一个与==原始F(ω)==相似但不相等的频谱：**原始信号中的高频细节**泄漏到**重建信号频谱的低频区域**。这些新的低频伪影被称为`aliases`（==因为高频被 "伪装 "成低频==）。图7.9显示了重建一维函数$f(x)=1+cos(4x^2)$的`aliasing`效应（欠采样`undersampling`）。

解决**频谱重叠问题**的一个办法：提高采样率，直到**频谱的副本**相距足够远，不至于重叠，从而彻底消除`aliasing`。事实上，==采样定理==告诉了我们到底需要什么样的速率。该定理说，只要==均匀采样点的频率ωs==大于信号中==最大频率ω0==的==两倍==，就可以从采样中完美地重建原始信号。这个最小采样频率称为==奈奎斯特频率==。

对于非频带限制的信号（==ω0=∞==），不可能以足够高的采样率来进行完美重建。不幸的是，**在计算机图形学中，很少有函数是有频带限制的**。特别是，**任何包含不连续域的函数都不可能频带限制**，因此我们无法对其进行完美的采样和重建。这是有道理的，因为**函数的不连续**总是落在两个样本之间，而==样本没有提供关于不连续位置的信息==。因此，除了增加采样率之外，还需要应用其他方法。

### 抗锯齿技术

当我们希望精确时，我们称**采样伪影**为==前锯齿==，**重建伪影**为==后锯齿==。任何修复这些错误的尝试都被广泛地归为==抗锯齿==。本节将回顾一些抗锯齿技术，而不仅仅是增加采样率。

#### 非均匀采样

通过非均匀的方式改变**样本之间的间距**，可以减少`aliasing`对视觉的影响。如果`ξ`表示0和1之间的一个随机数，那么基于脉冲序列的**非均匀样本集**就是

![image-20210416130151108](第七章_采样和重建.assets/image-20210416130151108.png)

均匀采样和非均匀采样都会产生不正确的重建信号。然而，==非均匀采样往往会将有规律的`aliasing`伪影变成噪声==，这对HSV干扰较小。

#### 自适应采样

另一种方法是==自适应超采样==：如果我们能够识别出信号中频率高于**奈奎斯特极限**的区域，我们就可以在这些区域采集更多的样本，而不需要增加所有采样频率。在实践中，要让这种方法很好地发挥作用是很困难的，因为找到**需要超采样的地方**是很困难的。**大多数技术都是基于对相邻采样值的检查**，并找到两个采样值之间有显著变化的地方，假设信号在该区域有高频率。

一般来说，**相邻的样本值**不能确定地告诉我们：它们之间到底发生了什么：即使数值相同，函数之间也可能有巨大的变化。另外，相邻的样本可能具有实质上不同的值，而实际上并不存在任何`aliasing`。

#### 预过滤:star:

:star:另一种方法是==对原始函数进行过滤==（**即模糊**），以便**在所使用的采样率下**，**不留下无法准确捕捉的高频**。这种方法在第10章的纹理函数中得到了应用。虽然**这种技术通过从函数中删除信息来改变被采样函数的特性**，但模糊通常比`aliasing`更不令人反感。

回想一下，我们想要将**原始函数的频谱**与**宽度合适的box滤波器**相乘，以便去除奈奎斯特限制以上的频率。在空间域中，这相当于将原始函数与一个==sinc滤波器==进行卷积

![image-20210416132201251](第七章_采样和重建.assets/image-20210416132201251.png)

在实践中，我们可以使用一种**有限范围的滤波器**，效果很好。这种滤波器的**频率空间表示**可以帮助澄清它对**理想sinc滤波器**行为的近似程度。

<img src="第七章_采样和重建.assets/image-20210416133045852.png" alt="image-20210416133045852" style="zoom:67%;" />

图7.10显示了函数$1+cos(4x^2)$与第7.8节将介绍的**有限范围的sinc变体**的卷积。请注意，高频细节已经被消除；这个函数可以以图7.9中使用的采样率进行采样和重构，而不会产生混叠。

### 在图像合成中的应用

我们有一个图像，我们可以把它看作是**2D (x, y)图像位置**到**亮度值L**的函数。好消息是，通过射线跟踪器，可以任何(x，y)点计算这个函数。坏消息是，在采样之前，一**般不可能对f进行预过滤**，以去除其中的高频。因此，本章中的采样器将使用两种策略，即在最终图像中**增加采样率**，以及**非均匀分布采样**。

将**场景函数的定义**概括为一个更高维度的函数是很有用的，这个函数也取决于时间t和(u, v)镜头位置。对于一个特定的图像位置，该点的辐射度通常会随着时间（如果场景中有移动的物体）和镜头位置（如果相机有一个有限孔径镜头）的变化而变化。

更普遍的是，因为在第14章到第16章中定义的许多积分器使用==统计技术==来估计给定射线的辐射度，当重复给出相同的射线时，它们可能返回不同的辐射度值。如果我们进一步扩展场景亮度函数，使其包含积分器使用的样本值，我们将得到一个更高维度的图像函数

![image-20210416134212039](第七章_采样和重建.assets/image-20210416134212039.png)

### 渲染中aliasing的来源

**几何学**是渲染图像中最常见的原因之一。当投射到图像平面上时，**物体的边界会引入一个阶跃函数**。不仅如前所述，**阶跃函数具有无限的频率域**，而且更糟糕的是，完美的重建滤波器在应用时，会引起伪影：在重建函数中出现==环状伪影==，这种效应被称为`Cibbs`现象。图7.11显示了一个1D函数的这种效应的例子。

<img src="第七章_采样和重建.assets/image-20210416135135044.png" alt="image-20210416135135044" style="zoom:67%;" />

场景中非常小的物体也会造成`几何aliasing`。如果几何体足够小，以至于它落在**图像平面上的样本之间**，它可能会在动画的多个帧中不可预知地消失和重新出现。

锯齿的另一个来源可能来自**物体的纹理和材质**。`Shading aliasing`可能是由**没有被正确过滤的纹理贴图**引起的（解决这个问题是第10章的大部分内容），或者是由闪亮表面上的小亮点引起的。如果取样率不够高，无法充分采样这些特征，就会产生锯齿。此外，**物体投下的尖锐阴影会在最终图像中引入另一个阶梯函数**，而从阴影边界检测**阶跃函数**比较困难。

### UNDERSTANDING PIXELS

在本章的其余部分，**有两个关于像素的观点是必须牢记的**。首先，必须记住，**构成图像的像素**是图像平面上**离散点的图像函数的采样**，没有与像素相关的 "面积"。正如阿尔维-雷-史密斯（Alvy Ray Smith，1995）指出的那样，==把像素看成是面积有限的小正方形是一种不正确的心理模型，会导致一系列的错误==。通过用信号处理的方法介绍本章的主题，我们试图为一个更准确的心理模型打下基础。

![image-20210416141612524](第七章_采样和重建.assets/image-20210416141612524.png)

第二个问题是，**最终图像中的像素**自然是在**像素网格上的离散整数（x，y）坐标**处定义的，但本章中的==Samplers==是在**连续的浮点（x，y）位置**生成图像样本的。在这**两个域之间映射**的自然方法是将**连续坐标舍入到最近的离散坐标**；这很吸引人，因为它将恰好与离散坐标具有相同值的连续坐标映射到该离散坐标上。结果是，**给定一组跨越[x0，x1]范围的离散坐标，覆盖该范围的连续坐标集是[x0 - 1/2，x1 + 1/2)**。因此，任何为给定的**离散像素范围**生成连续样本位置的代码，都会遍布`1/2`的偏移量。很容易忘记其中的一些，导致细微的错误。

如果我们将**连续坐标c**截断为**离散坐标d**

![image-20210416141454964](第七章_采样和重建.assets/image-20210416141454964.png)

将离散转换为连续：

![image-20210416141600033](第七章_采样和重建.assets/image-20210416141600033.png)



## 2. 采样接口

正如在第7.1.5节中所介绍的，**pbrt中实现的渲染方法涉及到在图像平面上二维点以外的其他维度上选择采样点**。各种不同的算法都会被用来生成这些点，但是所有这些算法的实现都继承自一个定义了它们接口的==抽象Sampler类==。核心采样声明和函数在文件core/sampler.h和core/sampler.cpp中，每个采样生成的实现都在自己的源文件中，在samplers/目录下。

采样器的任务是在$[0,1)^n$中生成一个**n维样本序列**，为每个**图像样本**生成一个这样的样本向量，每个样本的维数n可能不同，这取决于**光传输算法**执行的计算。

![image-20210416142158358](第七章_采样和重建.assets/image-20210416142158358.png)

因为样本值必须严格小于1，所以定义一个常数`OneMinusEpsilon`是很有用的，它表示**小于1的最大可表示浮点常数**。随后，我们将采样向量值夹在不大于这个值的范围内。

![image-20210416142546197](第七章_采样和重建.assets/image-20210416142546197.png)

**采样器最简单的实现**就是：在每次需要**采样向量的额外分量**时，返回[0，1]中的均匀随机值。这样的采样器可以产生正确的图像，但需要更多的采样（因此，需要更多的射线跟踪和更多的时间）来产生与更复杂的采样器相同质量的图像。**使用更好的采样模式的运行时间花费与均匀随机数等低质量模式的运行时间花费大致相同**；因为计算每个图像样本的辐射度比计算样本的分量值要贵得多，所以做这项工作是有好处的。

下面假设这些样本向量的一些特征：

+ 前两个维度专门用于选择当前像素区域内的图像上的一个点；第三个维度用于计算拍摄样本的时间；第四和第五个维度给出了景深的(u，v)镜头位置。
+ 有些抽样算法在某些维度产生的样本比在其他维度产生的样本要好。在系统的其他地方，我们假设在一般情况下，较早的维度有最合适的样本值。(?)

还要注意的是，由采样器生成的**n维样本**通常不会显式表示或完整地存储，而是根据**光传输算法的需要**逐渐生成。

### 评估样本模式：差异性

<img src="第七章_采样和重建.assets/image-20210416143834214.png" alt="image-20210416143834214" style="zoom:67%;" />

**傅里叶分析**为我们提供了一种评估**二维采样模式质量**的方法，但它所带来的影响仅限于：通过在**有限频带频率范围**内，增加更多均匀间隔的样本，来量化**所能带来的改善**。考虑到**图像边缘**存在无限大的频率内容，以及**蒙特卡罗光传输算法**需要(n > 2)维样本向量，**单靠傅里叶分析是不够的**。

给定一个渲染器和一个放置样本的候选算法，评估**算法有效性**的一种方法是：使用该采样模式渲染一幅图像，并计算图像与使用大量样本渲染的参考图像相比的误差。我们将在本章后面使用这种方法来比较采样算法，不过它只能告诉我们算法在一个特定场景下的效果如何，在没有经过渲染过程的情况下，它并不能让我们感受到采样点的质量。

在傅立叶分析之外，数学家发展了一个叫做==差异==`discrepancy`的概念，可以用来评估n维采样模式的质量。**分布良好的模式具有低差异值**，因此**样本模式生成问题**可以被认为是一个**寻找合适的低差异模式的问题**。

==差异的基本思想==是，在一个n维空间$[0,1)^n$中的**一组点的质量**可以通过观察域$[0,1)^n$的区域，计算每个区域内的**点的数量**，并将每个区域的体积与里面的样本点的数量进行比较来评估。一般来说，一**个给定的体积分数**，和内部的**样本点总数的分数**应该大致相同。我们尝试使用模式，使**实际容量**和**点估算的容量**之间的==最大差异最小化==。图7.15给出了二维的例子。

![image-20210416145842168](第七章_采样和重建.assets/image-20210416145842168.png)

为了计算一组点的差异，我们首先选择一个形状B族（family of shapes B ），是$[0,1)^n$的子集。例如，经常使用在原点有一个角的`box`。这对应于：

![image-20210417115910532](第七章_采样和重建.assets/image-20210417115910532.png)

对于一个采样序列$P=x_1,....,x_N$，P和B之间的差异是：

![image-20210417120216400](第七章_采样和重建.assets/image-20210417120216400.png)

其中，$\#\{x_i\in b\})$是$b$内点的数量，而$V(b)$是$b$的体积。当**形状B的集合**是以原点为角的`set of boxes`时，这个值被称为==星形差==，$D^*(P)$。B的另一个流行选项是**所有轴对齐框的集合**。

对于一些特定的点集，**差异**可以解析计算出来。例如，考虑一维的点集：
$$
x_i=\frac{i}{N}
$$
可以看到$x_i$的星差是：

![image-20210417120933471](第七章_采样和重建.assets/image-20210417120933471.png)

该序列的星差可以通过稍微修改来改善：

![image-20210417121139645](第七章_采样和重建.assets/image-20210417121139645.png)

![image-20210417121145766](第七章_采样和重建.assets/image-20210417121145766.png)

在一维中，一系列点的==星点差==的界限已被证明是：

![image-20210417121222350](第七章_采样和重建.assets/image-20210417121222350.png)

对于构造不那么简单的点序列、多维度更高的序列以及比盒形更不规则的形状，通常必须通过构造大量**形状b**，计算它们的差异，并报告**发现的最大值**，来对**差异**进行==数字估计==。

**单纯的差异性并不一定是一个好的度量标准**：一些**低差异性的点集**会表现出一些**样本的丛生**，其中两个或多个样本可能非常接近。一个样本与另一个样本越近，就越不可能提供关于**被抽样函数**的有用信息。因此，计算一组点中==任何两个样本之间的最小距离==也被证明是衡量**采样模式质量**的有用指标；最小距离越大，越好。

有许多算法可以生成==泊松盘采样模式==`Poisson disk`，这些模式在这个指标上得分很高。通过构造，在**泊松盘模式**中没有两个点比某个距离更近。研究表明，==眼睛中的视杆细胞和视锥细胞以类似的方式分布==，这进一步证实了这种分布对成像是一个不错的分布。在实践中，我们发现**泊松圆盘模式**对于二维图像的采样工作得很好，但与在**更复杂的渲染现场**进行**高维采样的低差异模式**相比，它的有效性较低。

### 基本的采样器接口

==Sampler基类==不仅定义了采样器的接口，而且为采样器的实现提供了一些常用的功能。

所有采样器实现必须向**构造函数**提供最终图像中**每个像素将生成的采样数**。我们使用一个精度为`64`位的变量，来存储采样计数。

![image-20210417122508008](第七章_采样和重建.assets/image-20210417122508008.png)

:one:当**渲染算法**准备好对某个像素开始工作时，它首先调用`StartPixel()`，需要提供图像中**像素的坐标**。

![image-20210417122659474](第七章_采样和重建.assets/image-20210417122659474.png)

`Get1D()`方法返回当前样本向量下一个维度的样本值，`Get2D()`返回两个维度的样本值.

![image-20210417122748106](第七章_采样和重建.assets/image-20210417122748106.png)

在`pbrt`中，我们不支持来自采样器的**3D或更高维度采样值**的请求，因为这里实现的渲染算法类型通常不需要这些采样值。如果有必要，来自**低维组件的多个值**可以用来构建**高维采样点**。

Sampler基类提供了一个方法来初始化给定像素的`CameraSample`。

![image-20210417123147923](第七章_采样和重建.assets/image-20210417123147923.png)

:two:如果需要==样本数组==，必须在渲染开始前请求它们。Request[12]DArray()方法应该在渲染开始之前，为每个这样的维度的数组调用——例如，在重写`SamplerIntegrator:.Preprocess()`方法的方法中。例如，在一个有**两个区域光源**的场景中，积分器将**四条阴影光线**追踪到**第一个光源**，**八个阴影光线**追踪到**第二个光源**，积分器将要求为每个图像样本提供**两个 2D 样本数组**，分别有`4`个和`8`个样本。(之所以需要一个二维阵列，是因为需要两个维度来参数化光的表面)。

![image-20210417123719732](第七章_采样和重建.assets/image-20210417123719732.png)

`Sampler::RoundCount()`方法有助于传达这个信息。需要样本数组的代码应该调用这个方法，并提供**所需的样本数**，让`Sampler`有机会将**样本数**调整到一个**更好的数字**。然后，**返回的值**应该被用作实际向`Sampler`请求的样本数，**默认的实现是不变地返回给定的计数**。

![image-20210417124012240](第七章_采样和重建.assets/image-20210417124012240.png)

在渲染过程中，可以调用`Get[12]DArray()`方法来获取一个指针。沿着`Get1D()`和`Get2D()`的思路，这些方法返回一个**指向样本数组的指针**，其大小由初始化期间相应调用`Request[12]DArray()`的参数`n`给出。调用者还必须向 "get "方法提供数组大小，该方法用于验证**返回的缓冲区**是否具有**预期的大小**。

![image-20210417124305129](第七章_采样和重建.assets/image-20210417124305129.png)

:three:当一个样本的工作完成后，积分器调用`StartNextSample()`。这个调用通知采样器，后续的**采样组件请求**应该从当前像素的下一个样本的第一个维度开始返回值。这个方法返回真值，直到**每个像素最初请求的样本数**被生成为止（此时，调用者应该开始在另一个像素上工作）。

![image-20210417131052199](第七章_采样和重建.assets/image-20210417131052199.png)

**Sampler的实现**存储了关于当前样本的各种状态：哪个像素正在被采样，样本的多少维度已经被使用，等等。一个`Sampler`被**多个线程**同时使用是不安全的。`Clone()`方法生成了一个**初始Sampler**的新实例，供渲染线程使用；它为`Sampler`的随机数生成器（如果有的话）取一个种子值，这样不同的线程就可以看到不同的**随机数序列**。在多个`image tiles`上重复使用**相同的伪随机数序列**可能会导致微妙的图像伪影，例如重复的噪声模式。

![image-20210417131722211](第七章_采样和重建.assets/image-20210417131722211.png)

有些**光传输算法**在进入下一个像素之前，并不使用一个像素中的所有样本，而是在像素间跳转，每次在像素中取**一个样本**。`SetSampleNumber()`方法允许积分器设置当前像素中**要生成下一个像素的样本索引**。一旦`sampleNum`大于或等于每个像素的**原始请求样本数**，该方法就会返回`false`。

![image-20210417132009019](第七章_采样和重建.assets/image-20210417132009019.png)



### 采样器的实现

:one:**Sampler基类**在其内部提供了一些方法的实现。首先，`StartPixel()`方法实现记录正在采样的**当前像素的坐标**，并将当前生成的像素中的采样数`currentPixelSampleIndex`重置为零。注意，这是一个带有实现的虚拟方法；重写这个方法的子类需要显式调用`Sampler::StartPixel()`。

![image-20210417132213034](第七章_采样和重建.assets/image-20210417132213034.png)

![image-20210417132245490](第七章_采样和重建.assets/image-20210417132245490.png)

当**像素采样**提前或显式设置时，`currentPixelSampleIndex`也会相应更新。与`StartPixel()`一样，方法`StartNextSample()`和`SetSampleNumber()`都是虚实现，也必须由Sampler子类中对它们的重载实现明确调用。

![image-20210417132444444](第七章_采样和重建.assets/image-20210417132444444.png)

:two:**基类Sampler实现**还负责记录对**样本组件数组**的请求，并为它们的值分配存储空间。请求的样本数组的大小存储在`samples1DArraySizes`和`samples2DArraySizes`中，整个像素的数组样本的内存分配在`sampleArray1D`和`sampleArray2D`中。每次分配中的前n个值用于像素中第一个样本，以此类推

![image-20210417132817565](第七章_采样和重建.assets/image-20210417132817565.png)

当通过`Get[12]DArray()`方法访问当前样本中的数组时，`array1D Offset`和`array2DOffset`被更新为**保存下一个要返回的、样本向量数组的索引**。

![image-20210417133003627](第七章_采样和重建.assets/image-20210417133003627.png)

当**启动一个新像素**或当前像素中的**样本数**发生变化时，这些数组偏移量必须重置为`0`。

![image-20210417133045390](第七章_采样和重建.assets/image-20210417133045390.png)

返回**合适的数组指针**是先根据当前样本向量中消耗了多少样本，来选择合适的数组，然后根据**当前像素样本索引**返回合适的实例。

![image-20210417133342379](第七章_采样和重建.assets/image-20210417133342379.png)

![image-20210417144035087](第七章_采样和重建.assets/image-20210417144035087.png)

> 为什么会有样本数组呢？例如，就后面的像素采样器来说，我们只有维度和采样数两个维度，也就是说，我们只需考虑为每个像素，考虑生成N个采样（采样又是M维度），但我们继续考虑，当射线击中一个表面时，除了反射方向外，我们可能还需要考虑面积光源（K边形），所以我们还需要为生成额外K组$N_i$个$M_i$维度采样。

:star:采样数组理解`1`

### 像素采样器

同时生成采样向量的所有维度的采样值。`PixelSampler类`实现了一些对**实现这些类型的采样器**有用的功能。

**渲染算法**将使用的**样本向量的维数**并不是提前知道的。事实上，它只是由`Get1D()`和`Get2D()`调用的次数以及**所请求的数组**来隐含决定的。因此，`PixelSampler constructor` 取一个最大的维数，`Sampler` 将计算**非数组样本值**。如果所有这些维度的组件都被消耗掉了，那么`PixelSampler`只会返回**额外维度的均匀随机值**。

对于每个**预计算的维度**，构造函数分配一个向量来存储样本值，像素中的每个样本都有一个值。这些向量的索引为`sample1D[dim][pixelSample]`。

![image-20210417135611142](第七章_采样和重建.assets/image-20210417135611142.png)

继承自`PixelSampler`的**Sampler实现的关键责任**就是：在它们的`StartPixel()`方法中填充`samples1D`和`samples2D`数组。

![image-20210417140144493](第七章_采样和重建.assets/image-20210417140144493.png)

![image-20210417140201813](第七章_采样和重建.assets/image-20210417140201813.png)

给定`PixelSampler`子类计算出的数组中的样本值，`Get1D()`的实现只是返回连续维度的值，直到所有**计算出的维度**都被消耗掉，这时会返回**统一的随机值**。

![](第七章_采样和重建.assets/image-20210417140358466.png)

![image-20210417140453449](第七章_采样和重建.assets/image-20210417140453449.png)



### 全局采样器

:one:其他生成采样的算法在很大程度上不是==基于像素的==，而是**自然生成**分布**在整个图像中**的**连续样本**，连续访问**完全不同的像素**。（这样的采样器将一个**额外的采样**放置在**n维样本空间**中，使其填满最大的洞，这导致**后续的样本**在不同的像素内:?:）

到目前为止，这些采样算法在**采样器接口**上有些问题：例如，考虑一个取样器，它为**前两个维度**生成`表7.2`==中间列==所示的一系列样本值。这些采样值乘以每个维度上的图像分辨率，就得到了图像平面上的采样位置（为了简单起见，这里我们考虑的是**2×3的图像**），请注意，对于这里的采样器（实际上是`HaltonSampler`），**每六个采样**会访问每个像素。如果我们要渲染一个每个像素三个采样的图像，那么为了生成像素`（0，0）`的样本，我们需要生成索引为`0，6，12`的样本。

![image-20210417141002692](第七章_采样和重建.assets/image-20210417141002692.png)

考虑到这样的采样器的存在，我们可以定义采样器接口，这样它就**可以为每个采样器指定要渲染的像素**，而不是相反

采用目前的设计有很好的理由：这种方法可以很容易地将`film`分解成小的图像`tiles`，进行==多线程渲染==，每个线程计算局部区域的像素，可以有效地合并到最终图像中。因此，我们必须要求这种采样器**不按顺序生成样本**，这样每个像素的所有样本都会连续生成。

:two:`GlobalSampler`有助于在**Sampler接口的期望**和**这些类型的采样器的自然操作**之间**架起桥梁**。它提供了所有**纯虚 Sampler 方法**的实现，并以**三个新的纯虚方法**来实现这些方法，而它的子类必须实现这些方法。

![image-20210417142642299](第七章_采样和重建.assets/image-20210417142642299.png)

有两个方法是实现者必须提供的。

+ 第一个方法，`GetIndexForSample()`，执行从**当前像素和给定的样本索引**，到**总体样本向量集的全局索引**的==反向映射==。例如，对于`生成表7.2`中的Sampler，如果`currentPixel`是`(0，2)`，那么`GetIndexForSample(0)`将返回`2`，因为样本索引2的对应像素样本坐标(0.25，0.666667)对应的是落在该像素区域的第一个样本。
  ![image-20210417142912358](第七章_采样和重建.assets/image-20210417142912358.png)

+ 此密切相关的是`SampleDimension()`，它返回序列中==indexth采样向量==的**给定维度的采样值**。因为前两个维度是用来偏移到当前像素中的，所以它们会被特殊处理：这个方法返回的值应该是**当前像素中的采样偏移量**，而不是原始的$[0,1)^2$样本值。对于表 7.2 中的例子，`SampleDimension(4,1)`将返回` 0.333333`，因为索引 4 的样本的第二个维度就是像素(0, 1)的偏移。
  ![image-20210417143400203](第七章_采样和重建.assets/image-20210417143400203.png)

:three:当开始为一个像素生成采样时，需要重置**样本的维数**，找到该像素中第一个样本的索引。与所有采样器一样，**样本数组的值**都是接下来生成的

![image-20210417143607706](第七章_采样和重建.assets/image-20210417143607706.png)

`dimension` 成员变量跟踪下一个维度，**采样器实现**将被要求生成一个样本值；当`Get1D()`和`Get2D()`被调用时，它将被递增。`intervalSampleIndex`记录了当前像素中，对应于当前样本$s_i$的**样本索引**。

![image-20210417145040223](第七章_采样和重建.assets/image-20210417145040223.png)

有必要决定将**样本向量的哪些维度**用于**数组采样**。在假设**早期的维度**比**后期的维度**质量更好的情况下，为`CameraSample`预留前几个维度是很重要的，因为**这些样本值的质量往往对最终的图像质量有很大影响**。

:four:因此，从`arrayStartDim`开始的第一个维度用于常规的一维和二维采样，随后的维度用于先做一维，再做二维数组采样。最后，从`arrayEndDim`开始的更高维度用于进一步的非数组1D和2D采样。当**GlobalSampler构造函数**运行时，不可能计算`arrayEndDim`，因为积分器还没有请求**数组采样**。因此，这个值是在 `StartPixel() `方法中计算的。

![image-20210417145818687](第七章_采样和重建.assets/image-20210417145818687.png)

![image-20210417150015130](第七章_采样和重建.assets/image-20210417150015130.png)

实际上，生成数组样本只是计算**当前样本维度**中所需值的数量

![image-20210417150406078](第七章_采样和重建.assets/image-20210417150406078.png)

:star:采样数组进一步分析：采样数组的第一维（最左边）是额外的处理数，比如需要额外考虑4个面积光；第二维是每个额外考虑所需的采样值，其大小不是一致的，等同于：射线数 * 每射线采样数。

:five:当像素采样发生变化时，需要重置当前的**采样维度计数器**，并计算像素内下一个采样的采样索引。

![image-20210417152107154](第七章_采样和重建.assets/image-20210417152107154.png)

![image-20210417152144915](第七章_采样和重建.assets/image-20210417152144915.png)

考虑到这个机制，获取**常规的1D样本值**只是跳过分配给数组样本的维度，并将当前样本索引和维度传递给实现的`SampleDimension()`方法。

![image-20210417152246945](第七章_采样和重建.assets/image-20210417152246945.png)

目前疑惑：采样数组的采样值的获取问题，以及表示问题——对每个额外处理来说，每个射线的每次采样只存储了一个符点数？为什么不是一个浮点数向量，就像常规的采样那些。

## 3. stratified sampling