# 颜色和辐射度学

在本章中，我们将介绍`4`个描述**电磁辐射**的关键量：通量`flux`、强度`intensity`、辐照度`irradiance`和辐射度`radiance`。这些辐射量都由它们的==光谱功率分布==（`SPD`）描述：**波长的分布函数**，描述每个波长上的光量。

## 1. 光谱表示

现实世界对象的`spd`可能非常复杂；下图为**荧光灯发射**的光谱分布图和**柠檬皮反射率**的光谱分布图。使用`SPDs`进行计算的渲染器需要一种紧凑、高效和准确的方法来表示这样的函数。在实践中，需要在这些品质之间进行一些权衡。

<img src="第五章_颜色和辐射度学.assets/image-20210410141624795.png" alt="image-20210410141624795" style="zoom:67%;" />

研究这些问题的==一般框架==可以建立在寻找代表`spd`的良好**基函数**的问题上。**基函数背后的思想**是将可能无限维空间的**SPD函数**映射到系**数的低维空间**，$c_i\in R$。例如，一个普通的基函数就是常函数，$B(\lambda)=1$。任意的`SPD`在这个基中可以用一个等于其平均值的系数$c$来表示，因此它的近似值为：$cB(\lambda)=c$。

本章中，我们将介绍两种可以用于**pbrt**中光谱的表示方法。==RGBSpectrum==，它遵循了典型的计算机图形学的做法，用代表红、绿、蓝三色混合的系数来表示SPD；==SampledSpectrum==，它将SPD表示为**一组波长范围内的点样本**。

### 光谱类型

在整个==pbrt==中，我们一直小心翼翼地用**频谱类型**来实现所有涉及`SPD`的计算，使用一组特定的内置运算符（加法、乘法等）。**频谱类型**隐藏了所使用的**特定频谱表示**的细节，因此改变系统的这个细节只需要改变频谱的实现，其他代码可以保持不变。频谱类型的实现在文件`core/spectrum.h`和`core/spectrum.cpp`中。

在pbrt中，通过文件`core/pbrt.h`中的`typedef`来选择使用哪种频谱表示法，默认情况下，pbrt使用更有效但不太准确的`RGB表示法`

```c++
<<Global Forward Declarations>>= 
typedef RGBSpectrum Spectrum;
// typedef SampledSpectrum Spectrum;
```

我们在编写系统的时候，并没有考虑到在运行时选择使用哪种`Spectrum`实现；如果要切换到不同的表示方式，整个系统必须重新编译。这种设计的一个好处是，许多不同的Spectrum方法可以被编译器==内联==为短函数来实现，而不是作为独立的函数，必须通过相对缓慢的==虚拟方法调用机制==来调用。**内联这样经常使用的短函数可以给性能带来很大的提升**。第二个优点是，系统中持有**频谱类型实例**的结构可以直接持有它们，而不需要根据运行时选择的频谱表示方式**动态分配**它们。

### CoefficientSpectrum实现

本章实现的两种表示都基于**存储固定数量的SPD样本**。因此，我们将从定义==CoefficientSpectrum模板类==开始，它将一个光谱表示为**nSpectrumSamples模板参数**给出的特定数量的样本。`RGBSpectrum`和`SampledSpectrum`都是通过继承它实现的。

```c++
<<Spectrum Declarations>>= 
    template <int nSpectrumSamples> class CoefficientSpectrum {
    public:
        <<CoefficientSpectrum Public Methods>> 
        <<CoefficientSpectrum Public Data>> 
    protected:
        <<CoefficientSpectrum Protected Data>> 
    };
```

提供了一个构造函数：它初始化所有波长的频谱，并使其具有`constant`值。

```c++
<<CoefficientSpectrum Public Methods>>= 
    CoefficientSpectrum(Float v = 0.f) { 
        for (int i = 0; i < nSpectrumSamples; ++i)
            c[i] = v;
    }
<<CoefficientSpectrum Protected Data>>= 
	Float c[nSpectrumSamples];
```

需要对**频谱对象**进行各种各样的**算术运算**。首先，我们定义了添加**光谱分布对**的运算。

```c++
<<CoefficientSpectrum Public Methods>>+=  
    CoefficientSpectrum &operator+=(const CoefficientSpectrum &s2) {
        for (int i = 0; i < nSpectrumSamples; ++i)
            c[i] += s2.c[i];
        return *this;
    }
<<CoefficientSpectrum Public Methods>>+=  
    CoefficientSpectrum operator+(const CoefficientSpectrum &s2) const {
        CoefficientSpectrum ret = *this;
        for (int i = 0; i < nSpectrumSamples; ++i)
            ret.c[i] += s2.c[i];
        return ret;
    }
```

类似地，减法、乘法、除法和一元否定都按此方式定义。这些方法与已经展示的方法非常相似，所以我们在这里不包括它们。pbrt还提供了相等性和不相等性检验，这里也不包括。

知道**处处为零的SPD**通常是很有用的。例如，如果一个表面的反射率为零，光传输程序可以避免计算，因为反射光线的贡献最终会乘以零，因此不需要追踪。

```c++
<<CoefficientSpectrum Public Methods>>+=  
    bool IsBlack() const {
        for (int i = 0; i < nSpectrumSamples; ++i)
            if (c[i] != 0.) return false;
        return true;
    }
```

一些更高深的运算：

```c++
<<CoefficientSpectrum Public Methods>>+=  
    friend CoefficientSpectrum Sqrt(const CoefficientSpectrum &s) { 
        CoefficientSpectrum ret;
        for (int i = 0; i < nSpectrumSamples; ++i)
            ret.c[i] = std::sqrt(s.c[i]);
        return ret;
    }
```

在两个`spd`之间使用一个参数$t$进行线性插值是非常有用的。

```c++
<<Spectrum Inline Functions>>= 
inline Spectrum Lerp(Float t, const Spectrum &s1, const Spectrum &s2) {
    return (1 - t) * s1 + t * s2;
}
```

最后，我们提供了一个调试例程，用于检查SPD的样本值中是否有任何一个是`not-a-number`（`NaN浮点值`）。这种情况可能会因为意外的除以`0`而发生；整个系统中的`Assert()`使用这个方法来捕捉这种情况的发生地点。

```c++
<<CoefficientSpectrum Public Methods>>+=  
    bool HasNaNs() const {
        for (int i = 0; i < nSpectrumSamples; ++i)
            if (std::isnan(c[i])) return true;
        return false;
    }
```

提供了一个公共常量nSamples，它给出了用于表示SPD的样本数量，以及一个用于访问单个样本值的operator[]方法。

```c++
<<CoefficientSpectrum Public Data>>= 
	static const int nSamples = nSpectrumSamples;
<<CoefficientSpectrum Public Methods>>+= 
    Float &operator[](int i) {
        return c[i];
    }
```

这个**采样访问器**的存在意味着隐含的假设，即**频谱表示**是==一组线性缩放固定基函数的系数==。例如，如果一个频谱实现将`SPD`表示为**高斯和**，其中系数$c_i$交替缩放高斯并设置其宽度。

![image-20210410145047591](第五章_颜色和辐射度学.assets/image-20210410145047591.png)

## 2. SampledSpectrum类

`SampledSpectrum`表示在起始波长和结束波长之间==均匀间隔采样的SPD==。波长范围从`400 nm`到`700 nm`这是HSV最敏感的视觉光谱范围。样本的数量，==60==，通常足够准确地代表**复杂的SPDs渲染**。

```c++
<<Spectrum Utility Declarations>>= 
    static const int sampledLambdaStart = 400;
    static const int sampledLambdaEnd = 700;
    static const int nSpectralSamples = 60;
```

```c++
<<Spectrum Declarations>>+=  
    class SampledSpectrum : public CoefficientSpectrum<nSpectralSamples> {
    public:
        <<SampledSpectrum Public Methods>> 
    private:
        <<SampledSpectrum Private Data>> 
    };
```

```c++
<<SampledSpectrum Public Methods>>= 
	SampledSpectrum(Float v = 0.f) : CoefficientSpectrum(v) { }
```

我们经常得到一组$(\lambda_i,v_i)$集作为光谱数据。`FromSampled()`方法取==给定波长λ==下的**SPD样本值v**的数组，并用它们定义一个分段线性函数来表示`SPD`。对于`SampledSpectrum`中的每个SPD样本，使用下面定义的`AverageSpectrumSamples()`效用函数来计算分段线性函数在每个SPD样本所负责的波长范围内的平均值。

```c++
<SampledSpectrum Public Methods>>+=  
    static SampledSpectrum FromSampled(const Float *lambda,
                                       const Float *v, int n) {
        <<Sort samples if unordered, use sorted for returned spectrum>> 
        SampledSpectrum r;
        for (int i = 0; i < nSpectralSamples; ++i) {
            <<Compute average value of given SPD over th sample’s range>> 
        }
        return r;
    }
```

