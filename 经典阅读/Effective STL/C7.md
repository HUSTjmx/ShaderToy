[toc]





# 使用STL编程

# 1. 条款43：尽量用算法调用代替手写循环

:one:每个算法接受至少一对用来指示**将被操作的对象区间**的迭代器。比如，`min_element`可以找出此区间中的**最小值**，而`accumulate`则对区间内的元素作**某种形式的整体求和运算**（参见条款`37`），`partition`将区间内的元素**分割为满足和不满足某判决条件的两个部分**（参见条款`31`）。当算法被执行时，从区间的起始点，循环到结束点。有一些算法，比如`find `和`find_if`，可能在遍历完成前就返回了，但即使是这些算法，==内部都包含一个循环==。

对许多C++程序员而言，使用**循环**比调用算法的想法自然多了，并且读循环比**弄懂`mem_fun_ref`的意义**和取` Widget::redraw`的地址要舒服多了。但是，本条款将说明**调用算法更可取**。为什么？有三个理由：

- **效率**：算法通常比程序员产生的循环更高效。
- **正确性**：写循环时比调用算法更容易产生错误。
- **可维护性**：算法通常使代码比相应的显式循环更干净、更直观。



# 2. 条款44：尽量用成员函数代替同名的算法

:one:大多数情况下，你应该用**成员函数**代替**算法**。这样做有两个理由。首先，**成员函数更快**。其次，比起算法来，它们**与容器结合得更好**（尤其是**关联容器**）。那是因为**同名的算法和成员函数通常并不是一样的**。

:two:效率上，特别是关联容器，由于是用红黑树实现，所以效率特别高（相对于算法）。更加严重的是，以`find`为例，**find算法**搜索用的是==相等==，而**find成员函数**用的是==等价==，可能造成**搜索的区别**。因此，如果使用**关联容器**的话，你应该尽量使用**成员函数形式的find、count、lower_bound**等等，而不是同名的算法，因为这些**成员函数版本提供了和其它成员函数一致的行为**。由于相等和等价间的差别，**算法不能提供这样的一致行为**。

:three:当面临着**STL算法**和**同名的容器成员函数**间进行选择时，你应该==尽量使用成员函数==，几乎可以肯定它更高效，而且它看起来也和**容器的惯常行为**集成得更好。



# 3. 条款45：注意count、find、binary_search、lower_bound、upper_bound 和equal_range的区别

:one:要选择**搜索策略**，必须依赖于你的迭代器是否定义了一个**有序区间**。如果是，你就可以通过`binary_search`、 `lower_bound`、`upper_bound`和`equal_range`来加速——通常是**对数时间**。

如果迭代器并**没有划分一个有序区间**，你就只能用**线性时间的算法**`count`、`count_if`、`find`和`find_if`。

> 下文我们忽略掉`_if`

:two:从**无序区间**迁移到**有序区间**导致了另一个迁移：从使用相等来判断两个值是否相同，到**使用等价来判断**。

要测试在有序区间中**是否存在一个值**，使用`binary_search`，并不会返回位置。如果需要，则使用`equal_range`。

当你用`lower_bound`来寻找一个值的时候，它返回**一个迭代器**，这个迭代器指向**这个值的第一个拷贝**（如果找到的话）或者到可以插入这个值的位置（如果没找到）。

> 因此lower_bound回答这个问题：“它在吗？如果是，第一个拷贝在哪里？如果不是，它将在哪里？”

我们或许会这么写：

```c++
vector<Widget>::iterator i = lower_bound(vw.begin(), vw.end(), w); 
if (i != vw.end() && *i == w) {
	...
}
```

但上面不完全对，我们不应该使用相等测试，而应该是**等价测试**。不考虑其他复杂的方法，这儿有一个简单的方法：使用`equal_range`。`equal_range`返回**一对迭代器**，第一个等于`lower_bound`返回的迭代 器，第二个等于`upper_bound`返回的。因此， `equal_range`，返回了一对划分出了和你要搜索的值等价的区间的迭代器。

对于`equal_range`的返回值，有两个重要的地方。第一，如果**这两个迭代器相同**，就意味着对象的区间是空的；**这个值没有找到**。

第二个要注意的是`equal_range`返回的东西是两个迭代器，对它们作`distance`就等于**区间中对象的数目**。

```c++
VWIterPair p = equal_range(vw.begin(), vw.end(), w); 
cout << "There are " << distance(p.first, p.second)  << " elements in vw equivalent to w.";
```

:three:通常我们有一个容器，而不是一个区间。在这种情况下，我们**必须区别序列和关联容器**。对于**标准的序列容器**（vector、string、deque和list），你应该遵循我在本条款提出的建议，使用**容器的begin和end迭代器**来划分出区间。

这种情况对**标准关联容器**（set、multiset、map和multimap）来说是不同的，因为它们提供了**搜索的成员函数**，它们往往是比用STL算法**更好的选择**。

调用`binary_search`的策略不同，因为这个算法**没有提供对应的成员函数**。要测试在set或map中是否存在某个 值，使用`count`的惯用方法来对成员进行检测：

```c++
set<Widget> s;          // 建立set，放入数据 
... 
Widget w;               // w仍然是保存要搜索的值 
... 
if (s.count(w)) 
{
	...
}
```



# 4. 条款46：考虑使用函数对象代替函数作算法的参数

:one:一个关于用高级语言编程的抱怨是==抽象层次越高，产生的代码效率就越低==。但我们通常发现，传递一个STL对象，相对于我们传输函数，更加高效（例如，`sort`的第三个参数）。这是为什么呢？

答案是：==内联==。但我们传递函数时，实际上传递的是**函数指针**，所以不会内联，而且还会有一次调用开销。

==把函数指针作为参数会抑制内联==的事实解释了一个长期使用C的程序员经常发现却难以相信的现象：在速度 上，`C++`的`sort`实际上总是使C的qsort感到窘迫。

而让我们回顾**仿函数**，或者说，函数对象，我们完全可以将`operate()`设置为内联的。

:two:第二个理由是，有时候，甚至使用函数作为参数，会导致看似完全正确的无法编译。举一个例子，下列代码就无法编译：

```c++
//从cout打印出set中每个字符串的长度：(具体理由见书)
set<string> s; 
... 
transform(s.begin(), s.end(), ostream_iterator<string::size_type>(cout, "\n"),
```

一个变通方法是改用**函数对象**：

```c++
struct StringSize:        
public unary_function<string, string::size_type>
{       
// 参见条款40        
    string::size_type operator()(const string& s) const       
    {                
        return s.size();        
    } 
};

transform(s.begin(), s.end(), ostream_iterator<string::size_type>(cout, "\n"), StringSize());
```



# 5. 条款47：避免产生只写代码

//todo
