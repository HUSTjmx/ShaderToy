[toc]





# 使用STL编程

# 1. 条款43：尽量用算法调用代替手写循环

:one:每个算法接受至少一对用来指示**将被操作的对象区间**的迭代器。比如，`min_element`可以找出此区间中的**最小值**，而`accumulate`则对区间内的元素作**某种形式的整体求和运算**（参见条款`37`），`partition`将区间内的元素**分割为满足和不满足某判决条件的两个部分**（参见条款`31`）。当算法被执行时，从区间的起始点，循环到结束点。有一些算法，比如`find `和`find_if`，可能在遍历完成前就返回了，但即使是这些算法，==内部都包含一个循环==。

对许多C++程序员而言，使用**循环**比调用算法的想法自然多了，并且读循环比**弄懂`mem_fun_ref`的意义**和取` Widget::redraw`的地址要舒服多了。但是，本条款将说明**调用算法更可取**。为什么？有三个理由：

- **效率**：算法通常比程序员产生的循环更高效。
- **正确性**：写循环时比调用算法更容易产生错误。
- **可维护性**：算法通常使代码比相应的显式循环更干净、更直观。



# 2. 条款44：尽量用成员函数代替同名的算法

:one:大多数情况下，你应该用**成员函数**代替**算法**。这样做有两个理由。首先，**成员函数更快**。其次，比起算法来，它们**与容器结合得更好**（尤其是**关联容器**）。那是因为**同名的算法和成员函数通常并不是一样的**。

:two:效率上，特别是关联容器，由于是用红黑树实现，所以效率特别高（相对于算法）。更加严重的是，以`find`为例，**find算法**搜索用的是==相等==，而**find成员函数**用的是==等价==，可能造成**搜索的区别**。因此，如果使用**关联容器**的话，你应该尽量使用**成员函数形式的find、count、lower_bound**等等，而不是同名的算法，因为这些**成员函数版本提供了和其它成员函数一致的行为**。由于相等和等价间的差别，**算法不能提供这样的一致行为**。

:three:当面临着**STL算法**和**同名的容器成员函数**间进行选择时，你应该==尽量使用成员函数==，几乎可以肯定它更高效，而且它看起来也和**容器的惯常行为**集成得更好。



# 3. 条款45：注意count、find、binary_search、lower_bound、upper_bound 和equal_range的区别

:one:
