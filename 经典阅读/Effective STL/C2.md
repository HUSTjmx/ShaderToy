[toc]



# Vector和String



# 1. 条款13：尽量使用vector和string来代替动态分配的数组

:one:就是表面意思。





# 2. 条款14：使用reserve来避免不必要的重新分配

:one:对于`vector`和`string`，只要需要更多空 间，就以`realloc`等价的思想来增长。这个类似于`realloc`的操作有四个部分：

1. 分配**新的内存块**，它有容器目前容量的**几倍**。在大部分实现中，`vector`和`string`的容量每次以`2`为因数增长。
2. 把所有元素从**容器的旧内存**拷贝到它的**新内存**。 
3. 销毁**旧内存中的对象**。 
4. 回收旧内存。

每次这些步骤发生时，所有指向`vector`或`string`中的**迭代器、指针和引用都会失效**。`reserve`成员函数允许你最小化**必须进行的、重新分配的次数**。在解释`reserve`为什么可以那么做之前，简要介绍有时候**令人困惑的四个相关成员函数**。在标准容器中，只有`vector`和`string`提供了所有这些函数：

- `size()`告诉你容器中**有多少元素**。它没有告诉你：容器为它容纳的元素分配了多少内存。 
- `capacity()`告诉你容器在它已经分配的内存中**可以容纳多少元素**——**总共可以容纳多少元素**，而不是还可以容纳多少元素。如果你想知道一个`vector`或`string`中**有多少没有被占用的内存**，你必须从`capacity()`中减去`size()`。
-  `resize(Container::size_type n)`强制把容器改为容纳`n`个元素。调用`resize`之后，`size`将会返回`n`。
- `reserve(Container::size_type n)`强制容器把它的容量改为至少`n`，提供的`n`**不小于当前大小**。这一般强迫进行**一次重新分配**，因为容量需要增加。如果`n`小于当前容量，`vector`忽略它，这个调用什么都不做。

**避免重新分配的关键**是使用`reserve`尽快把**容器的容量**设置为足够大，最好在容器被构造之后立刻进行。

:two:假定你想建立一个容纳`1-1000`值的`vector<int>`。没有使用`reserve`：

```c++
vector<int> v; 
for (int i = 1; i <= 1000; ++i) 
	v.push_back(i);
```

在大多数**STL实现**中，这段代码在循环过程中将会导致`2`到`10`次重新分配。把代码改为使用`reserve`，我们得到这个：

```c++
vector<int> v; 
v.reserve(1000); 
for (int i = 1; i <= 1000; ++i) 
	v.push_back(i);
```

通常有两个情况使用`reserve`来避免**不必要的重新分配**。第一个可用的情况是当你确切或者大约知道**有多少元素**将最后出现在容器中。那样的话，就像上面的`vector`代码，你只是提前`reserve`适当数量的空间。第二种情况是**保留你可能需要的最大的空间**，然后，一旦你添加完全部数据，修整掉任何多余的容量。



# 3. 条款15：小心string实现的多样性

:one:一个`string`对象的大小是多少？换句话说，`sizeof(string)`返回什么值？`string`和`char*`指针一样大的实现很常见，也很容易找到 `string`是`char*`7倍大小的`string`实现。为什么会有差别？实际上每个`string`实现都容纳了下面的信息：

- 字符串的大小，也就是它**包含的字符的数目**。
- 容纳字符串字符的**内存容量**。
- 这个字符串的值。

另外，一个`string`可能容纳：

- 它的配置器的拷贝。

**依赖引用计数的string实现**也包含了：

- **这个值的引用计数**。

:two:在实现`A`中，每个**string对象**包含一个它配置器的拷贝，字符串的大小，它的容量，和一个指向包含引用计数（`RefCnt`）和字符串值的**动态分配的缓冲区的指针**。在这实现中，一个使用默认配置器的字符串对象是**指针大小的四倍**。

![image-20210827153300790](C2.assets/image-20210827153300790.png)

:three:实现`B`的**string对象和指针一样大**，因为在结构体中只包含一个指针。再次，这里假设**使用默认配置器**。正如实现A，如果使用**自定义配置器**，这个` string`对象的大小会**增加大约配置器对象的大小**。

![image-20210827153423090](C2.assets/image-20210827153423090.png)

:four:**实现C的string对象**总是等于指针的大小，但是这个指针指向**一个包含所有与string相关的东西的动态分配缓冲器**：它的大小、容量、引用计数和值。缓冲区也容纳一些关于**值可共享性的数据**，我们在这里不考虑这个主题，所以我标记为`X`。

![image-20210827153555609](C2.assets/image-20210827153555609.png)

:five:**实现D的string对象**是一个**指针大小的七倍**（仍然假设**使用了默认配置器**）。这个实现**没有使用引用计数**，但每个`string`包含了一个**足以表现最多15个字符的字符串值的内部缓冲区**。因此小的字符串可以被整个保存在string对象中。当一个`string`的容量超过`15`时，缓冲器的第一部分被用作**指向动态分配内存的一个指针**，而字符串的值存放在那块内存中：

![image-20210827155517676](C2.assets/image-20210827155517676.png)

:six:考虑如下代码：

```c++
string s("Perse");
```

在实现`D`下将会没有动态分配，在实现`A`和`C`下一次，而在实现`B`下两次（一次是string对象指向的对象，一次是**那个对象指向的字符缓冲区**）。

更多分析见书。这里进行总结：

- 字符串值可能是或可能不是**引用计数的**。默认情况下，很多实现的确是用了引用计数，但它们通常提供了关闭的方法，一般是通过预处理器宏。
- string对象的大小可能从`1`到至少`7`倍`char*`指针的大小。
- 新字符串值的建立可能需要`0`、`1`或`2`次**动态分配**。 
- string对象可能是或可能不共享**字符串的大小和容量信息**。 
- string可能是或可能不支持每对象配置器。 
- 不同实现对于最小化字符缓冲区的配置器有不同策略。



# 4. 条款16：如何将vector和string的数据传给遗留的API

:one:已经存在的**遗留的C风格API**接受的是**数组和`char*`指针**，而不是 `vector`和`string`对象。这样的API函数还将会存在很长时间，如果我们要有效使用`STL`的话，就必须和它们和平共处。 

幸运的是，这很容易。如果你有一个`vector`对象`v`，而你需要得到一个指向`v`中数据的指针，以使得它可以**被当作一个数组**，只要使用`&v[0]`就可以了。对于`string`对象`s`，相应的咒语是简单的`s.c_str()`。

```c++
void doSomething(const int* pInts, size_t numInts);
//我们可以这样做
doSomething(&v[0], v.size());
```

唯一的问题就是，如果`v`是空的。如果这样的话，`v.size()`是`0`，而`&v[0]`试图产生一个指向根本就不存在的东西的指针。其结果未定义。一个较安全的方法是这样：

```c++
if (!v.empty()) {
	doSomething(&v[0], v.size());
}
```

> 当你需要一个指向`vector`内部数据的指针时绝不该使用`begin`。如果你基于某些原因决定键入`v. begin()`，就应该键入`&*v.begin()`

:two:对于`string`和`const char*`，可以直接使用`c_str()`。

//具体见书



# 5. 条款17：使用“交换技巧”来修改过剩容量

:one:如果你的`vector`有时候容纳了`10`万个的可能的候选人，它的容量会继续保持在至少`100000`，即使后来它只容纳`10`个。

需要有一种方法来把它从**曾经最大的容量**减少到它**现在需要的容量**。这样减少容量的方法常常被称为**收缩到合适**（`shrink to fit`）。

方法很简单：

```c++
vector<Contestant>(contestants).swap(contestants);
```

> 表达式`vector<Contestant>(contestants)`建立一个**临时vector**，它是**contestants的一份拷贝**：vector的拷贝构造函数做了这个工作。但是，**vector的拷贝构造函数只分配拷贝的元素需要的内存** ，所以这个**临时vector没有多余的容量**。然后我们让**临时vector**和`contestants`交换数据，这时我们完成了，contestants只有临时变量的修整过的容量，而这个临时变量则持有了曾经在contestants中的发胀的容量。在这里（这个语句结尾），**临时vector被销毁**，因此释放了以前contestants使用的内存。

同样的技巧可以应用于`string`：

```c++
string s; 
...                             // 使s变大，然后删除所有它的字符 
string(s).swap(s);
```

并不是真的意味着“**使容量尽可能小**”，它意味着“使**容量和这个实现**可以尽量给容器的当前大小一样小”。但是，只要没有切换**不同的STL实现**，这是你能做的最好的方法。

:two:==交换技巧的变体==可以用于清除容器，和减少它的容量到**你的实现提供的最小值**。你可以简单地和一个默认构造的临时vector或string做个交换：

```c++
vector<Contestant> v; 
string s; 
...                                     // 使用v和s 
vector<Contestant>().swap(v);           // 清除v而且最小化它的容量 
string().swap(s);                       // 清除s而且最小化它的容量
```



# 6. 条款18：避免使用`vector<bool>`

:one:做为一个STL容器，`vector<bool>`有两个问题：

- 第一，它不是一个STL容器。
- 第二，它并不容纳`bool`。 

一个东西要成为**STL容器**就必须满足所有在**C++标准**列出的**容器必要条件**。在这些要求中有这样一条：如果`c`是一个`T`类型对象的容器，且`c`支持`operator[]`， 那么以下代码必须能够编译：

```c++
T *p = &c[0];    
```

但如下代码不能编译，因为`vector<bool>`是一个**伪容器**，并不保存真正的`bool`，而是打包`bool`以**节省空间**。在一个典型的实现中，每个保存在`vector`中的`bool`占用一个单独的比特，而一个**8比特的字节**将容纳`8 `个`bool`。在内部，`vector<bool>`使用了与**位域（bitfield）**等价的思想，来表示它假装容纳的`bool`。

```c++
vector<bool> v; 
bool *pb = &v[0]; 
```

但真的`bool`和**化装成bool的位域**之间有一个重要的不同：你可以创建指向真的bool的指针，但却**禁止有指向单个比特的指针**。

**引用单个比特也是禁止的**，这为`vector<bool>`接口的设计摆出了难题。因为`vector<T>::operator[]`的返回值应该是`T&`。如果`vector<bool>`真正容纳bool，这不成问题，但因为它没有，`vector<bool>::operator[]`需要返回**指向一个比特的引用**，而并不存在这样的东西。

为了解决这个难题，`vector<boo>::operator[]`返回一个对象，其行为类似于比特的引用，也称为==代理对象== 。 深入本质来看，`vector<bool>`看起来像这样：

```c++
template <typename Allocator> 
vector<bool, Allocator> 
{ 
public:        
    class reference {...};                  // 用于产生引用独立比特的代理类        
    reference operator[](size_type n);      // operator[]返回一个代理        
    ... 
}
```

现在，这段代码不能编译的原因就很明显了：

```c++
vector<bool> v; 
bool *pb = &v[0];      // 错误！右边的表达式是vector<bool>::reference*类型, 不是bool*
```

> 当你会写出一个模板，它只在取容器元素的地址时会产生一个**指向包含类型的指针**时才能工作，到那时，你将突然明白容器和**几乎是容器**之间的区别。

:two:标准库提供了**两个替代品**，它们能满足几乎所有需要。第一个是`deque<bool>`。deque提供了几乎所有vector所提供的（唯一值得注意的是`reserve`和`capacity`），而`deque<bool>`是一个STL容器，它保存真正的bool值。当然，deque内部**内存不是连续的**。所以不能传递`deque<bool>`中的数据给一个**希望得到bool数组的C API**。

第二个`vector<bool>`的替代品是`bitset`。`bitset`不是一个STL容器，但它是C++标准库的一部分。与STL容器不同，**它的大小（元素数量）在编译期固定**，因此它**不支持插入和删除元素**。此外，因为它不是一个STL容器，它也**不支持iterator**。但就像`vector<bool>`，它使用一个**压缩的表示法**，使得它包含的每个值只占用一比特。它提供`vector<bool>`特有的`flip`成员函数，还有一系列其他**操作位集（collection of bits）所特有的成员函数**。如果不在乎没有迭代器和动态改变大小，你也许会发现`bitset`正合你意。



