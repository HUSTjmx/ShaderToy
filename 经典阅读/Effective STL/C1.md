# 1. 条款1：仔细选择你的容器

:one:C++中有很多你可以支配的容器，但是你意识到有多少吗？

- 标准STL**序列容器**：vector、string、deque和list。
- 标准STL**关联容器**：set、multiset、map和multimap。
- **非标准序列容器** slist和rope。`slist`是一个**单向链表**，`rope`本质上是一个**重型字符串**。
- 非标准关联容器hash_set、hash_multiset、hash_map和hash_multimap。

> `vector`是一种可以默认使用的序列类型，当很频繁地**对序列中部进行插入和删除**时应该用`list`，当大部分**插入和删除发生在序列的头或尾时**可以选择`deque`这种数据结构。

:two:首先我需要介绍一种**STL容器的分类方法**，它被讨论的次数并不多——**连续内存容器和基于节点的容器的区别**。

- **连续内存容器**（也叫做==基于数组的容器==）在一个或多个**动态分配的内存块**中保存它们的元素。如果插入或者删除，**在同一个内存块的元素**就必须向上或者向下移动，来为新元素提供空间或者填充原来被删除的元素。标准的连续内存容器是`vector`、`string`和`deque`。非标准的`rope`也是连续内存容器。
- **基于节点的容器**在每个内存块中**只保存一个元素**。容器元素的插入或删除只影响**指向节点的指针**，而不是节点自己的内容。所以当有东西插入或删除时，元素值不需要移动。`list`和`slist`是基于节点的，所有的**标准关联容器**也是（它们的典型实现是==平衡树==）。

> **非标准的散列容器**使用不同的基于节点的实现，

:three:在容器间选择的==主要策略==：

- 在容器的任意位置插入一个新元素？需要**序列容器**，关联容器做不到。
- 关心元素在容器中的**顺序**吗？如果不，**散列容器**就是可行的选择。
- 你需要哪一类迭代器 ？如果必须是**随机访问迭代器**，在技术上你就只能限于`vector`、`deque`和`string`
- 当插入或者删除数据时，是否非常在意容器内**现有元素的移动**？ 如果是，你就必须放弃**连续内存容器**。
-  容器中的数据的**内存布局兼容C**吗？ 如果是，你就只能用`vector`。
- 查找速度：散列容器 > 排序的`vector` > 标准的关联容器
- 如果不希望**底层实现**使用了**引用计数**，则不能使用`string`和`rope`——替代品是`vector<char>`。
- 如果需要有**可靠地回退插入和删除的能力**，使用基于节点的容器。
- 要把迭代器、指针和引用的**失效次数减到最少**吗？ 如果是，你就应该使用**基于节点的容器**，因为在这些容器上**进行插入和删除不会使迭代器、指针和引用失效**。
- 可以使用随机访问迭代器，而且插入发生在容器结尾时，指针和引用不会失效，最佳选择是`deque`。



# 2. 条款2：小心对“容器无关代码”的幻想

> `STL`是建立在泛化之上的。**数组泛化为容器**，参数化了所包含的对象的类型。**函数泛化为算法**，参数化了所用的迭代器的类型。**指针泛化为迭代器**，参数化了所指向的对象的类型。

:one:**独立的容器类型泛化为序列或关联容器**，而且类似的容器拥有类似的功能。标准的内存相邻容器都提供**随机访问迭代器**，标准的基于节点的容器都提供**双向迭代器**。

具体见书。



# 3. 条款3：是容器里对象的拷贝操作轻量而正确

:one:当你向容器中添加一个对象，进入容器的是**对象的拷贝** 。拷进去，拷出来，这就是STL的方式。

> 现在应该是移动了

如果你用一个拷贝过程很昂贵的对象填充一个容器，那么一个简单的操作——把对象放进容器也会是一个**性能瓶颈**。

:two:由于继承的存在，**拷贝会导致分割**。那就是说，如果你以基类对象建立一个容器，而你试图插入派生类对象，那么当对象拷入容器的时候，对象的派生部分会被删除。

所以还是**传入指针**（最好是智能指针），来避免分割，而且还快。



# 4. 条款4：用`empty`来代替检查`size()`是否为`0`

:one:`empty`的**典型实现**是一个返回**size是否返回0**的==内联函数==。

你应该首选`empty`，而且理由很简单：对于所有的标准容器，`empty`是一个**常数时间的操作**，但对于一 些`list`实现，`size`花费**线性时间**。

什么造成`list`这么麻烦？为什么不能也提供一个常数时间的`size`？答案是对于`list`特有的`splice`有很多要处理的东西。考虑这段代码：

```c++
list<int> list1; 
list<int> list2; 
... 
list1.splice(                                   // 把list2中        
    list1.end(), list2,                     // 从第一次出现5到        
    find(list2.begin(), list2.end(), 5),            // 最后一次出现10    
    find(list2.rbegin(), list2.rend(), 10).base()   // 的所有节点移到list1的结尾。 
);                                              

```

具体分析见书。



# 5. 条款5：尽量使用区间成员函数代替它们的单元素兄弟

:one:给定两个`vector`，`v1`和`v2`，使`v1`的内容和`v2`的**后半部分**一样的**最简单方式**是什么？

```c++
v1.assign(v2.begin() + v2.size() / 2, v2.end()); 
```

这个测验设计为做两件事。

- 第一，它来提醒你`assign`成员函数的存在，太多的程序员没注意到这是一个很方便的方法。它对于**所有标准序列容器**（vector，string，deque和list）都有效。
- 演示为什么**区间成员函数**优先于它们的**单元素替代品**。 

````