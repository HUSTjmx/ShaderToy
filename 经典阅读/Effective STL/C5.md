[toc]



# 算法



# 1. 条款30：确保目标空间足够大

:one:当程序员想向容器中**插入对象**，但并没有告诉`STL`他们所想的时，问题出现了。这是一个常见的方法：

```c++
int transmogrify(int x); // 这个函数从x
						 // 产生一些新值
vector<int> values;
... 					 // 把数据放入values
vector<int> results; 	 
transform(values.begin(), values.end(), results.end(), transmogrify); 
 // 这段代码有bug
```

`transform`通过对**目标区间的元素**写入结果，`transform`会把`transmogrify`应用于`values[0]`，并把结果赋给``*results.end()``。然后它会把`transmogrify`应用于 `value[1]`，并把结果赋给``*(results.end()+1)``。那只能带来灾难，因为在``*results.end()``没有对象，``*(results.end()+1)``也没有。

正确方法是调用`back_inserter`来产生**指定目标区间起点的迭代器**：

```c++
vector<int> results; 						 // 把transmogrify应用于
transform(values.begin(), values.end(), 		// values中的每个对象，
 		 back_inserter(results),			 // 在results的结尾
 		 transmogrify); 				   // 插入返回的values
```

在内部，`back_inserter`返回的迭代器会调用`push_back`，所以你可以在任何提供`push_back`的容器上使用 `back_inserter`（也就是任何**标准序列容器**：`vector`、`string`、`deque`和`list`）。

如果你想让一个算法在**容器的前端**插入东西，你可以使用`front_inserter`。在内部，`front_inserter`利用了`push_front`，所以`front_insert`只和提供那个成员函数的容器配合（也就是`deque`和`list`）：

```c++
... 								// 同上
list<int> results; 					  // results现在是list
transform(values.begin(), values.end(),  // 在results前端
 		  front_inserter(results), 	  // 以反序
		  transmogrify); 			// 插入transform的结果
```

> 因为`front_inserter`用`push_front`把每个对象添加到`results`，`results`中的对象顺序会和`values`中对应的对象顺序**相反**。

:two:有点惊人的是`inserter`允许你强制算法把**它们的结果**插入容器中的**任意位置**：（通过条款`15`预设大小来减少内存分配的消耗）

```c++
vector<int> values; 	// 同上
...
vector<int> results; 	// 同上，除了现在
... 				 // 在调用transform前
 					// results已经有一些数据
results.reserve(results.size() + values.size()); 
transform(values.begin(), values.end(), 						// 把transmogrify的
 			inserter(results, results.begin() + results.size()/2), // 结果插入
 			transmogrify); 									// results的中间
```

:three:本条款论证了这个主题的很多变化，但我希望你能牢牢记住**本质**。无论何时你使用一个**要求指定目的区间的算法**，确保**目的区间已经足够大**，或者在算法执行时**可以增加大小**。如果你选择**增加大小**，就使用**插入迭代器**，比如`ostream_iterators`或从`back_inserter`、`front_inserter`或`inserter`返回的迭代器。

如果**足够大**，必须确保使用的内存区域是**已经初始化好的对象**，而不是**原始内存区域**。

```c++
transform(values.begin(), values.end(), results.end(), transmogrify);    //error
transform(values.begin(), values.end(), results.begin(), transmogrify);  //right
```



# 2. 条款31：了解你的排序选择

:one:当很多程序员想到**排序对象**时，只有一个算法出现在脑海：`sort`。

有时候你不需要**完全排序**。比如，如果你有一个`Widget`的`vector`，你想选择`20`个质量最高的`Widget`发送给客户，排序以鉴别出`20`个最好的`Widget`，剩下的可以**保持无序**。你需要的是**部分排序**，有一个算法叫做`partial_sort`：

```c++
bool qualityCompare(const Widget& lhs, const Widget& rhs)
{
 	// 返回lhs的质量是不是比rhs的质量好
}
...
partial_sort(widgets.begin(), 		 // 把最好的20个元素
 			widgets.begin() + 20,  // （按顺序）放在widgets的前端
 			widgets.end(),
 			qualityCompare);
```

如果只是能把`20`个最好的`Widget`给`20`个最好的客户，但你不关心哪个`Widget`给哪个客户， `partial_sort`就给了你多于需要的东西。在那种情况下，你需要的只是**任意顺序的、20个最好的Widget**。`STL`有一个算法精确的完成了你需要的，它叫做`nth_element`：

```c++
nth_element(widgets.begin(), // 把最好的20个元素
 			widgets.begin() + 19, // 放在widgets前端，
			 widgets.end(), // 但不用担心
			 qualityCompare); // 它们的顺序
```

:two:那引出一个重要的问题。当有**元素有同样质量**的时候这些算法怎么办？比如假设有`12`个元素质量是`1`级，`15`个元素质量是`2`级。当多个元素有等价的值时，`sort`怎么判断**元素的顺序**？

`partial_sort`和`nth_element`以任何它们喜欢的方式排序**值等价的元素**，而且你**不能控制**它们在这方面行为。

> 对于**完整的排序**，你有稍微多一些的控制权。有些排序算法是==稳定的==。在稳定排序中，如果一个区间中的两个元素有**等价的值**，它们的相对位置**在排序后不改变**。因此，如果在（未排序的）`widgets vector`中`Widget A`在 `Widget B`之前，而且两者都有**相同的质量等级**，那么稳定排序算法会保证在这个vector排序后，`Widget A`仍然在`Widget B`之前。**不稳定的算法没做这个保证**。
>

`partial_sort`是不稳定的。`nth_element`、`sort`**也没有提供稳定性**。如果当你排序的时候需要**稳定性**，你可能要使用`stable_sort`。`STL`并不包含`partial_sort`和 `nth_element`的稳定版本。

:three:现在谈谈`nth_element`，这个名字奇怪的算法是个**引人注目的多面手**。除了能帮你找到区间顶部的`n`个元素， 它也可以用于找到**区间的中值**，或者找到**指定百分点的元素**：

```c++
vector<Widget>::iterator begin(widgets.begin()); 	 // 方便地表示widgets的
vector<Widget>::iterator end(widgets.end()); 		// 起点和终点迭代器的变量
vector<Widget>::iterator goalPosition;
goalPosition = begin + widgets.size() / 2;

nth_element(begin, goalPosition, end,  // 找到widgets中中等
 			qualityCompare); 		// 质量等级的值
```

:four:假设，你不需要鉴别出`20`个质量最高的`Widget`。取而代之的是，你需要鉴别出所有**质量等级**为`1`或`2` 的。当然你可以按照质量排序这个`vector`，然后搜索第一个质量等级比`2`差的。一个**更好的策略**是使用`partition`算 法，它重排区间中的元素，以使**所有满足某个标准的元素**都在**区间的开头**。

```c++
bool hasAcceptableQuality(const Widget& w)
{
	 // 返回w质量等级是否是2或更高;
}
// 把所有满足hasAcceptableQuality的widgets移动到widgets前端，
vector<Widget>::iterator goodEnd = partition(widgets.begin(), 
                              widgets.end(), 		 // 并且返回一个指向第一个
									 hasAcceptableQuality);  // 不满足的widget的迭代器
```

此调用完成后，从``widgets.begin()``到`goodEnd`的区间容纳了所有质量是`1`或`2`的`Widget`，从`goodEnd`到`widgets.end ()`的区间包含了所有**质量等级更低的Widget**。如果在分割时保持同样质量等级的`Widget`的**相对位置**很重要， 我们自然会用`stable_partition`来代替`partition`。

:five:算法`sort`、`stable_sort`、`partial_sort`和`nth_element`需要**随机访问迭代器**，所以它们可能只能用于`vector`、`string`、 `deque`和数组。对**标准关联容器**排序元素没有意义，因为这样的容器使用**它们的比较函数**来保持有序。唯一我们可能会但不能使用sort、stable_sort、partial_sort或nth_element的容器是`list`，`list`通过提供`sort`**成员函数**做了一些补偿。（有趣的是，`list::sort`提供了==稳定排序==。）

`partition`和`stable_partition`不同，它们只需要**双向迭代器**。因此你可以在**任何标准序列迭代器**上使用`partition`和`stable_partition`

![image-20210906114518983](C5.assets/image-20210906114518983.png)

:six:在本条款讨论的算法排序如下，**需要更少资源（时间和空间）的算法**列在前面：

![image-20210906114553069](C5.assets/image-20210906114553069.png)



# 3. 条款32：如果你真的想删除东西的话，就在类似remove的算法后接上erase

:one:我将从`remove`的复习开始这个条款，因为`remove`是`STL`中==最糊涂的算法==。这是`remove`的声明：

```c++
template<class ForwardIterator, class T>
ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T& value);
```

就像所有算法，`remove`接收指定它操作的**元素区间的一对迭代器**。它不接收一个容器，所以`remove`不知道它作用于哪个容器。此外，`remove`也不可能发现容器，因为**没有办法从一个迭代器获取对应于它的容器**。

想想怎么从容器中除去一个元素。==唯一的方法==是调用那个容器的一个**成员函数**，几乎都是`erase`的某个形式。而因为`remove`无法知道它**正在操作的容器**，所以`remove`不可能从一 个容器中除去元素。这解释了**另一个令人沮丧的观点**——从一个容器中`remove`元素**不会改变容器中元素的个数**。

```c++
vector<int> v; // 建立一个vector<int> 用1-10填充它
v.reserve(10); // （调用reserve的解释在条款14）
for (int i = 1; i <= 10; ++i) {
    v.push_back(i);
}

cout << v.size(); 			    // 打印10
v[3] = v[5] = v[9] = 99; 		  // 设置3个元素为99
remove(v.begin(), v.end(), 99);   // 删除所有等于99的元素
cout << v.size(); 				// 仍然是10
```

==remove并不“真的”删除东西，因为它做不到。==

:two:我们现在需要复习的是`remove`做了什么。非常简要地说一下，`remove`移动指定区间中的元素，直到**所有“不删除的”元素**在区间的开头。**返回值**是区间的**“新逻辑 终点”**。

举个例子：

![image-20210906115454066](C5.assets/image-20210906115454066.png)

```c++
vector<int>::iterator newEnd(remove(v.begin(), v.end(), 99));
```

这是调用后`v`看起来的样子：

![image-20210906115530635](C5.assets/image-20210906115530635.png)

> 这里我用**问号**来标明那些在**概念上已经从v中被删除，但继续存在的元素**的值。

`remove`并没有改变区间中**元素的顺序**，所以不会把**所有“删除的”元素**放在结尾，并安排所有**“不删除的”值**在开头。虽然标准没有要求，但一般来说区间中在**新逻辑终点**以后的元素仍**保持它们的原值**。调用完`remove`后，在我知道的所有实现中，`v `看起来像这样：

![image-20210906115745929](C5.assets/image-20210906115745929.png)

> 如果你不想失去任何值，你可能应该调用`partition`或`stable_partition`，而不是`remove`， `partition`在条款`31`中描述。

在内部，`remove`遍历这个区间，把要**“删除的”值**覆盖为**后面要保留的值**。你可以想象`remove`完成了**一种压缩**，被删除的值表演了在压缩中**被填充的洞的角色**。

:three:只有**容器成员函数**可以除去容器元素，而那是本条款的整个要点：如果你真的要删除东西的话，你应该在`remove`后面接上`erase`。这个调用很直截了当：

```c++
vector<int> v; // 正如从前
v.erase(remove(v.begin(), v.end(), 99), v.end()); // 真的删除所有等于99的元素
cout << v.size(); // 现在返回7
```

把`remove`的返回值作为`erase`区间形式**第一个实参**传递很常见，这是个惯用法。事实上，`remove`和`erase`是亲密联盟，这两个整合到`list`成员函数`remove`中。这是`STL`中唯一名叫`remove`又能从容器中除去元素的函数：

```c++
list<int> li; // 建立一个list,放一些值进去
li.remove(99);
```



# 4. 条款33：提放在指针的容器上使用类似remove的算法