# 1. 条款41：了解隐式接口和编译器多态

:one:`Template`以及泛型世界，与**面向对象**有根本上的不同，虽然**显式接口**和**运行期多态**依然存在，但重要性降低，反倒是**隐式接口和编译期多态**更为重要。

:two:显式接口由函数的签名式构成。**隐式接口并不基于函数签名式，而是由有效表达式组成**。

![image-20210608092202693](7.模板与泛型编程.assets\image-20210608092202693.png)



# 2. 条款42：了解typename的双重意义

:one:

![image-20210608092542520](7.模板与泛型编程.assets\image-20210608092542520.png)

任何时候想要在`template`中指涉一个**嵌套从属类型名称**，就必须在紧邻它的前一个位置放上关键词`typename`。而其他地方不该有它的存在：

![image-20210608092930165](7.模板与泛型编程.assets\image-20210608092930165.png)

:two:上诉规则的例外是：`typename`不可以出现在`base  classes list`内的嵌套从属类型名称之前，也不可以在成员初值列中作为base class修饰符：

![image-20210608093151836](7.模板与泛型编程.assets\image-20210608093151836-1623115916517.png)



# 3. 条款43：学习处理模板化基类内的名称

:one:当我们​在模板类上应用继承会导致一个问题：**派生类无法知道基类的成员函数**，因为无法知道其模板基类的细节。为什么不知道呢？因为模板类可能会特化，从而具有完全不同的特点（成员函数可能都不存在了）。

> 之前学的时候也说了，模板类实际上并不是类，在具现化时才会生成特定的类。

:two:有三个解决办法：

- 第一个是在基类函数调用动作之前加上`this->`：

  ![image-20210608094401418](7.模板与泛型编程.assets\image-20210608094401418.png)

- 第二是使用`using`声明式：

  ![image-20210608094454330](7.模板与泛型编程.assets\image-20210608094454330.png)

- 明确指出被调用的函数位于基类内：

  ![image-20210608094536073](7.模板与泛型编程.assets\image-20210608094536073.png)

但这个方法最不好，因为如果调用的是虚函数，上诉明确资格修饰会关闭虚绑定行为。

![image-20210608094708236](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\经典阅读\Effective C++\7.模板与泛型编程.assets\image-20210608094708236.png)



# 4. 条款44：将参数无关的代码抽离`template`

![image-20210610093959535](7.模板与泛型编程.assets\image-20210610093959535-1623289201160.png)



# 5. 条款45：运用成员函数模板接受所有兼容类型

:one:指针做得很好的一件事是：支持隐式转换。派生类指针可以转换为基类指针，指向`non-const`的指针可以指向`const`对象。但是在用户自定的智能指针中模拟上诉转换，稍稍有点麻烦，我们希望以下代码通过编译。

![image-20210610094547699](7.模板与泛型编程.assets\image-20210610094547699.png)

![image-20210610094609288](7.模板与泛型编程.assets\image-20210610094609288.png)

:two:

![image-20210610094748471](7.模板与泛型编程.assets\image-20210610094748471.png)

但我们不希望不存在**隐式转换**（总之，不可能啥都可以，例如`int*`不能转换成`double*`），可以使用**成员初值列**来初始化，来达到目的：只在其**所获得的实参**隶属**适当兼容类型**时才通过编译。

![image-20210610095151903](7.模板与泛型编程.assets\image-20210610095151903.png)



# 6. 条款46：需要类型转换时请为模板定义非成员函数

//todo



# 7. 条款47：请使用traits classes表现类型信息

![image-20210611092441766](7.模板与泛型编程.assets\image-20210611092441766.png)

//todo



# 8. 条款48：认识模板元编程

![image-20210611092857411](7.模板与泛型编程.assets\image-20210611092857411.png)

找本书好好了解TMP。https://github.com/wuye9036/CppTemplateTutorial#6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A8%81%E5%8A%9B%E4%BB%8Eforeach-transform%E5%88%B0linq





> 这部书的阅读暂时告一段落，后续残余内容有机会再补，毕竟这本书实在太老了。

