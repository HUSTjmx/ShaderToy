# 1. 条款41：了解隐式接口和编译器多态

:one:`Template`以及泛型世界，与**面向对象**有根本上的不同，虽然**显式接口**和**运行期多态**依然存在，但重要性降低，反倒是**隐式接口和编译期多态**更为重要。

:two:显式接口由函数的签名式构成。**隐式接口并不基于函数签名式，而是由有效表达式组成**。

![image-20210608092202693](7.模板与泛型编程.assets\image-20210608092202693.png)



# 2. 条款42：了解typename的双重意义

:one:

![image-20210608092542520](7.模板与泛型编程.assets\image-20210608092542520.png)

任何时候想要在`template`中指涉一个**嵌套从属类型名称**，就必须在紧邻它的前一个位置放上关键词`typename`。而其他地方不该有它的存在：

![image-20210608092930165](7.模板与泛型编程.assets\image-20210608092930165.png)

:two:上诉规则的例外是：`typename`不可以出现在`base  classes list`内的嵌套从属类型名称之前，也不可以在成员初值列中作为base class修饰符：

![image-20210608093151836](7.模板与泛型编程.assets\image-20210608093151836-1623115916517.png)



# 3. 条款43：学习处理模板化基类内的名称

:one:当我们​在模板类上应用继承会导致一个问题：**派生类无法知道基类的成员函数**，因为无法知道其模板基类的细节。为什么不知道呢？因为模板类可能会特化，从而具有完全不同的特点（成员函数可能都不存在了）。

> 之前学的时候也说了，模板类实际上并不是类，在具现化时才会生成特定的类。

:two:有三个解决办法：

- 第一个是在基类函数调用动作之前加上`this->`：

  ![image-20210608094401418](7.模板与泛型编程.assets\image-20210608094401418.png)

- 第二是使用`using`声明式：

  ![image-20210608094454330](7.模板与泛型编程.assets\image-20210608094454330.png)

- 明确指出被调用的函数位于基类内：

  ![image-20210608094536073](7.模板与泛型编程.assets\image-20210608094536073.png)

但这个方法最不好，因为如果调用的是虚函数，上诉明确资格修饰会关闭虚绑定行为。

![image-20210608094708236](C:\Users\xueyaojiang\Desktop\JMX\ShaderToy\经典阅读\Effective C++\7.模板与泛型编程.assets\image-20210608094708236.png)



# 4. 条款44：将参数无关的代码抽离`template`

