# 继承和面向对象设计

## 1. 条款32：确定你的`public`继承塑膜出`is-a`关系

:one:以`C++`进行面向对象编程，==最重要的一个规则是==：`public`继承意味着`is-a`的关系。​

任何函数如果期望获得一个类型为基类（或指向person的指针和引用）的实参，也愿意接受一个派生类对象。但注意，这一切的前提是`public `继承，不适用于`private`或`protected`继承。

![image-20210422160618900](6.继承和面向对象设计.assets/image-20210422160618900.png)



## 2. 条款33：避免遮掩继承而来的名称

![image-20210422161003245](6.继承和面向对象设计.assets/image-20210422161003245.png)

:one:在这个继承关系中，以作用域为基础的==名称遮掩规则==并没有改变，以至于：`base::mf1`和`Base::mf3`不再被`Derived`继承：

![image-20210422161133568](6.继承和面向对象设计.assets/image-20210422161133568.png)

这些行为背后的基本理由是：为了防止你在程序库或应用框架内建立新的派生类时，附带地从疏远的基类继承重载函数。

:two:如果实在想要这么做，可以使用`using`声明式：

![image-20210422161447840](6.继承和面向对象设计.assets/image-20210422161447840.png)

:three:但有时候并不想要继承基类的所有函数，虽然在`public`继承下不可能发生，因为违反了`is-a`思想。所以这里我们考虑`private`继承，我们只想继承无参数版本，可以使用==转交函数==：

![image-20210422162203132](6.继承和面向对象设计.assets/image-20210422162203132.png)

:four:![image-20210422162243026](6.继承和面向对象设计.assets/image-20210422162243026.png)



## 3. 条款34：区分接口继承和实现继承

:one:令人意外的是：==我们可以为纯虚函数提供定义==，但调用它的唯一途径是使用时，明确指出其类名称。​

![image-20210422164003748](6.继承和面向对象设计.assets/image-20210422164003748.png)

+ 第一个错误是将所有函数声明为非虚函数。
+ 第二个则是都声明为虚函数。

:two:

![image-20210422164145191](6.继承和面向对象设计.assets/image-20210422164145191.png)



## 4. 条款35：考虑虚函数以外的其他选择