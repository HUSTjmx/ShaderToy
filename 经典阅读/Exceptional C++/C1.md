# 条款1：Iterators

:one:设计准则：绝对不要提领一个无效的迭代器。

使用`iterators`时，务必清楚以下四点:

1. 有效的数值：这个迭代器可以提领吗？如果你写`*e.end()`，绝对是个错误。
2. 有效的寿命：这个迭代器被使用时还有效吗？或是它已经因为某些操作而变得无效了。
3. 有效的范围：一对`iterators` 是否组成一个有效范围？
4. ==不合法的操作行为==：**代码**是否企图修改**内建类型的暂时物件**，像`--e.End()`这样？



# 条款2-3：不区分大小写的string

:one:写一个不分大小写的字符串类型，它其它方面都与标准库中的`string`类相同。

首先，我们不难知道`std::string`的本质：

<img src="C1.assets/image-20211111171413999.png" alt="image-20211111171413999" style="zoom: 67%;" />

<img src="C1.assets/image-20211111171429602.png" alt="image-20211111171429602" style="zoom:67%;" />

关键点是`char_trait`部分，它决定了字符的**相互作用和比较运算**（`!`运算）。如果你希望在`string`这些操作上有不同的行为，我们所要做的只是提供一个不同的`char_trait`模板。这是最容易的方法：

![image-20211111171800121](C1.assets/image-20211111171800121.png)

![image-20211111171819977](C1.assets/image-20211111171819977.png)

:two:最终将合并：

<img src="C1.assets/image-20211111172301647.png" alt="image-20211111172301647" style="zoom:67%;" />





# 条款4-5：具有最大可复用性的通用Containers

:one:为下面的==定长向量类==实现**拷贝构造操作**和**拷贝赋值操作**，以提供**最大的可用性**。提示：请考虑用户代码可能会用它做哪些事情。

![image-20211111172731713](C1.assets/image-20211111172731713.png)

![image-20211111172746093](C1.assets/image-20211111172746093.png)

:two:答案如下：

![image-20211111172910588](C1.assets/image-20211111172910588.png)

:three:进行分析。

你以为原本默认构造的拷贝构造和复制函数都不会生成了吗？不！真正的**拷贝构造函数或者拷贝赋值运算符**只对完全相同类型的对象施以**构造或赋值操作**。举个例子：

![image-20211111173640915](C1.assets/image-20211111173640915.png)

![image-20211111173650305](C1.assets/image-20211111173650305.png)

由于==模板构造函数终究不是拷贝构造函数==，因此这种模板的出现并**不会隐藏**原来隐含的拷贝构造函数之声明。如此一来，我们在解答中给出的代码实际上与原来问题中的原始代码==有着相同的拷贝构造函数和拷贝赋值运算符==——因为编译器始终生成它们隐含的版本。我们所做的改动只是**增强了构造操作和赋值操作的可适应性**，而不是替换掉了旧有的版本。

![image-20211111173831723](C1.assets/image-20211111173831723.png)

由此可以看出，本条款的问题所寻求的==真正答案==其实是：提供了具有可适应性的“从其它固定向量进行构造和拷贝的操作”，而不是具有可适应性的“拷贝构造操作和拷贝赋值操作”——它们早就存在了。

:four:我们增加的两个操作具有如下两个主要用途：

- 支持可变的类型（包括继承在内）

  ![image-20211111174422736](C1.assets/image-20211111174422736.png)

- 支持可变的大小。

  ![image-20211111174437495](C1.assets/image-20211111174437495.png)

:five:另一种解答：标准库风格。

![image-20211111174550920](C1.assets/image-20211111174550920.png)

![image-20211111174611600](C1.assets/image-20211111174611600.png)

![image-20211111174659207](C1.assets/image-20211111174659207.png)



# 条款6：临时对象

:one:让性能优化无法达到的罪魁祸首之一就是临时对象。考虑一下代码有几个不必要的临时对象：

![image-20211115162340615](C1.assets/image-20211115162340615.png)

![image-20211115162347146](C1.assets/image-20211115162347146.png)

:two:答案：

首先，函数的两个参数形式都是性能不高的，应该使用**常量引用**，而不是值传递。

> 规则：请使用`const&`，而不是传值拷贝。

然后，我也看出来了哈哈：`++i`要比`i++`效率更高，原因就是后增操作要返回一个包括递增前的值的临时对象（实现上也确实如此）。

> 规则：非必要，请使用先增操作，避免使用后增操作。

```
*i == name
```

这里没有体现`Employee`类，但如果想让它行得通，则要么来一个转换成`String`的操作，要么通过一个**转换构造函数**来得到一个字符串。然而两种方法都会产生**临时对象**。

> 尽可能显式的使用构造函数。

> 绝对不要返回局部对象的引用

:three:其实还有很多可以优化的地方，诸如：避免对`end()`进行多余的调用 。程序员可以使用一个`const_iterator`。



# 条款7：使用标准库





# 条款8-17：异常处理的安全性

:one:实现如下==异常-中立的容器==。要求：`Stack`对象的状态必须保持其**一致性**；即使有内部操作**抛出异常**，堆栈对象也必须是**可析构的**；`T`的异常必须能够传递到其调用者那里。

![image-20211115164425850](C1.assets/image-20211115164425850.png)

附加题：

- 根据当前的`C++`标准，标准库中的容器是==异常安全==还是==异常中性==？
- 应该让容器成为**异常中性**吗？为什么？有什么**折衷方案**吗？
- 容器应该使用**异常规则**吗？堆栈：比如，我们到底应不应该作诸如`Stack::Stack()throw(bad_alloc);`的声明？

挑战极限的问题：

- 由于在目前许多的编译器中使用`try`和`Catch`会给你的程序带来一些**额外的负荷**，所以在我们这种**低级的可复用容器**中，最好避免使用它们。你能在不使用`try`和`catch`的情况下，按照要求实现`Stack`所有的成员函数吗？

:two:解答。

现在我们来看看实现。我们对`T`有一个要求，就是`T`的**析构函数不能抛出异常**。这是因为，如果允许`T`的析构函数抛出异常，那我们就很难在保证代码安全性的前提下进行实现了。

![image-20211115172710774](C1.assets/image-20211115172710774.png)

![image-20211115172740379](C1.assets/image-20211115172740379.png)

![image-20211115172805716](C1.assets/image-20211115172805716.png)

![image-20211115172836492](C1.assets/image-20211115172836492.png)

![image-20211115172904186](C1.assets/image-20211115172904186.png)

:three:对附加题的解答。

![image-20211115173422767](C1.assets/image-20211115173422767.png)

![image-20211115173437221](C1.assets/image-20211115173437221.png)

:four:极限挑战问题的解答。

![](C1.assets/image-20211115173610520.png)

## 理解:star:

> 以上建立在：1、内建类型的各个操作，不会抛异常；2、模板参数T的析构函数不会抛异常。所以我们在上面实际会产生异常的只有两个地方：`NewCopy`函数和`result = v[...]`这个`T`的拷贝赋值上。
>
> 目前，还没看懂的是`pop()`那里的分析。
>
> 仔细看了会，我觉得问题在于旧版的`pop`是`return result;`，这里有一个局部对象产生和赋值，但这个时候发生错误抛异常，虽然状态改变了，但我们实际上并没有获得栈顶元素，下次再次进行调用，我们也只会获得中间的元素。甚至于，明明栈非空，却告诉调用者栈已经空了！。有点理解下面这段话了：
>
> ![image-20211115175450847](C1.assets/image-20211115175450847.png)



# 条款18：代码的复杂性(1)

:one:问题：在没有任何其它附加信息的情况下，下列代码中可以有多少条**执行路径**？

![image-20211116173009927](C1.assets/image-20211116173009927.png)

假设：

- 忽略对**函数参数**求值时的不同顺序，以及由**析构函数**抛出的异常。
- 调用的函数被认为具有**原子性**。

:two:==23==。`3`条和异常无关的路径，`20`条暗藏的路径，都与异常有关。

![image-20211116173529249](C1.assets/image-20211116173529249.png)

![image-20211116173547097](C1.assets/image-20211116173547097.png)



# 条款19：代码的复杂性(2)

:one:问题：让我们来考虑上一个条款里的那个函数。这个函数是**异常安全的**，出现异常时仍能**正常工作**；还是**异常中立的**，能将所有异常都**转给调用者**？

![image-20211116173009927](C1.assets/image-20211116173009927.png)

如果它是**异常安全的**，那它是**基本保证**，还是**强力保证**；如果他不是**异常安全的**，那该如何对其进行修改以使其进行修改，以支持**基本保证或强力保证**。

> 异常保证是关于==确保对象处于一致状态==，以便可以**安全地销毁对象**（==基本保证==），或撤消对对象的所有操作以便在**抛出异常时对象恢复到其先前状态**（==强保证==）

:two:解答。

如题所述，我们假设所有被调用的函数——包括流函数（`stream function`）在内——都是**异常安全的**（即可能抛出异常，但在抛出异常时无副作用），并且假设所使用到的所有对象——包括**临时对象**在内——也都是**异常安全的**（即当这些对象被销毁时，其占用的资源也都能被清理）。

然而`stream`却偏偏要对此使个拌儿——这缘于其可能产生的**“不可回滚”副作用**。例如，运算符`<<`可能会在输出了字符串的一部分之后抛出一个异常，而此时已经被输出的那部分是无

