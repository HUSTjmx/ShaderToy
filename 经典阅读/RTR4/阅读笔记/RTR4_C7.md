# Chapter 7——Shadow

本章聚焦于阴影计算的基础和经典算法，对于如今实时领域流行的算法会做个介绍。本章的一些术语进行介绍：投射阴影的叫做`occluders`，接受阴影的叫做`receivers`。`Punctual light`（非区域光）产生的阴影叫做硬阴影，区域光则会产生软阴影；完全阴影的地区叫做`umbra`，部分阴影的地区叫做`penumbra`。值得注意的是，软阴影虽然在表现形式上是模糊的阴影边缘，但是不可以直接通过低频滤波器对硬阴影边缘进行模糊获得。

<img src="RTR4_C7.assets/image-20201013101007106.png" alt="image-20201013101007106" style="zoom:67%;" />

投射的几何阴影区域越接近接收者，一个正确的软阴影应该越清晰。而光源越大，软阴影的`umbra`越小。本章的行文思路：平面（地面）投影，任意平面投影，投影优化。



## 1. Planar Shadow

### 1.1 Projection Shadows

这项技术主要是，将三维物体渲染第二次来产生Shadow——计算一个矩阵，将物体的点投影到平面上。首先我们考虑特殊情况，既平面为Y=0（下图左）

<img src="RTR4_C7.assets/image-20201013102730063.png" alt="image-20201013102730063" style="zoom:67%;" />

我们先考虑其X坐标的关系，可以得到如下公式：
$$
\frac{p_x-l_x}{v_x-l_x}=\frac{l_y}{l_y-v_y}\rightarrow p_x=\frac{l_yv_x-l_xv_y}{l_y-v_y}
$$
Z坐标同上推导，而Y坐标则为常数0。，因此可以由此得到变换矩阵如下：

![image-20201013103437942](RTR4_C7.assets/image-20201013103437942.png)

更常规的情况是投影到任意平面$\pi:n\cdot x+d=0$（其中n，x都是向量），此时，推得：
$$
p=l-\frac{d+n\cdot l}{n\cdot (v-l)}(v-l)
$$
使得$Mv=p$的投影矩阵为：

<img src="RTR4_C7.assets/image-20201013103852729.png" alt="image-20201013103852729" style="zoom:67%;" />

然后，实际使用的过程中，为了避免阴影渲染在平面以下，我们还需要给投影的平面加上一点偏移。当然也可以通过关闭深度测试来避免。



### 1.2 Soft Shadow

==投影阴影也可以产生软阴影==，这里介绍了一种实现技术——低精度但是快速。软阴影产生于区域光，而区域光可以通过在它表面采样几个`Punctal lights`来近似，然后对它们每一个进行单独渲染，并将结果存储到一个BUFFER中，最后进行平均，来产生软阴影。

这里的技术基于`frustum`的方法来产生他们的阴影。这个想法是把光当作观察者，地面就成了`frustum`的剪切面。然后使用之前描述过的采样平均方法。这种方法给出了一个精确但昂贵的解决方案，但更多是作为其他快速方法的指标。

<img src="RTR4_C7.assets/image-20201013114144509.png" alt="image-20201013114144509" style="zoom:50%;" />

一种更有效的方法是使用==卷积，即滤波==。模糊一个单点生成的硬阴影在某些情况下是足够的，可以产生一个半透明的纹理，与真实世界的内容结合。参见下图。然而，在物体与地面接触的地方，均匀模糊是难以令人信服的。

<img src="RTR4_C7.assets/image-20201013114537361.png" alt="image-20201013114537361" style="zoom:33%;" />

还有一些==其他更好的方法==，虽然有额外的花销。从一个投影的硬阴影开始，然后用梯度渲染边缘，从中心的黑暗到边缘的白色；利用球面谐波的想法，用椭球体近似，给予柔和的阴影。



## 2. Shadows on Curved Surfaces

将平面投影扩展到曲面投影的一个简单方法是，是属于一张生成的阴影图来作为投影纹理`projective texture`。以光的位置为视点，能看到的区域就要被渲染，否则就是阴影区。这里，首先将`Occluder`渲染进一张白色图，他所在的像素渲染成黑色，这个纹理被投射到`Receiver`上

纹理投影方法存在着一些严重的缺陷。首先，应用程序必须识别哪些对象是`Occluders`，哪些对象是`Receivers`。接收者与光的高度距离要大于和遮挡者的，否则阴影就会“向后投射”。同时，遮挡对象不能遮挡自己。

而纹理投影也可以应用到其他地方，比如说：条纹状阴影可以产生百叶窗效果。这也是C6.9提到过的`Cookie`。



## 3. Shadow Volumes

`Crow shadow volumes`通过使用`stencil buffer`可以在任意物体上投射阴影。它不是基于图像的(不像下面描述的阴影映射算法)，这样就避免了采样问题，从而在任何地方产生正确的锐利阴影。于其不可预测的成本，阴影体积现在很少被使用。本文对算法进行了简要的描述，说明了算法的一些重要原理，并在此基础上进行了进一步的研究。

<img src="RTR4_C7.assets/image-20201013123042362.png" alt="image-20201013123042362" style="zoom:50%;" />

==大致思想==：首先，想象一个点光源和一个三角形，形成如上图。然后从视点处，进行Ray Marching过程，射线在打中物体之前，每和`Shadow Volume`的正面相交一次，计数器加一，背面则减一，如果最后打中物体时，计数器大于0，则说明该物体处于阴影区内。

直接这样做耗时持久，更聪明的实现方式是：使用`stencil buffer`进行计数：1.`stencil Buffer`清零。2. 常规渲染（需要光参与的不进行计算），更新color和Z buffer。3. color和z停止更新，绘制`shadow volume`的`front face`，所有能绘制的地方（通过深度测试），`stencil Buffer`的值加一。4. 背面也来一遍，不过是减一。5. 所有`stencil Buffer`的值为0的地方进行光参与的计算。关于==Z-Fail==，具体见书P 232

<img src="RTR4_C7.assets/image-20201013124711958.png" alt="image-20201013124711958" style="zoom:50%;" />

除了资源消耗（每个三角形片元都需要三个四边形来组成`Shadow volumes`）,然而，阴影体算法仍然有一个可怕的缺点:极端的可变性——随着视点或者光源的移动，`Shadow Volume`不断发生改变，导致更多的计算成本。



## 4. Shadow Maps

==阴影映射==，有一个更可预测的成本，非常适合GPU，因此在许多应用中形成阴影生成的基础。这个想法是使用z-buffer，从投射阴影的光源位置来渲染场景。光“看到”的是被照亮的，其余的都在阴影中。在生成此Image时，只需要z缓冲。此时，Z-Buffer中每个像素存储了离光源最近的物体的深度值，它也被称为`shadow map`或者`shadow depth map`、`shadow buffer`。然后正常视角进行第二次渲染，每个像素的深度值转到光源视点空间后，和之前的`shadow map`对应的深度值进行比较（通过转化后的（x,y）坐标进行索引），大于它，则说明其位于阴影处。

<img src="RTR4_C7.assets/image-20201013144155245.png" alt="image-20201013144155245" style="zoom:67%;" />

但目前的使用域比较狭窄，考虑光源周围是物体的情况？这个时候传统的解决方法是建立一个`six-view cube`，类似于之前的`cubic environment mapping`，因此称为`omnidirectional shadow maps`。这项技术的主要问题在两个图片连接处。一些拓展文献详见书P 234。根据视点的`volumes`，调整light-view的视锥体，使其==自动剔除一些不在视点视锥体内的Occluders==，提高算法的性能，降低消耗，详见书P 235。

阴影贴图技术的==主要缺点==是：实现效果依赖于阴影图的分辨率和`Z-buffer`的数值精度。离物体间接触的地方越近，锯齿问题越容易出现，一个常见的问题就是`self-shadow aliasing`——a triangle is incorrectly considered to shadow itself 。出现这个问题有两个主要原因：1.存储精度，2.几何原因，阴影贴图的采样位置和该点的位置并不完全对应，一般偏小。

<img src="RTR4_C7.assets/image-20201013150940136.png" alt="image-20201013150940136" style="zoom:50%;" />

一个常见的解决方法就是引入`bias`——从物体到视点的距离中减去它。除了使用常量，一种更有效的方法是使用<与**接收者对光的角度**成比例>的偏差——==倾斜角度越大，偏置就越大==。这种技术被称为`slope scale bias`

<img src="RTR4_C7.assets/image-20201013151941296.png" alt="image-20201013151941296" style="zoom:67%;" />

`Normal offset bias`：沿表面法线方向移动接收器的空间位置，移动距离与$sin(n\cdot l)$成正比。这种方法可以想象为：移动到接收器上方的“虚拟表面”进行采样。这个偏移量是一个世界空间距离。（==形象化可见上图右==）

过多的偏置会导致所谓的==光泄漏==或`light leaks or Peter Panning  `的问题，即物体似乎漂浮在底层表面之上（上上图：右）。这种伪影的出现是因为物体接触点下方的区域，例如脚下的地面，向前移动太远（地面深度反而小于脚的深度），所以没有阴影。

`second-depth shadow mapping`：==核心观点==是只渲染物体的背面`backfaces`深度到`ZBuffer`中。当物体是双面的、薄的或相互接触的时候，就会出现问题——因为此时，背面和正面的深度一致或接近。选择哪种方案取决于具体情况——例如，Sousa等人[1679]发现，使用正面作为太阳阴影，使用背面作为室内灯光，效果最好。

请注意，对于阴影贴图，对象必须是`water tight`(多面体和封闭的)，或者正面和背面必须都呈现在贴图上，否则对象可能无法完全投射阴影。吴志明[1900]提出了一种通用方法，即试图在只使用正面或背面进行阴影处理之间找到折衷的方法。他的想法是将solid物体渲染到阴影贴图上，并跟踪两个离光最近的表面。这个过程可以通过`depth peeling`（OIT）或其他与透明相关的技术来完成。两个物体表面之间的平均深度形成一个中间层，其深度被用作阴影图，==有时称为==`dual shadow map`

关于视点移动情况下，光源的视锥体改变size来修改Occluder set，导致阴影在帧与帧之间发生轻微的变化，这是因为light的阴影贴图从light中采样了一组不同的方向，而这些方向与前一组不一致。对于定向光，解决方案是在：世界空间中，强制每个后续生成的阴影贴图，保持相同的、相对==texel beam locations== 。见书P 239。



### 4.1 Resolution Enhancement

光的方向一旦改变，像素的比例就会改变（即一个阴影贴图像素包含多少个视点像素），这就会造成`artifacts`。如下图组左：阴影是块状的，定义很差，因为前景中的大量像素都与阴影贴图的每个texel相关联。==这种叫做==`perspective aliasing  `。如果一个表面与光线接近平行，但面向观察者，也会导致这种现象，但这个被称为==射影混叠==`projective aliasing  `。可以通过增加阴影贴图的分辨率来减少块度，但是要以额外的内存和处理为代价。

<img src="RTR4_C7.assets/image-20201013164122761.png" alt="image-20201013164122761" style="zoom:67%;" />