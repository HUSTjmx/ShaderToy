# Chapter 15——Non-Photorealistic Rendering

> 建议使用主题`Fluent`阅读

非真实感渲染(**NPR**)，也称为程式化渲染，有广泛的目标。NPR的另一个领域是模拟绘画风格和自然介质，如钢笔和墨水，炭笔和水彩（ pen and ink, charcoal, and watercolor）。两本旧书提供了部分NPR算法 [**563,1719**]。

<img src="RTR4_C15.assets/image-20201224141740458.png" alt="image-20201224141740458" style="zoom:80%;" />



## 1. Toon Shading

这种风格被认为是**卡通**，它有幻想和童年的内涵。最简单的方法是，==用实线画出不同颜色的区域==。卡通渲染风格已经在计算机图形学中使用了几十年，它将三维模型与二维的`cel`动画结合在一起。与其他NPR风格相比，它很容易定义，因此很适合由计算机自动生成。一些游戏进行了广泛的使用 [**250, 1224, 1761**]。

<img src="RTR4_C15.assets/image-20201224144015352.png" alt="image-20201224144015352" style="zoom: 67%;" />

**物体的轮廓**通常用黑色渲染，这放大了卡通的外观。而对于渲染卡通表面，有许多不同的方法——==两种最常见的方法==是用实色（无光照）填充网格区域（`solid`），或使用`two-tone`方法。

`two-tone`方法也被称为`hard shading`，当渲染法线和光源方向的**点积**高于某个值时，使用**较浅的颜色**，反之则使用**较深的色调**。

<img src="RTR4_C15.assets/image-20201224144934764.png" alt="image-20201224144934764" style="zoom:67%;" />

当光照比较复杂时，另一种方法是对**最终图像本身**进行量化。这种方法也被称为 ==posterization==:arrow_up:，将一个连续的**值范围**转换为几个`tones`。量化**RGB值**有时是不好的，因为各个通道是不相关的。

使用==HSV==、==HSL==或==Y`CbCr==等保色空间是更好的选择。另外，可以定义一个**一维函数**或纹理来**重新映射**强度级别到特定的`shades or colors`。纹理也可以使用**量化**或其他**过滤器**，进行预处理。

B神通过使用一张二维贴图，代替一维纹理，来产生**视相关**的效果 [**104**]。**第二个维度**是通过表面的深度或方向来访问的，例如，当物体距离较远或快速移动时，它可以**平滑软化**。



## 2. Outline Rendering

有几种不同类型的**边缘**可以在**卡通渲染**中使用：

- ==boundary==或==border==是两个三角形不共用的边，例如：纸的边缘。固体物体没有此类边。
- ==crease,hard or feature edge==（折痕、硬边或特征边）是两个三角形所共用的，但其**夹角**高于某个预设值。一个好的默认**折痕角度**是60度 [**972**]。折痕边缘可以进一步细分为==ridge==和==valley==（脊边和谷边）。
- ==material edge==当共享它的两个三角形在材质上不同，或在其他方面造成渲染变化时，将出现。
- ==contour edge==是指两个相邻的三角形，相对于某个方向向量（通常是view），朝向不同的方向。（**轮廓**）
- ==silhouette edge==是沿着物体轮廓的**轮廓边缘**，即在图像平面上将物体与背景分离开来。

<img src="RTR4_C15.assets/image-20201224151253421.png" alt="image-20201224151253421" style="zoom:80%;" />

我们在此区分轮廓和轮廓边缘，**S**是**C**（contour edge）的子集，因为**S**将物体和其它部分分离开，而**C**则不需要。暗示轮廓==Suggestive contours== [**335**]是由从原始视点来看，几乎是轮廓的位置形成的。它们提供**额外的边缘**，帮助传达物体的形状:arrow_down:。

<img src="RTR4_C15.assets/image-20201224152255037.png" alt="image-20201224152255037" style="zoom:80%;" />

我们关注的焦点是**contour edges**。[**132**]

### 2.1 Shading Normal Contour Edges

渲染法线和视线向量之间的**点积**可以用来给出轮廓（contour）。这种方法的一个**缺点**是：等高线的宽度是可变的，取决于表面的曲率。这种方法适用于没有**折痕边缘**的曲面模型

<img src="RTR4_C15.assets/image-20201224153040090.png" alt="image-20201224153040090" style="zoom:67%;" />

该算法在诸如**立方体**这样的模型上失效，因为**折痕边缘**附近的`surface`不具备这一属性。即使在曲面上，它也会被破坏，看起来很糟糕，因为当物体很远，轮廓（`contour`）附近的一些法线采样可能并不接近垂直。[**565**]

###  2.2 Procedural Geometry Silhouetting

R神提出了第一个实时**轮廓渲染**技术 [**1510**]，并由C神进行优化 [**1460**]。一般的想法是正常渲染正面，然后用某种技术渲染背面，使其轮廓边缘（contour）可见。

渲染轮廓的**一种方法**是只绘制背面的边缘（而不是正面）。一种使这些线**变宽**的方法是将背面本身渲染成黑色，再次向前偏置（biasing forward）。

Raskar和Cohen给出了几种偏置方法，例如固定偏移、an amount that compensates for the nonlinear nature of the z-depths、**深度-斜率偏差调用**（depth-slope bias）——例如**OpenGL**的`glPolygonOffset`。这些方法的一个**共同问题**是创建的线条宽度不一致，因此偏移值不仅取决于背面，还取决于相邻的正面(s)。见下图:arrow_down:。​

> Lengyel[**1022**]讨论了如何通过修改透视矩阵来提供更精细的深度控制

<img src="RTR4_C15.assets/image-20201224155456963.png" alt="image-20201224155456963" style="zoom:80%;" />

R神 [**1460,1461**]解决了这个**邻接依赖问题**，取而代之的方法是：将每个背面三角形沿其边缘增大，而三角形的**斜率**和到观看者的距离决定了三角形的**扩展量**。

- 一种方法是将每个三角形的三个顶点沿其平面向外展开。:arrow_down:
- 绘制三角形的一种**更安全的方法**是将三角形的每条边向外移动并连接这些边。这样做可以避免顶点远离原始三角形。:arrow_down:

<img src="RTR4_C15.assets/image-20201224160210535.png" alt="image-20201224160210535" style="zoom:80%;" />

三种方法的结果见下图:arrow_down:。这种增大技术（==fattening==）更加可控和一致，并成功地用于《*波斯王子*》和《*爆炸头*》等电子游戏。

<img src="RTR4_C15.assets/image-20201224160407727.png" alt="image-20201224160407727" style="zoom:67%;" />

**另一种方法**是通过沿**共享顶点法线**，移动它们的顶点，将背面向外移动，移动量与它们与眼睛的**z距离**成正比 [**671**]。这被称为`shell`或`halo`方法。沿着顶点的法线，向外移动顶点是**顶点着色器**的一个完美任务。这种类型的扩展有时称为==shell映射==。

<img src="RTR4_C15.assets/image-20201224161038870.png" alt="image-20201224161038870" style="zoom:80%;" />

一个`shell`实现：

<img src="RTR4_C15.assets/image-20201224161241369.png" alt="image-20201224161241369" style="zoom:50%;" />

==这类算法只呈现轮廓边缘（contour edges）==。Raskar[**1461**]给出了一个巧妙的解决方案，可以在变形模型上绘制==脊折痕边==，而不需要创建和访问**边连通性数据结构**。这个想法是：:arrow_down:

- 沿着被渲染的三角形的每条边，生成一个额外的多边形。
- 这些**边缘多边形**通过用户定义的**临界二面角**，在三角形的平面上进行弯曲，该临界二面角决定了何时应该出现折痕。
- 如果两个相邻的三角形的折痕角大于这个**临界折痕角**，边缘多边形将可见，否则将被三角形隐藏。

<img src="RTR4_C15.assets/image-20201224162112662.png" alt="image-20201224162112662" style="zoom:67%;" />



###  2.3 Edge Detection by Image Processing

检测和渲染这些边缘包括两个部分。首先，渲染场景的几何形状，像素着色器保存深度，法线，对象id，或其他所需的各种渲染目标的数据。然后以类似12.1节中描述的方式进行后处理。后处理通过采样每个像素周围的邻域，并根据这些采样输出结果。

<img src="RTR4_C15.assets/image-20201224163124773.png" alt="image-20201224163124773" style="zoom:67%;" />

一旦产生了这些笔画，就可以根据需要，进行进一步的**图像处理**。由于笔画可以在单独的缓冲区中创建，它们可以自行修改，然后在表面上合成。例如，噪声函数可以用于分别**磨损**和**摆动**线条和表面，在两者之间创建**小间隙**，并提供手绘外观。纸张的高度可以用来影响渲染效果，比如在凸起的顶部**沉积**木炭等固体材料，或者在山谷中**堆积**水彩颜料。如图15.16

<img src="RTR4_C15.assets/image-20201224163728212.png" alt="image-20201224163728212" style="zoom:80%;" />

一种方法被称为**差高斯**(==difference of Gaussians==)，其中图像处理两次，用两个不同的**高斯滤波器**，然后一个从另一个减去。这种边缘检测方法已被发现**为NPR产生特别令人满意的结果**，用于生成各种艺术风格的图像，如**铅笔渲染**和**蜡笔**。 [**949, 1896, 1966**].

Kyprianidis等人[**949**]对NPR领域的图像处理效果进行了全面的回顾和分类。

Montesdeoca等人[**1237**]的作品是一个很好的例子，将一些简单的技术结合到**以交互速率运行**的水彩效果中。下图:arrow_down:显示了一个用水彩风格渲染的模型。

<img src="RTR4_C15.assets/image-20201224164144280.png" alt="image-20201224164144280" style="zoom:67%;" />



###  2.4 Geometric Contour Edge Detection