# 1. 管理线程

## 1.1 基本线程管理

线程是通过构造`std::thread`对象来开始的，该对象指定了线程上要运行的任务。。如同大多数 C++标准库一样，`std::thread` 可以用**可调用（callable）类型**构造，将带有**函数调用符类型 的实例**传入 std::thread 类中，替换默认的构造函数。

```c++
class background_task
{
public:
    void operator()() const
    {
        do_something();
        do_something_else();
    }
};
background_task f;
std::thread my_thread(f);

```

或者使用`lambda`表达式：

```c++
std::thread my_thread([]{
    do_something();
    do_something_else();
});
```

启动了线程，你需要明确是要等**待线程结束**（加入），还是让其**自主运行**（分离）。如果 std::thread 对象销毁之前还没有做出决定，程序就会终止 ( **std::thread 的析构函数**会调用 **std::terminate()** )。因此，即便是有异常存在，也需要确保线程能够正确的加入(`joined`)或分离(`detached`)。

如果不等待线程，就必须保证线程结束之前，**可访问数据的有效性**。这种情况很可能发生在线程还没结束，函数已经退出的时候，这时线程函数还持有**函数局部变量的指针或引用**。

```c++
//清单2.1
struct func
{
    int& i;
    func(int& i_) : i(i_) {}
    void operator() ()
    {
        for (unsigned j=0 ; j<1000000 ; ++j)
        {
        	do_something(i); // 1. 潜在访问隐患：悬空引用
        }
    }
};
void oops()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread my_thread(my_func);
    my_thread.detach(); // 2. 不等待线程结束
} // 3. 新线程可能还在运行

```

> 上面会调用已经释放的变量`i`

### 等待线程完成

如果需要**等待线程**，相关的 **std::tread 实例**需要使用``join()``。清单2.1中， 将 my_thread.detach() 替换为 my_thread.join() ，就可以确保局部变量在线程完成后，才被销毁。

`join()`是简单粗暴的等待线程完成或不等待。==只能对一个线程使用一次join()；==一旦已经使用过 join()， **std::thread 对象**就不能再次加入了，当对其使用``joinable()``时，将返回否（false）。

如果打算**等待对应线程**，则需要细心挑选**调用join()的位置**。当在线程运行之后产生异常，在join()调用之前抛出，就意味着很这次调用会被跳过。 避免应用被抛出的异常所终止，就需要作出一个决定。通常，当==倾向于在无异常的情况下使用join()时，需要在异常处理过程中调用join()==，从而避免生命周期的问题。下面的程序清单是 一个例子。

```c++
struct func; // 定义在清单2.1中
void f()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread t(my_func);
    try
    {
    	do_something_in_current_thread();
    }
    catch(...)
    {
        t.join(); // 1
        throw;
    }
    t.join(); // 2
}
```

一种更好方式是使用“**资源获取即初始化方式**”(==RAII==，Resource Acquisition Is Initialization)，并且提供一个类，在**析构函数**中使用join()，如同下面清单中的代码。看它如何简化``f()``函数。

``` c
class thread_guard
{
    std::thread& t;
    
    public:
    explicit thread_guard(std::thread& t_):
    t(t_){}
    
    ~thread_guard()
    {
        if(t.joinable()) // 1
        {
        	t.join(); // 2
        }
    }
    
    thread_guard(thread_guard const&)=delete; // 3
    thread_guard& operator=(thread_guard const&)=delete;
};
struct func; // 定义在清单2.1中
void f()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
} // 4

```

### 后台运行线程

使用``detach()``会让线程在后台运行，这就意味着主线程不能与之产生直接交互。也就是说，不 会等待这个线程结束；如果线程分离，那么就不可能有 **std::thread 对象**能引用它。通常称**分离线程**为**守护线程**（daemon threads），应用场景是两个极端：

+ 长时间运行

+ "发后即忘"(fire and forget)的任务

  

## 1.2 传递参数给线程函数

