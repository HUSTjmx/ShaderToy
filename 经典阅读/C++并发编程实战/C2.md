# 3. 同步并发操作

C++提供了==条件变量==和==期望==来进行线程同步。

## 3.1等待一个事件或其他条件

 :one:标准C++库提供了两个条件变量的实现：	`std::condition_variable`和`std::condition_variable_any`。这两个实现都包含在`<condition_variable>`头文件的声明中。两者都需要与一个**互斥量**一起才能工作（互斥量是为了同步）；前者仅限于与`std::mutex`一起工作，而后者可以和**任何满足最低标准的互斥量**一 起工作，从而加上了`_any`的后缀。

因为`std::condition_variable_any`更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以`std::condition_variable`一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑`std::condition_variable_any`。

怎么使用呢？

```c++
 std::mutex mut;
std::queue<data_chunk> data_queue; // 1
std::condition_variable data_cond;
void data_preparation_thread()
{
while(more_data_to_prepare())
    {
        data_chunk const data = prepare_data();
        std::lock_guard<std::mutex> lk(mut);
        data_queue.push(data); // 2
        data_cond.notify_one(); // 3
    }
}

void data_processing_thread()
{
    while(true)
    {
        std::unique_lock<std::mutex> lk(mut); // 4
        data_cond.wait(
        lk,[]{return !data_queue.empty();}); // 5
        
        data_chunk data = data_queue.front();
        data_queue.pop();
        lk.unlock(); // 6
        process(data);
        if(is_last_chunk(data))
        	break;
    }
}
```

具体分析可以见书P 66，或者自己分析。需要注意：`std::condition_variable`的`notify_one()`成员函数，对等待的线程（如果有等待线程）进行通知。

:two:使用条件变量构建**线程安全队列**：

```c++
#include<condition_variable>
#include<thread>
#include<mutex>
#include<queue>
#include<memory>

template<typename T>
class threadsafe_queue {
private:
	mutable std::mutex mut; //互斥量必须是可变的

	std::queue<T>data_queue;
	std::condition_variable data_cond;
public:
	threadsafe_queue() {}
	threadsafe_queue(threadsafe_queue const& other) {
		std::lock_guard<std::mutex> lk(other.mut);
		data_queue = other.data_queue;
	}

	void push(T new_value) {
		std::lock_guard<std::mutex> lk(mut);
		data_queue.push(new_value);
		data_cond.notify_one();
	}

	void wait_and_pop(T& value) {
		std::unique_lock<std::mutex> lk(mut);
		data_cond.wait(lk, [this] {return !data_queue.empty();});
		value = data_queue.front();
		data_queue.pop();
	}

	std::shared_ptr<T> wait_and_pop() {
		std::unique_lock<std::mutex> lk(mut);
		data_cond.wait(lk, [this] {return !data_queue.empty();});
		std::shared_ptr<T> res(std::make_shared<T>(data_queue.front()));
		data_queue.pop();
		return res;
	}

	bool try_pop(T& value) {
		std::lock_guard<std::mutex> lk(mut);
		if (data_queue.empty())
			return false;
		value = data_queue.front();
		data_queue.pop();
		return true;
	}

	bool empty() {
		std::lock_guard<std::mutex> lk(mut);
		return data_queue.empty();
	}
};
```



## 3.2 使用期望等待一次性事件

:one:`future`线程会周期性的等待或检查，事件是否触发；在检查期间也会执行其他任务。直到对应的任务触发，而后等待期望的状态会变为**“就绪”(ready)**。一个“期望”可能是数据相关的，也可能不是。当事件发生时（并且期望状态为就绪），**这个“期望”就不能被重置**。

在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件`<future>`中：==唯一期望==( `std::future<>` )和==共享期望==( `std::shared_future<> `)。这是仿照 `std::unique_ptr`和 `std::shared_ptr` 。 

后者的实现中，所有实例会在同时变为**就绪状态**，并且他们可以访问与事件相关的**任何数据**。这些**关联的数据**就是它们成为模板的原因。在与数据无关的地方，可以使用 `std::future `与 `std::shared_future `的特化模板。

`std::thread`执行的任务不能有返回值，**这个问题将在使用“期望”后解决**；

:two:解决方法是使用`std::async`启动一个==异步任务==，其返回一个`std::feature`对象（持有函数返回值）。我们需要时，只需要在上面调用`get()`。一个简单的例子：

```c++
#include <future>
#include <iostream>
int find_the_answer_to_ltuae();
void do_other_stuff();
int main()
{
    std::future<int> the_answer=std::async(find_the_answer_to_ltuae);
    do_other_stuff();
    std::cout<<"The answer is "<<the_answer.get()<<std::endl;
}

```

与 `std::thread` 做的方式一样， `std::async`允许通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象（不是直接的，就是通过指针，还可以包装在 `std::ref `中），剩余的参数可作为**成员函数的参数**传入。否则，第二个和随后的参数将作为函数的参数。

```c++
#include <string>
#include <future>
struct X
{
    void foo(int,std::string const&);
    std::string bar(std::string const&);
};

X x;
auto f1 = std::async(&X::foo,&x,42,"hello"); // 调用p->foo(42, "hello")，p是指向x的指针
auto f2 = std::async(&X::bar,x,"goodbye"); // 调用tmpx.bar("goodbye")， tmpx是x的拷贝副本

struct Y
{
	double operator()(double);
};
Y y;
auto f3 = std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到
auto f4 = std::async(std::ref(y),2.718); // 调用y(2.718)

X baz(X&);
std::async(baz, std::ref(x)); // 调用baz(x)

class move_only
{
public:
    move_only();
    move_only(move_only&&)
    move_only(move_only const&) = delete;
    move_only& operator=(move_only&&);
    move_only& operator=(move_only const&) = delete;
    void operator()();
};
auto f5 = std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到
```

:three:可以在函数调用之前使用一个额外参数来指定究竟使用什么启动方式，这个参数为`std::launch`类型：

- `std::launch::deferred`，表面该函数调用会延迟，直到在future上调用`wait()`或`get()`。
- `std::launch::async`表明该函数必须允许在它自己的线程上。
- 1|2：表明可以由具体实现来选择。这是默认的。

在本章的后面和第8章中，你将会再次看到这段程序，使用 `std::async `会让**分割算法到各个任务中变的容易**，这样程序就能并发的执行了。



