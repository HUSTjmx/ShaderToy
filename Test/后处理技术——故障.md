# 故障艺术

<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20210424135834203.png" alt="image-20210424135834203" style="zoom:80%;" />



## RGB颜色分离故障（RGB Split Glitch）

#### Common

```c++
#define IDENSITY (0.091)
#define PATTERRN (2)
#define AMPLITUDE (3.0)

float randomNoise(float x, float y)
{
	return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);
}
```

#### Image

```c++
float getSplitAmount()
{
    #if PATTERRN > 1
        float splitA = (1. + sin(iTime * 6.)) * 0.5;
        splitA *= 1.0 + sin(iTime * 16.) * 0.5;
        splitA *= 1.0 + sin(iTime * 19.) * 0.5;
        splitA *= 1.0 + sin(iTime * 27.) * 0.5;
        splitA = pow(splitA, AMPLITUDE);
        splitA *= (0.05 * IDENSITY);
        return splitA;
    #else
        return IDENSITY * randomNoise(iTime, 2.);
    #endif
    
}

vec3 Frag_Horizontal(vec2 uv)
{
    float splitamout = getSplitAmount();
    vec3 col;
    
    col.r = texture(iChannel0, uv + vec2(splitamout, 0.0)).r + splitamout;
    col.g = texture(iChannel0, uv + vec2(0.0, 0.0)).g;
    col.b = texture(iChannel0, uv - vec2(splitamout, 0.0)).b + splitamout;
    
    return col;
}

vec3 Frag_Vertical(vec2 uv)
{
    float splitamout = getSplitAmount();
    vec3 col;
    
    col.r = texture(iChannel0, uv + vec2(0.0, splitamout)).r;
    col.g = texture(iChannel0, uv + vec2(0.0, 0.0)).g;
    col.b = texture(iChannel0, uv - vec2(0.0, splitamout)).b;
    
    return col;
}

vec3 Frag_Horizontal_Vertical(vec2 uv)
{
    float splitamout = getSplitAmount();
    vec3 col;
    
    col.r = texture(iChannel0, uv + vec2(splitamout, splitamout)).r;
    col.g = texture(iChannel0, uv + vec2(0.0, 0.0)).g;
    col.b = texture(iChannel0, uv - vec2(splitamout, splitamout)).b;
    
    return col;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = Frag_Horizontal(uv);

    // Output to screen
    fragColor = vec4(col,1.0);
}
```

#### 结果

![](后处理技术——故障.assets/1/lenfc-dq5dr.gif)



## 错位图块故障（Image Block Glitch）

### 基础版本的错位图块故障（Image Block Glitch）

#### Common

```c++
#define BLOCK_SIZE (10.0)
#define SPEED (10.1)
```

#### Image

```c++
float randomNoise(vec2 seed)
{
    return fract(sin(dot(seed * floor(iTime * SPEED), vec2(17.13, 3.71))) * 43758.5453123);
}


float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

vec3 ImageBlockGlitch_BASE(vec2 uv)
{
    vec2 block = vec2(randomNoise(floor(uv * vec2(BLOCK_SIZE))));
    float dis = pow(block.x, 8.) * pow(block.x, 3.);
    vec3 col;
    
    col.r = texture(iChannel0, uv).r;
    col.g = texture(iChannel0, uv + vec2(dis * 0.05 * hash11(block.y + iTime), 0.0)).g;
    col.b = texture(iChannel0, uv - vec2(dis * 0.05 * hash11(block.y + iTime), 0.0)).b;
    
    return col;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = ImageBlockGlitch_BASE(uv);

    // Output to screen
    fragColor = vec4(col,1.0);
}
```

#### 结果

![](后处理技术——故障.assets/2/1asio-zdq6c.gif)



### 结合RGB Split的错位图块故障（Image Block Glitch）

#### Common

```c++
#define BLOCK_SIZE (10.0)
#define SPEED (12.1)

#define _MaxRGBSplitX (2.)
#define _MaxRGBSplitY (2.)
```

#### Image

```c++
float randomNoise(vec2 seed)
{
    return fract(sin(dot(seed * floor(iTime * SPEED), vec2(17.13, 3.71))) * 43758.5453123);
}


float randomNoise(float seed)
{
	return randomNoise(vec2(seed, 1.0));
}

vec3 ImageBlockGlitch_RGB(vec2 uv)
{
    vec2 block = vec2(randomNoise(floor(uv * vec2(BLOCK_SIZE))));
    float displaceNoise = pow(block.x, 8.0) * pow(block.x, 3.0);
	float splitRGBNoise = pow(randomNoise(7.2341), 15.0);
	float offsetX = displaceNoise - splitRGBNoise * _MaxRGBSplitX;
	float offsetY = displaceNoise - splitRGBNoise * _MaxRGBSplitY;

	float noiseX = 0.05 * randomNoise(13.0);
	float noiseY = 0.05 * randomNoise(7.0);
	vec2 offset = vec2(offsetX * noiseX, offsetY * noiseY);
    vec3 col;
    
    col.r = texture(iChannel0, uv).r;
    col.g = texture(iChannel0, uv + offset).g;
    col.b = texture(iChannel0, uv - offset).b;
    
    return col;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = ImageBlockGlitch_RGB(uv);

    // Output to screen
    fragColor = vec4(col,1.0);
}
```

#### 结果

![](后处理技术——故障.assets/3/ck9bt-qg4gp.gif)



### 进阶版的错位图块故障（Image Block Glitch）

#### Common

```c++
#define SPEED (10.1)
#define _Fade (1.)
#define _Offset (10.)


#define _BlockLayer1_U (5.)
#define _BlockLayer1_V (9.5)

#define _BlockLayer2_U (15.)
#define _BlockLayer2_V (15.)

#define _BlockLayer1_Indensity (6.)
#define _BlockLayer2_Indensity (4.)

#define _RGBSplit_Indensity (4.)
```

#### Image

```c++
float randomNoise(vec2 seed)
{
    return fract(sin(dot(seed * floor(iTime * SPEED), vec2(127.13, 311.71))) * 43758.5453123);
}


float randomNoise(float seed)
{
	return randomNoise(vec2(seed, 1.0));
}

vec4 ImageBlockGlitch_HIGH(vec2 uv)
{
    vec2 blockLayer1 = floor(uv * vec2(_BlockLayer1_U, _BlockLayer1_V));
    vec2 blockLayer2 = floor(uv * vec2(_BlockLayer2_U, _BlockLayer2_V));
    //return vec4(blockLayer1, blockLayer2);
    
    float lineNoise1 = pow(randomNoise(blockLayer1), _BlockLayer1_Indensity);
    float lineNoise2 = pow(randomNoise(blockLayer2), _BlockLayer2_Indensity);
    float RGBSplitNoise = pow(randomNoise(5.1379), 7.1) * _RGBSplit_Indensity;
    float lineNoise = lineNoise1 * lineNoise2 * _Offset - RGBSplitNoise;
    //return vec4(lineNoise);
    
    vec4 colR = texture(iChannel0, uv);
    vec4 colG = texture(iChannel0, uv + vec2(lineNoise * 0.05 * randomNoise(7.), 0.));
    vec4 colB = texture(iChannel0, uv - vec2(lineNoise * 0.05 * randomNoise(23.), 0.));
    
    vec4 re = vec4(vec3(colR.x, colG.y, colB.z), colR.a + colG.a + colB.a);
    re = mix(colR, re, _Fade);
    return re;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec4 col = ImageBlockGlitch_HIGH(uv);

    // Output to screen
    fragColor = col;
}
```

#### 结果

![](后处理技术——故障.assets/4/sqpvu-5x701.gif)



## 错位线条故障（Line Block Glitch）

#### Common

```c++
#define _LinesWidth (0.8) //越小越宽
#define _Amount (0.3) //控制线条数量，1就无了
#define _Offset (0.9) //控制线条的强度
#define _Alpha (0.9) //混合比例

float randomNoise(vec2 seed)
{
    return fract(sin(dot(seed, vec2(1.9898, 7.233))) * 43758.5453123);
}

float trunc(float x, float num_levels)
{
    return floor(x * num_levels) / num_levels;
}

vec2 trunc(vec2 x, vec2 num_levels)
{
    return floor(x * num_levels) / num_levels;
}

vec3 rgb2yuv(vec3 rgb)
{
    vec3 yuv;
    yuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));
    yuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));
    yuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));
    return yuv;
}
	
vec3 yuv2rgb(vec3 yuv)
{
    vec3 rgb;
    rgb.r = yuv.x + yuv.z * 1.13983;
    rgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);
    rgb.b = yuv.x + yuv.y * 2.03211;
    return rgb;
}
```

#### Image

```c++
vec3 LineBlockGlitch(vec2 uv)
{
    float truncTime = trunc(iTime, 4.0);
    float uv_trunc = randomNoise(trunc(uv.yy, vec2(8., 8.)) + vec2(100.0 * truncTime));
    //return vec3(uv_trunc); ------------------------------1
    
    float uv_randomTrunc = 6. * trunc(iTime, 24. * uv_trunc);
    //return vec3(uv_randomTrunc); ------------------------2
    
    float blockLine_random = 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(8. * _LinesWidth, 8. * _LinesWidth)));
    blockLine_random += 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(7., 7.)));
    blockLine_random = blockLine_random * 2.0 - 1.0;	
    blockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4), 0., 1.);
    blockLine_random = mix(0., blockLine_random, _Offset);
    //return vec3(blockLine_random);-----------------------3
    
    vec2 uv_blockLine = uv;
    uv_blockLine = clamp(uv_blockLine + vec2(0.1 * blockLine_random, 0.), 0., 1.);
    
    vec3 col = texture(iChannel0, abs(uv_blockLine)).xyz;
    //return col; -----------------------------------------4
    
    col = rgb2yuv(col);
    col.y /= 2. - 3. * abs(blockLine_random) * clamp(0.5 -  blockLine_random, 0., 1.); //Chrominance
    col.z += 3.25 *  blockLine_random * clamp( blockLine_random - .5, 0., 1.);  //Chroma
    col = yuv2rgb(col);
    col = pow(col, vec3(1. / 2.2));
    
    vec3 ori_col = texture(iChannel0, uv).xyz;
    return mix(ori_col, col, vec3(_Alpha));
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = LineBlockGlitch(uv);

    // Output to screen
    fragColor = vec4(col,1.0);
}
```

#### 结果

![](后处理技术——故障.assets/5/tipwj-qxili.gif)



## 图块抖动故障（Tile Jitter Glitch）

#### Common

```c++
#define IS_DYMIC 0
#define IS_HOR 1
#define SPLIT_DIR 1
#define _Frequency (30.)
#define _SplittingNumber (8.)
#define _JitterSpeed (25.4)
#define _JitterAmount (67.)
#define pixelSizeX (1. / iResolution.x)
```

#### Image

```c++
vec3 TileJitterGlitch(vec2 uv)
{
    float str;
    #if IS_DYMIC
        str = 1.;
    #else
        str = 0.5 + 0.5 * cos(iTime * _Frequency);
    #endif
    
    float dir;
    #if SPLIT_DIR
        dir = mod(uv.y * _SplittingNumber, 2.);
    #else
        dir = mod(uv.x * _SplittingNumber, 2.);
    #endif
    
    if(dir < 1.)
    {
        #if IS_HOR
            uv.x += pixelSizeX * cos(iTime * _JitterSpeed) * _JitterAmount * str;
        #else
            uv.y += pixelSizeX * cos(iTime * _JitterSpeed) * _JitterAmount * str;
        #endif
    }
    return texture(iChannel0, uv).xyz;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = TileJitterGlitch(uv);

    // Output to screen
    fragColor = vec4(col,1.0);
}
```

#### 结果

![](后处理技术——故障.assets/6/de183-by4sp.gif)

////////////////////////////////////////////////////////////////////////////////